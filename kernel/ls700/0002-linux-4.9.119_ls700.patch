diff --git a/Makefile b/Makefile
index dcbf0d1..cd5f42f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 4
 PATCHLEVEL = 9
 SUBLEVEL = 119
-EXTRAVERSION =
+EXTRAVERSION = -buffalo
 NAME = Roaring Lionus
 
 # *DOCUMENTATION*
@@ -391,6 +391,12 @@ LINUXINCLUDE    := \
 		$(if $(KBUILD_SRC), -I$(srctree)/include) \
 		-I$(objtree)/include
 
+BUFFALOINCLUDE := -I$(srctree)/buffalo/arch/$(hdr-arch)/include \
+		-Ibuffalo/arch/$(hdr-arch)/include/generated \
+		-Ibuffalo/include/generated \
+		-I$(srctree)/buffalo/include
+LINUXINCLUDE	+= $(BUFFALOINCLUDE)
+
 LINUXINCLUDE	+= $(filter-out $(LINUXINCLUDE),$(USERINCLUDE))
 
 KBUILD_AFLAGS   := -D__ASSEMBLY__
@@ -1006,6 +1012,7 @@ export mod_sign_cmd
 
 
 ifeq ($(KBUILD_EXTMOD),)
+core-y		+= buffalo/
 core-y		+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
@@ -1387,6 +1394,7 @@ CLEAN_DIRS  += $(MODVERDIR)
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config usr/include include/generated          \
 		  arch/*/include/generated .tmp_objdiff
+MRPRPPER_DIRS  += buffalo/include/generated buffalo/arch/*/include/generated
 MRPROPER_FILES += .config .config.old .version .old_version \
 		  Module.symvers tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS \
 		  signing_key.pem signing_key.priv signing_key.x509	\
@@ -1452,8 +1460,10 @@ rpm: include/config/kernel.release FORCE
 # ---------------------------------------------------------------------------
 
 boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
+boards += $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*_defconfig)
 boards := $(sort $(notdir $(boards)))
 board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs += $(dir $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*/*_defconfig))
 board-dirs := $(sort $(notdir $(board-dirs:/=)))
 
 PHONY += help
diff --git a/README-LS700.txt b/README-LS700.txt
new file mode 100644
index 00000000..9531a8b
--- /dev/null
+++ b/README-LS700.txt
@@ -0,0 +1,16 @@
+BUFFALO LinkStation 700 kernel README
+=====================================
+
+Branch:	linux-4.9.y
+Commit:	8f21ecb4249a0914aea08bef1befca9019a3b44b
+Tag:	v4.9.119
+Description:
+	Base revision of Realtek SDK for rtd161x (2020/04/28)
+
+Branch: develop-4.9.y+realtek-sdk-rtd161x+buffalo-ls700
+Commit: HEAD
+Tag:	(not-yet)
+Description:
+	Development line of LS700 kernel. This is 'linux-4.9.119'
+	source + Realtek SDK for rtd161x (2020/04/28) + BUFFALO
+	specific patches.
diff --git a/README-TSx010.txt b/README-TSx010.txt
new file mode 100644
index 00000000..af70ef1
--- /dev/null
+++ b/README-TSx010.txt
@@ -0,0 +1,70 @@
+BUFFALO TeraStation [537]010 Series kernel README
+=================================================
+
+Repository Infomation
+---------------------
+
+Branch:	linux-4.1.y
+Commit:	35327468a79dd9e343eaf7e66cc372f8277b2a84
+Tag:	v4.1.37
+Description:
+	Base revision of Annapurna SDK 6.1
+
+Branch:	develop-4.1.37+alpine-sdk-6.1-sa
+Commit:	72ff845711087fe579e8ae35ad080fada465e2d4
+Tag:	al_storage_adv-al-V_6.1.3-5851039
+Description:
+	Base revision of TS[537]010 series kernel development.
+	This is 'linux-4.1.37' source + patches followed:
+	+ linux-4.1.37-6.1.3-5851039.patch
+
+Branch: develop-4.1.37+alpine-sdk-6.1-sa+buffalo-ts5010
+Commit: HEAD
+Tag:	(not-yet)
+Description:
+	Development line of TS[537]010 series kernel.
+
+How to build the standalone kernel
+-----------------------------------
+This section describes how to build standalone (not packaged) kernel, DTBs,
+modules.  See [How to build kernel debian package] section instead, if you
+want kernel packages.
+
+Abstract of kernel building step is followed:
+
+* make *_defconfig
+* make uImage dtbs modules
+* make modules_install
+
+typical build script is followed:
+
+<pre>
+#!/bin/sh
+ARCH="arm"
+#MACHINE=alpine
+MACHINE=ts5010
+CROSS_COMPILE=arm-linux-gnueabihf-
+BUILDDIR="${HOME}/obj/${ARCH}/${MACHINE}"
+MODULEDIR="${BUILDDIR}/modules"
+MAKEOPTS="V=1 ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} O=${BUILDDIR}"
+export ARCH CROSS_COMPILE
+
+mkdir -p ${BUILDDIR} ${MODULEDIR}
+
+case "${MACHINE}" in
+alpine) DEFCONFIG=alpine_defconfig;;
+*)      DEFCONFIG=buffalo_ts5010_defconfig;;
+esac
+
+make ${MAKEOPTS} ${DEFCONFIG} || exit 1
+make ${MAKEOPTS} uImage dtbs modules || exit 1
+make ${MAKEOPTS} INSTALL_MOD_PATH=${MODULEDIR} modules_install || exit 1
+</pre>
+
+
+How to build kernel debian package
+----------------------------------
+Debian style kernel packages for ubuntu-14.04 can be built by script
+named "debiansize.sh".  At the top of kernel source tree, ivoke:
+
+	sh buffalo/scripts/debianize.sh
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0ad1092..62d01b6 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -2263,3 +2263,5 @@ endif
 source "lib/Kconfig"
 
 source "arch/arm/kvm/Kconfig"
+
+source "buffalo/Kconfig"
diff --git a/arch/arm/boot/compressed/misc.c b/arch/arm/boot/compressed/misc.c
index d4f891f..6dfbc8a 100644
--- a/arch/arm/boot/compressed/misc.c
+++ b/arch/arm/boot/compressed/misc.c
@@ -21,6 +21,11 @@
 #include <linux/compiler.h>	/* for inline */
 #include <linux/types.h>
 #include <linux/linkage.h>
+#ifdef CONFIG_BUFFALO_PLATFORM
+#include "builddate.h"
+const char buffalo_builddate[] =
+	"BUILDDATE=" BUFFALO_BUILD_DATE " " BUFFALO_BUILD_TIME "\n";
+#endif /*CONFIG_BUFFALO_PLATFORM*/
 
 static void putstr(const char *ptr);
 extern void error(char *x);
diff --git a/arch/arm/boot/install.sh b/arch/arm/boot/install.sh
index 2a45092..83bea24a 100644
--- a/arch/arm/boot/install.sh
+++ b/arch/arm/boot/install.sh
@@ -35,6 +35,10 @@ verify "$2"
 verify "$3"
 
 # User may have a custom install script
+if [ -x ${srctree}/buffalo/arch/arm/boot/${INSTALLKERNEL} ]; then
+	# Don't execute /sbin/installkernel on host ubuntu system
+	exec ${srctree}/buffalo/arch/arm/boot/${INSTALLKERNEL} "$@";
+fi
 if [ -x ~/bin/${INSTALLKERNEL} ]; then exec ~/bin/${INSTALLKERNEL} "$@"; fi
 if [ -x /sbin/${INSTALLKERNEL} ]; then exec /sbin/${INSTALLKERNEL} "$@"; fi
 
diff --git a/arch/arm/kernel/reboot.c b/arch/arm/kernel/reboot.c
index d704df8..2e8a5aa 100644
--- a/arch/arm/kernel/reboot.c
+++ b/arch/arm/kernel/reboot.c
@@ -13,6 +13,9 @@
 
 #include <asm/cacheflush.h>
 #include <asm/idmap.h>
+#ifdef CONFIG_BUFFALO_MICON_V3
+#include <buffalo/micon_v3.h>
+#endif	/* CONFIG_BUFFALO_MICON_V3 */
 
 #include "reboot.h"
 
@@ -94,6 +97,11 @@ void soft_restart(unsigned long addr)
 void machine_shutdown(void)
 {
 	disable_nonboot_cpus();
+#if 0	/* XXX: this function is for kexec, maybe it is no need to micon op */
+#ifdef CONFIG_BUFFALO_MICON_V3
+	miconCntl_PowerOff();
+#endif	/* CONFIG_BUFFALO_MICON_V3 */
+#endif
 }
 
 /*
@@ -105,9 +113,27 @@ void machine_halt(void)
 {
 	local_irq_disable();
 	smp_send_stop();
+
+#ifdef CONFIG_BUFFALO_MICON_V3
+	miconCntl_PowerOff();
+#else	/* CONFIG_BUFFALO_MICON_V3 */
+#ifdef CONFIG_BUFFALO_MICON_REBOOT
+	printk(KERN_EMERG "Waiting for MICON halt.\n");
+#endif	/* CONFIG_BUFFALO_MICON_REBOOT */
 	while (1);
+#endif	/* CONFIG_BUFFALO_MICON_V3 */
 }
 
+#ifdef CONFIG_BUFFALO_MICON_REBOOT
+static inline void longdelay(int sec)
+{
+	int i;
+	for (i = 0; i < sec; i++) {
+	    mdelay(1000);
+	    touch_softlockup_watchdog();
+	}
+}
+#endif	/* CONFIG_BUFFALO_MICON_REBOOT */
 /*
  * Power-off simply requires that the secondary CPUs stop performing any
  * activity (executing tasks, handling interrupts). smp_send_stop()
@@ -119,8 +145,16 @@ void machine_power_off(void)
 	local_irq_disable();
 	smp_send_stop();
 
+#ifdef CONFIG_BUFFALO_MICON_V3
+	miconCntl_PowerOff();
+#else	/* CONFIG_BUFFALO_MICON_V3 */
+#ifdef CONFIG_BUFFALO_MICON_REBOOT
+	printk(KERN_EMERG "Waiting for MICON power-off.\n");
+	longdelay(10);	/* wait 10 secends */
+#endif	/* CONFIG_BUFFALO_MICON_REBOOT */
 	if (pm_power_off)
 		pm_power_off();
+#endif	/* CONFIG_BUFFALO_MICON_V3 */
 }
 
 #ifdef CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART
@@ -168,10 +202,18 @@ void machine_restart(char *cmd)
 	 * out to the console drivers */
 	arm_machine_flush_console();
 
+#ifdef CONFIG_BUFFALO_MICON_V3
+	miconCntl_Reboot();
+#else	/* CONFIG_BUFFALO_MICON_V3 */
+#ifdef CONFIG_BUFFALO_MICON_REBOOT
+	printk(KERN_EMERG "Waiting for MICON restart.\n");
+	longdelay(10);	/* wait 10 seconds */
+#endif	/* CONFIG_BUFFALO_MICON_REBOOT */
 	if (arm_pm_restart)
 		arm_pm_restart(reboot_mode, cmd);
 	else
 		do_kernel_restart(cmd);
+#endif	/* CONFIG_BUFFALO_MICON_V3 */
 
 	/* Give a grace period for failure to restart of 1s */
 	mdelay(1000);
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 514dd68..bc82c78 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1191,3 +1191,5 @@ source "arch/arm64/crypto/Kconfig"
 endif
 
 source "lib/Kconfig"
+
+source "buffalo/Kconfig"
diff --git a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-mmnas-megingjord-2GB.dts b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-mmnas-megingjord-2GB.dts
index 81a5e5f..5b7eaab 100755
--- a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-mmnas-megingjord-2GB.dts
+++ b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-mmnas-megingjord-2GB.dts
@@ -211,12 +211,6 @@
 		osd-init = <1>;
 	};
 
-	rtk_usb_power_manager@0 {
-		gpio1: gpio1 {
-			/delete-property/realtek,power-gpio; //gpio48
-		};
-	};
-
 	dwc3_drd: rtk_dwc3_drd@98013200 {
 		dwc3_drd@98020000 {
 			dr_mode = "host"; /*host, peripheral*/
@@ -227,7 +221,6 @@
 	};
 
 	dwc3_u2host: rtk_dwc3_u2host@98013C00 {
-		status = "disabled";
 	};
 
 	dwc3_u3host: rtk_dwc3_u3host@98013E00 {
diff --git a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-sata.dtsi b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-sata.dtsi
index 7d7176e..84fca15 100644
--- a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-sata.dtsi
+++ b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-1619-sata.dtsi
@@ -21,8 +21,8 @@
 				<0x00632211>, <0x00636211>, <0x0063a211>,
 				<0xab762311>, <0xab766311>, <0xab76a311>;
 			tx-driving-tbl = // user can define tx driving here //
-					<0x40aa2011>, <0x40aa6011>, <0x40a8a011>,
-					<0x88aa2111>, <0x88aa6111>, <0x88aaa111>;
+					<0x40a52011>, <0x40a46011>, <0x40a6a011>,
+					<0x585a2111>, <0x484a6111>, <0x387aa111>;
 			rx-sense-tbl = // user can define rx sensitivity here //
 					<0x42100911>, <0x42104911>, <0x42108911>,
 					<0x276a0311>, <0x276a4311>, <0x27668311>;
@@ -41,8 +41,8 @@
 				<0x00632211>, <0x00636211>, <0x0063a211>,
 				<0xab762311>, <0xab766311>, <0xab76a311>;
 			tx-driving-tbl = // user can define tx driving here //
-					<0x40aa2011>, <0x40aa6011>, <0x40a8a011>,
-					<0x88aa2111>, <0x88aa6111>, <0x88aaa111>;
+					<0x40a42011>, <0x40a46011>, <0x40a6a011>,
+					<0x484a2111>, <0x484a6111>, <0x287aa111>;
 			rx-sense-tbl = // user can define rx sensitivity here //
 					<0x42100911>, <0x42104911>, <0x42108911>,
 					<0x276a0311>, <0x276a4311>, <0x27668311>;
diff --git a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx-pcie.dtsi b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx-pcie.dtsi
index e38d7fe..cd6dbca 100644
--- a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx-pcie.dtsi
+++ b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx-pcie.dtsi
@@ -41,7 +41,7 @@
 		<0x60420201>,
 		<0xAB632301>,
 		<0x080C2401>,
-		<0xa8032b01>,
+		<0xb8032b01>,
 		<0x80A11B01>,
 		<0x27e94301>,
 		<0x52f54401>,
@@ -54,7 +54,7 @@
 		<0x60424201>,
 		<0xAB636301>,
 		<0x08106401>,
-		<0xa8036b01>,
+		<0xb8036b01>,
 		<0xf8022801>,
 		<0xf8026801>,
 		<0x69050B01>,
@@ -138,7 +138,7 @@
 		<0x60420201>,
 		<0xAB632301>,
 		<0x080C2401>,
-		<0xa8032b01>,
+		<0xa0032b01>,
 		<0x80A11B01>,
 		<0x27e94301>,
 		<0x52f54401>,
@@ -151,7 +151,7 @@
 		<0x60424201>,
 		<0xAB636301>,
 		<0x08106401>,
-		<0xa8036b01>,
+		<0xa0036b01>,
 		<0xf8022801>,
 		<0xf8026801>,
 		<0x69050B01>,
diff --git a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx.dtsi b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx.dtsi
index aaa544b..cdf788a 100644
--- a/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx.dtsi
+++ b/arch/arm64/boot/dts/realtek/rtd16xx/rtd-16xx.dtsi
@@ -443,7 +443,7 @@
 		reg = <0x0 0x98007000 0x0 0x100>,
 			<0x0 0x98007100 0x0 0x100>; /* ISO_SYS ISO_GPIO*/
 		gpio-ranges = <&pinctrl 0 0 86>;
-		wakeup-gpio-list = <&rtk_iso_gpio 10 0 1>,<&rtk_iso_gpio 26 0 1>;
+		wakeup-gpio-list = <&rtk_iso_gpio 2 0 1>,<&rtk_iso_gpio 45 0 1>;
 		wakeup-gpio-enable = <1>, <1>;
 		wakeup-gpio-activity = <0>, <0>;
 		status = "okay";
@@ -710,7 +710,7 @@
 			clksrc_div = <0x1>; //default OSD: from 0x0 to 0xf
 			duty_rate = <50>; //default duty_rate 0 ~ 100
 
-			default-loc = <0>;
+			default-loc = <1>;
 			pinctrl-names = "loc-0-enable",
 					"loc-0-disable",
 					"loc-1-enable",
@@ -726,7 +726,7 @@
 			clksrc_div = <0x1>; //default OSD: from 0x0 to 0xf
 			duty_rate = <50>; //default duty_rate 0 ~ 100
 
-			default-loc = <0>;
+			default-loc = <1>;
 			pinctrl-names = "loc-0-enable",
 					"loc-0-disable",
 					"loc-1-enable",
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index a4ac7ba..8deb9f8 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -2784,3 +2784,5 @@ source "crypto/Kconfig"
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "buffalo/Kconfig"
diff --git a/arch/x86/boot/install.sh b/arch/x86/boot/install.sh
index d13ec1c..a3e0981 100644
--- a/arch/x86/boot/install.sh
+++ b/arch/x86/boot/install.sh
@@ -33,6 +33,10 @@ verify "$3"
 
 # User may have a custom install script
 
+if [ -x ${srctree}/buffalo/arch/x86/boot/${INSTALLKERNEL} ]; then
+	# Don't execute /sbin/installkernel on host ubuntu system
+	exec ${srctree}/buffalo/arch/x86/boot/${INSTALLKERNEL} "$@";
+fi
 if [ -x ~/bin/${INSTALLKERNEL} ]; then exec ~/bin/${INSTALLKERNEL} "$@"; fi
 if [ -x /sbin/${INSTALLKERNEL} ]; then exec /sbin/${INSTALLKERNEL} "$@"; fi
 
diff --git a/block/blk-core.c b/block/blk-core.c
index c13af61..b1216cd 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -39,6 +39,9 @@
 
 #include "blk.h"
 #include "blk-mq.h"
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include <buffalo/kernevnt.h>
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
 
 #include <linux/math64.h>
 
@@ -1901,6 +1904,28 @@ static inline int bio_check_eod(struct bio *bio, unsigned int nr_sectors)
 		goto end_io;
 	}
 
+#ifdef CONFIG_BUFFALO_IOERRS
+	if (bio->bi_bdev->bd_disk->limit_io_errors > 0 &&
+	    (bio->bi_bdev->bd_disk->io_errors > bio->bi_bdev->bd_disk->limit_io_errors)) {
+		//printk("%s:io error limit\n",bdevname(bio->bi_bdev, b));
+#ifdef CONFIG_BUFFALO_ALPINE_PLATFORM
+		/* NOTE: (Temporary Fix)
+		 *	Skip setting the QUEUE_FLAG_DEAD flag here, because
+		 *	this setting causes process hang-up when opening
+		 *	'/dev/sd*' device file at Alpine platform by unknown
+		 *	reason.  Instead, stop issueing 'ioerror' event
+		 *	when ioerror counter reaches its limit.
+		 *	See NOTE in blk_update_request() function below.
+		 */
+#else /* CONFIG_BUFFALO_ALPINE_PLATFORM */
+		set_bit(QUEUE_FLAG_DEAD, &q->queue_flags);
+#endif /* CONFIG_BUFFALO_ALPINE_PLATFORM */
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		kernevnt_DriveDead(bdevname(bio->bi_bdev, b));
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
+		goto end_io;
+	}
+#endif	/* CONFIG_BUFFALO_IOERRS */
 	part = bio->bi_bdev->bd_part;
 	if (should_fail_request(part, bio->bi_iter.bi_size) ||
 	    should_fail_request(&part_to_disk(part)->part0,
@@ -2615,6 +2640,31 @@ bool blk_update_request(struct request *req, int error, unsigned int nr_bytes)
 
 	}
 
+#ifdef CONFIG_BUFFALO_IOERRS
+	if (error && req->cmd_type != REQ_TYPE_BLOCK_PC && req->rq_disk) {
+#ifdef CONFIG_BUFFALO_ERRCNT
+		if (atomic_inc_return(&req->rq_disk->nr_errs) < 0)
+			atomic_set(&req->rq_disk->nr_errs, INT_MAX);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#ifdef CONFIG_BUFFALO_ALPINE_PLATFORM
+		if (req->rq_disk->io_errors > req->rq_disk->limit_io_errors) {
+			/* NOTE: (Temporary Fix)
+			 *	Stop issueing 'ioerror' event when io_erroes
+			 *	counter reaches its limit, to avoid process
+			 *	hang-up at open() system-call for disk-device
+			 *	on Alpine Platform.
+			 */
+			;
+		} else
+#endif /* CONFIG_BUFFALO_ALPINE_PLATFORM */
+		kernevnt_IOErr(req->rq_disk->disk_name,
+			       (rq_data_dir(req) == WRITE) ? "WRITE" : "READ",
+			       (unsigned long long)blk_rq_pos(req),
+			       ++req->rq_disk->io_errors);
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
+	}
+#endif	/* CONFIG_BUFFALO_IOERRS */
 	blk_account_io_completion(req, nr_bytes);
 
 	total_bytes = 0;
diff --git a/block/genhd.c b/block/genhd.c
index fcd6d4f..4b6e2bb 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -1005,6 +1005,74 @@ static ssize_t disk_discard_alignment_show(struct device *dev,
 	return sprintf(buf, "%d\n", queue_discard_alignment(disk->queue));
 }
 
+#ifdef CONFIG_BUFFALO_IOERRS
+static ssize_t disk_io_error_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%u\n", disk->io_errors);
+}
+
+static ssize_t disk_limit_io_error_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%u\n", disk->limit_io_errors);
+}
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)			\
+ssize_t __FUNC(struct device *dev, struct device_attribute *attr,	\
+	       const char *buf, size_t count)				\
+{									\
+	struct gendisk *disk = dev_to_disk(dev);			\
+	unsigned int __data;						\
+	char *p = (char *) buf;						\
+									\
+	__data = simple_strtoul(p, &p, 10);				\
+	if (__data < (MIN))						\
+		__data = (MIN);						\
+	else if (__data > (MAX))					\
+		__data = (MAX);						\
+	if (__CONV)							\
+		*(__PTR) = msecs_to_jiffies(__data);			\
+	else								\
+		*(__PTR) = __data;					\
+	return count;							\
+}
+
+static STORE_FUNCTION(disk_io_error_store, &disk->io_errors, 0, UINT_MAX, 0)
+static STORE_FUNCTION(disk_limit_io_error_store, &disk->limit_io_errors, 0, UINT_MAX, 0)
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+static ssize_t disk_nr_errs_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%d\n", atomic_read(&disk->nr_errs));
+}
+
+static ssize_t disk_nr_errs_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	long n;
+	char *e, *p = (char *) buf;
+
+	n = simple_strtoul(p, &e, 10);
+	if (*p && (*e == 0 || *e == '\n') && n >= 0 ) {
+		atomic_set(&disk->nr_errs, n);
+		return count;
+	}
+	return -EINVAL;
+}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
 static DEVICE_ATTR(range, S_IRUGO, disk_range_show, NULL);
 static DEVICE_ATTR(ext_range, S_IRUGO, disk_ext_range_show, NULL);
 static DEVICE_ATTR(removable, S_IRUGO, disk_removable_show, NULL);
@@ -1027,6 +1095,13 @@ static DEVICE_ATTR(badblocks, S_IRUGO | S_IWUSR, disk_badblocks_show,
 	__ATTR(io-timeout-fail,  S_IRUGO|S_IWUSR, part_timeout_show,
 		part_timeout_store);
 #endif
+#ifdef CONFIG_BUFFALO_IOERRS
+static DEVICE_ATTR(io_errors, S_IRUGO|S_IWUSR, disk_io_error_show, disk_io_error_store);
+static DEVICE_ATTR(limit_io_errors, S_IRUGO|S_IWUSR, disk_limit_io_error_show, disk_limit_io_error_store);
+#ifdef CONFIG_BUFFALO_ERRCNT
+static DEVICE_ATTR(nr_errs, S_IRUGO|S_IWUSR, disk_nr_errs_show, disk_nr_errs_store);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
 
 static struct attribute *disk_attrs[] = {
 	&dev_attr_range.attr,
@@ -1046,6 +1121,13 @@ static DEVICE_ATTR(badblocks, S_IRUGO | S_IWUSR, disk_badblocks_show,
 #ifdef CONFIG_FAIL_IO_TIMEOUT
 	&dev_attr_fail_timeout.attr,
 #endif
+#ifdef CONFIG_BUFFALO_IOERRS
+	&dev_attr_io_errors.attr,
+	&dev_attr_limit_io_errors.attr,
+#ifdef CONFIG_BUFFALO_ERRCNT
+	&dev_attr_nr_errs.attr,
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
 	NULL
 };
 
@@ -1322,6 +1404,9 @@ struct gendisk *alloc_disk_node(int minors, int node_id)
 		}
 
 		disk->minors = minors;
+#ifdef CONFIG_BUFFALO_ERRCNT
+		atomic_set(&disk->nr_errs, 0);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		rand_initialize_disk(disk);
 		disk_to_dev(disk)->class = &block_class;
 		disk_to_dev(disk)->type = &disk_type;
diff --git a/buffalo/Kconfig b/buffalo/Kconfig
new file mode 100644
index 00000000..7723aa4
--- /dev/null
+++ b/buffalo/Kconfig
@@ -0,0 +1,140 @@
+menu "BUFFALO Features"
+
+config BUFFALO_PLATFORM
+	bool "BUFFALO_PLATFORM"
+	---help---
+	  Hardware/Software is for BUFFALO platfrom
+
+config BUFFALO_USE_KERNEVNT
+	bool "BUFFALO_USE_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  Use kernelevent
+
+config BUFFALO_USE_MD_KERNEVNT
+	bool "BUFFALO_USE_MD_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_DEGRADE_KERNEVNT
+	bool "BUFFALO_USE_MD_DEGRADE_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_SCAN_KERNEVNT
+	bool "BUFFALO_USE_MD_SCAN_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_REBUILD_KERNEVNT
+	bool "BUFFALO_USE_MD_REBUILD_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_ERRCNT
+	bool "BUFFALO_ERRCNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_IOERRS
+	---help---
+	disk I/O error counter and auto MD degrading.	 
+
+config BUFFALO_USE_UPS
+	bool "BUFFALO_USE_UPS"
+	depends on BUFFALO_PLATFORM
+	---help---
+	Enable kernel support of ups shutdown.
+
+config BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+       bool "BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN"
+       depends on BUFFALO_USE_UPS
+       default n
+       ---help---
+	 Support OMRON UPS
+
+config BUFFALO_SUPPORT_UPS_RECOVER
+       bool "BUFFALO_SUPPORT_UPS_RECOVER"
+       depends on BUFFALO_USE_UPS
+       default n
+       ---help---
+	 Support /proc/buffalo/ups/ups_recover
+
+config BUFFALO_DUPLICATE_SUPERBLOCK_DEBUG
+	bool "BUFFALO_DUPLICATE_SUPERBLOCK_DEBUG"
+	depends on BUFFALO_DUPLICATE_SUPERBLOCK
+	---help---
+	  enable duplicate superblock debug mode.
+
+config BUFFALO_UBOOT_PARAMS
+	bool "BUFFALO_UBOOT_PARAMS"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  add u-boot parameters
+
+config BUFFALO_IOERRS
+	bool "BUFFALO_IOERRS"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  disk I/O error counter
+
+config BUFFALO_SKIP_RESYNC
+	bool "BUFFALO_SKIP_RESYNC"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  skip resync of md device
+
+config BUFFALO_IGNORE_LUN
+	bool "BUFFALO_IGNORE_LUN"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  ignore lun of SCSI device
+
+config BUFFALO_SCSI_GUID
+	bool "BUFFALO_SCSI_GUID"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  add guid of SCSI device
+
+config BUFFALO_EXT23_EXTENSION
+	bool "BUFFALO_EXT23_EXTENSION"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  extend ext2/ext3 magic number
+
+choice BUFFALO_SATA_HOTPLUG_EVENT_CHOICE
+	prompt "support SATA HOTPLUG EVENT"
+	depends on BUFFALO_SATA_HOTPLUG_EVENT
+	default BUFFALO_SATA_HOTPLUG_EVENT_INTERRUPT
+
+config BUFFALO_SATA_HOTPLUG_EVENT_INTERRUPT
+	bool "SATA HOTPLUG EVENT INTERRUPT"
+
+config BUFFALO_SATA_HOTPLUG_EVENT_POLLING
+	bool "SATA HOTPLUG EVENT POLLING"
+
+endchoice
+
+config BUFFALO_SUPPORT_WOL
+	bool "BUFFALO_SUPPORT_WOL"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  Support WOL function.
+	  Below is supported phy lists.
+	    1318
+
+config BUFFALO_DISCONIRQ
+	bool "BUFFALO_DISCONIRQ"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  disable interrupt for ttyS0/COM1/IRQ11
+
+source "buffalo/arch/$SRCARCH/Kconfig"
+
+endmenu
diff --git a/buffalo/Makefile b/buffalo/Makefile
new file mode 100644
index 00000000..6376ae6
--- /dev/null
+++ b/buffalo/Makefile
@@ -0,0 +1,3 @@
+obj-y					+= drivers/
+
+include $(srctree)/buffalo/arch/$(SRCARCH)/Makefile
diff --git a/buffalo/arch/arm/Kconfig b/buffalo/arch/arm/Kconfig
new file mode 100644
index 00000000..32e5af0
--- /dev/null
+++ b/buffalo/arch/arm/Kconfig
@@ -0,0 +1,44 @@
+config BUFFALO_SUPPORT_BOARD_INFO
+	 bool "support board info from kernel"
+	 depends on BUFFALO_PLATFORM
+	 depends on ARM
+	 default y
+	 ---help---
+	  BUFFALO board information
+
+config BUFFALO_ALPINE_PLATFORM
+	bool "ALPINE_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on ARCH_ALPINE
+	---help---
+	  for TS5x10 (featured Annapurna alpine SoC)
+
+config BUFFALO_USE_MICON
+	bool "USE MICON control"
+	depends on ARM
+	default y
+	---help---
+	  BUFFALO Micon
+
+config BUFFALO_MICON_V3
+	bool "featuring Micon version 3"
+	depends on BUFFALO_USE_MICON
+	depends on BUFFALO_ALPINE_PLATFORM
+	default y
+	---help---
+	  BUFFALO Micon version 3
+
+config BUFFALO_MICON_V3_DEVTTY
+	string "tty device name used by Micon v3"
+	depends on BUFFALO_MICON_V3
+	default "/dev/ttyS1"
+	---help---
+	  Micon connected tty device name
+
+config BUFFALO_MICON_REBOOT
+	bool "USE MICON level reboot"
+	depends on BUFFALO_PLATFORM
+	depends on ARCH_ALPINE
+	default n
+	---help---
+	    Uer Micon level reboot instead of kernel level reboot.
diff --git a/buffalo/arch/arm/Makefile b/buffalo/arch/arm/Makefile
new file mode 100644
index 00000000..db48cf8
--- /dev/null
+++ b/buffalo/arch/arm/Makefile
@@ -0,0 +1,4 @@
+# Note:	This file is included from $(srctree)/buffalo/Makefile,
+#	you have to specify relatively from $(srctree)/buffalo
+
+obj-$(CONFIG_BUFFALO_ALPINE_PLATFORM)	+= arch/arm/plat-alpine/
diff --git a/buffalo/arch/arm/boot/installkernel b/buffalo/arch/arm/boot/installkernel
new file mode 100644
index 00000000..b38fa11
--- /dev/null
+++ b/buffalo/arch/arm/boot/installkernel
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# "make install" script for arm architecture
+#
+# Arguments:
+#   $1 - kernel version
+#   $2 - kernel image file
+#   $3 - kernel map file
+#   $4 - default install path (blank if root directory)
+#
+
+cp $2 $4
diff --git a/buffalo/arch/arm/configs/buffalo_ts5010_defconfig b/buffalo/arch/arm/configs/buffalo_ts5010_defconfig
new file mode 100644
index 00000000..dd015ee
--- /dev/null
+++ b/buffalo/arch/arm/configs/buffalo_ts5010_defconfig
@@ -0,0 +1,291 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_LDM_PARTITION=y
+CONFIG_ARCH_ALPINE=y
+CONFIG_ARM_LPAE=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_INTERNAL_ALPINE=y
+CONFIG_PCI_EXTERNAL_ALPINE=y
+CONFIG_SMP=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE_MADVISE is not set
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_MASQUERADE_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_BRIDGE_EBT_BROUTE is not set
+# CONFIG_BRIDGE_EBT_T_FILTER is not set
+# CONFIG_BRIDGE_EBT_T_NAT is not set
+# CONFIG_BRIDGE_EBT_802_3 is not set
+# CONFIG_BRIDGE_EBT_AMONG is not set
+# CONFIG_BRIDGE_EBT_ARP is not set
+# CONFIG_BRIDGE_EBT_IP is not set
+# CONFIG_BRIDGE_EBT_LIMIT is not set
+# CONFIG_BRIDGE_EBT_MARK is not set
+# CONFIG_BRIDGE_EBT_PKTTYPE is not set
+# CONFIG_BRIDGE_EBT_STP is not set
+# CONFIG_BRIDGE_EBT_VLAN is not set
+# CONFIG_BRIDGE_EBT_ARPREPLY is not set
+# CONFIG_BRIDGE_EBT_DNAT is not set
+# CONFIG_BRIDGE_EBT_MARK_T is not set
+# CONFIG_BRIDGE_EBT_REDIRECT is not set
+# CONFIG_BRIDGE_EBT_SNAT is not set
+# CONFIG_BRIDGE_EBT_LOG is not set
+# CONFIG_BRIDGE_EBT_NFLOG is not set
+# CONFIG_BRIDGE is not set
+CONFIG_VLAN_8021Q=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_BLOCK2MTD=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_AL=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=8
+CONFIG_BLK_DEV_RAM_SIZE=131072
+CONFIG_RAID_ATTRS=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_ATA=y
+# CONFIG_SATA_PMP is not set
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_ALPINE=y
+CONFIG_SATA_SIL24=m
+CONFIG_SATA_MV=y
+CONFIG_MD=y
+CONFIG_MD_RAID0=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_RAID=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_UEVENT=y
+CONFIG_TARGET_CORE=m
+CONFIG_ISCSI_TARGET=m
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_NET_TEAM=m
+CONFIG_NET_TEAM_MODE_BROADCAST=m
+CONFIG_NET_TEAM_MODE_ROUNDROBIN=m
+CONFIG_NET_TEAM_MODE_RANDOM=m
+CONFIG_NET_TEAM_MODE_ACTIVEBACKUP=m
+CONFIG_NET_TEAM_MODE_LOADBALANCE=m
+# CONFIG_TUN is not set
+# CONFIG_VHOST_NET is not set
+CONFIG_NET_AL_ETH=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_AT803X_PHY=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_HW_RANDOM=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_PL061=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_POWER_RESET=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_AL_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_EDAC=y
+CONFIG_EDAC_MM_EDAC=y
+CONFIG_EDAC_AL_MC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RX8010=y
+CONFIG_DMADEVICES=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_AL_DMA=y
+CONFIG_AL_DMA_STATS=y
+CONFIG_AL_DMA_PCI_IOV=y
+CONFIG_UIO=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_MEMORY=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLBFS is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_ECRYPT_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_MINIX_FS=y
+CONFIG_ROMFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+CONFIG_CIFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=7
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_KEYS=y
+CONFIG_ENCRYPTED_KEYS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_DEV_AL_CRYPTO=y
+CONFIG_CRYPTO_DEV_AL_CRYPTO_STATS=y
+CONFIG_LIBCRC32C=y
+CONFIG_LOCALVERSION="-6.1.3-5851039_sa"
+CONFIG_XFS_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_NET_MQ_TX_LOCK_OPT is not set
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_KVM is not set
+# CONFIG_CAIF is not set
+# CONFIG_CAIF_VIRTIO is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_ARM_PAGE_SIZE_LARGE=y
+CONFIG_LFS_ON_32CPU=y
+CONFIG_BTRFS_FS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTACTL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_USE_UPS=y
+CONFIG_BUFFALO_SUPPORT_UPS_RECOVER=y
+# CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN is not set
+# CONFIG_BUFFALO_UBOOT_PARAMS is not set
+CONFIG_BUFFALO_IOERRS=y
+CONFIG_BUFFALO_SKIP_RESYNC=y
+CONFIG_BUFFALO_IGNORE_LUN=y
+CONFIG_BUFFALO_SCSI_GUID=y
+CONFIG_BUFFALO_EXT23_EXTENSION=y
+# CONFIG_BUFFALO_SUPPORT_WOL is not set
+CONFIG_BUFFALO_SUPPORT_BOARD_INFO=y
+CONFIG_BUFFALO_ALPINE_PLATFORM=y
+# CONFIG_BUFFALO_USE_MICON is not set
+# CONFIG_BUFFALO_MICON_V3 is not set
+# CONFIG_BUFFALO_MICON_V3_DEVTTY is not set
+CONFIG_BUFFALO_MICON_REBOOT=y
diff --git a/buffalo/arch/arm/plat-alpine/Makefile b/buffalo/arch/arm/plat-alpine/Makefile
new file mode 100644
index 00000000..56bafc7
--- /dev/null
+++ b/buffalo/arch/arm/plat-alpine/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_BUFFALO_ALPINE_PLATFORM)	+= sysfs.o
diff --git a/buffalo/arch/arm/plat-alpine/sysfs.c b/buffalo/arch/arm/plat-alpine/sysfs.c
new file mode 100644
index 00000000..5520b46
--- /dev/null
+++ b/buffalo/arch/arm/plat-alpine/sysfs.c
@@ -0,0 +1,35 @@
+/*
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/sysfs.h>
+
+static struct class *ts5010_cls = NULL;
+
+static int
+init_sysfs_files(void)
+{
+	/* create /sys/class/ts5010 */
+	ts5010_cls = class_create(THIS_MODULE, "ts5010");
+
+	return 0;
+}
+
+static int __init
+ts5010_platform_init(void)
+{  	
+	return init_sysfs_files();
+}
+
+static void __exit
+ts5010_platform_exit(void)
+{
+	class_destroy(ts5010_cls);
+}
+
+module_init(ts5010_platform_init);
+module_exit(ts5010_platform_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BUFFALO");
diff --git a/buffalo/arch/arm64/Kconfig b/buffalo/arch/arm64/Kconfig
new file mode 100644
index 00000000..afb9586
--- /dev/null
+++ b/buffalo/arch/arm64/Kconfig
@@ -0,0 +1,14 @@
+config BUFFALO_SUPPORT_BOARD_INFO
+	bool "support board info from kernel"
+	depends on BUFFALO_PLATFORM
+	depends on ARM64
+	default y
+	---help---
+	  BUFFALO board information
+
+config BUFFALO_RTD16xx_PLATFORM
+	bool "RTD16xx_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on ARCH_RTD16xx
+	---help---
+	  for LS700 (featured Realtek RTD16xx SoC)
diff --git a/buffalo/arch/arm64/Makefile b/buffalo/arch/arm64/Makefile
new file mode 100644
index 00000000..7ea87ce
--- /dev/null
+++ b/buffalo/arch/arm64/Makefile
@@ -0,0 +1,4 @@
+# Note:	This file is included from $(srctree)/buffalo/Makefile,
+#	you have to specify relatively from $(srctree)/buffalo
+
+obj-$(CONFIG_BUFFALO_RTD16xx_PLATFORM)	+= arch/arm64/plat-rtd16xx/
diff --git a/buffalo/arch/arm64/configs/buffalo_ls700_defconfig b/buffalo/arch/arm64/configs/buffalo_ls700_defconfig
new file mode 100644
index 00000000..c92aed6
--- /dev/null
+++ b/buffalo/arch/arm64/configs/buffalo_ls700_defconfig
@@ -0,0 +1,566 @@
+CONFIG_CROSS_COMPILE="aarch64-linux-"
+CONFIG_DEFAULT_HOSTNAME="Realtek-SoC"
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_RCU_EXPERT=y
+CONFIG_RCU_FANOUT=32
+CONFIG_IKCONFIG=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_NAMESPACES=y
+CONFIG_CRASHLOG=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_KALLSYMS_UNCOMPRESSED=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_STRIPPED=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ARCH_RTD16xx=y
+CONFIG_PCI=y
+CONFIG_PCIE_RTD16xx_SLOT1=y
+CONFIG_PCIE_RTD16xx_SLOT2=y
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NR_CPUS=6
+CONFIG_PREEMPT=y
+# CONFIG_COMPACTION is not set
+CONFIG_CMA=y
+CONFIG_CMA_DEBUGFS=y
+CONFIG_ZSMALLOC=y
+CONFIG_SECCOMP=y
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+# CONFIG_ARM64_VHE is not set
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_EFI is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_COMPAT=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_DEBUG=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_DIAG_DESTROY=y
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+# CONFIG_TCP_CONG_WESTWOOD is not set
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_DEFAULT_HTCP=y
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_IPV6_SIT is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETFILTER=y
+# CONFIG_BRIDGE_NETFILTER is not set
+# CONFIG_NETFILTER_INGRESS is not set
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_RTCACHE=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ECN=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_RTK_IR is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_CMA_ALIGNMENT=4
+CONFIG_ARM_CCI400_PMU=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_UID_SYS_STATS=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_ATA=y
+# CONFIG_ATA_VERBOSE_ERROR is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_SATA_AHCI=y
+CONFIG_AHCI_RTK=y
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_BCACHE=m
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=m
+CONFIG_DM_MIRROR=m
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=y
+CONFIG_NET_TEAM=y
+CONFIG_NET_TEAM_MODE_BROADCAST=y
+CONFIG_NET_TEAM_MODE_ROUNDROBIN=y
+CONFIG_NET_TEAM_MODE_RANDOM=y
+CONFIG_NET_TEAM_MODE_ACTIVEBACKUP=y
+CONFIG_NET_TEAM_MODE_LOADBALANCE=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+CONFIG_R8168=m
+CONFIG_R8125=m
+CONFIG_R8169SOC=y
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_USB_NET_DRIVERS=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_RTK=y
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_CAVIUM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_RTK=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_RTK_THERMAL_EOH=y
+CONFIG_WATCHDOG=y
+CONFIG_RTK_WATCHDOG=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_SY8827E=y
+CONFIG_REGULATOR_I2C_SELECTOR=y
+# CONFIG_VGA_ARB is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_COMPRESS_OFFLOAD=m
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VIRMIDI=m
+# CONFIG_SND_REALTEK is not set
+CONFIG_SND_SOC=y
+# CONFIG_HID is not set
+# CONFIG_USB_HID is not set
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_UAS=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_RTK_DWC3_DRD_MODE=y
+CONFIG_RTK_USB_RLE0599_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_MMC=y
+CONFIG_MMC_RTK_EMMC=y
+CONFIG_MMC_RTK_SDMMC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RTK=y
+CONFIG_SYNC_FILE=y
+CONFIG_UIO=y
+CONFIG_UIO_RTK_SE=y
+CONFIG_UIO_RTK_MD=y
+CONFIG_STAGING=y
+# CONFIG_COMMON_CLK_XGENE is not set
+CONFIG_RTK_TIMER=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_SENDFILE_PATCH=y
+CONFIG_RTK_SB2_SECURITY_DEBG=y
+CONFIG_RTK_MCP=y
+# CONFIG_RTK_RPC is not set
+CONFIG_POWER_CONTROL=y
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_PM_DEVFREQ_EVENT=y
+CONFIG_PWM=y
+CONFIG_PWM_RTK=y
+CONFIG_PHY_RTK_SATA=y
+CONFIG_ANDROID=y
+CONFIG_NVMEM=y
+CONFIG_ACPI=y
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_THERMAL is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_F2FS_FS=y
+# CONFIG_F2FS_FS_POSIX_ACL is not set
+# CONFIG_MANDATORY_FILE_LOCKING is not set
+CONFIG_OVERLAY_FS=y
+CONFIG_FSCACHE=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_STRIPPED=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_ECRYPT_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_NFS_V4_1_MIGRATION=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V4=y
+CONFIG_CIFS=y
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_DEBUG is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_MAGIC_SYSRQ_SERIAL is not set
+CONFIG_PAGE_EXTENSION=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_FUNCTION_TRACER=y
+# CONFIG_TRACING_EVENTS_GPIO is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+CONFIG_SECURITY_DMESG_RESTRICT=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_PCRYPT=y
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_CRYPTO_CRC32_ARM64=y
+CONFIG_CRC32_SARWATE=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_TEXTSEARCH=y
+
+#
+# XFS and quota for LS700
+#
+CONFIG_FS_IOMAP=y
+CONFIG_LIBCRC32C=y
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA=y
+CONFIG_QUOTACTL=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_QUOTA=y
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+
+#
+# SquashFS for LS700
+#
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_INFLATE=y
+
+#
+# RAM disk for LS700
+#
+CONFIG_BLK_DEV_RAM_COUNT=8
+CONFIG_BLK_DEV_RAM_SIZE=131072
+
+#
+# Dnotify and Inotify for LS700
+#
+CONFIG_INOTIFY_USER=y
+CONFIG_DNOTIFY=y
+
+#
+# Netfilter for LS700
+#
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_NETFILTER_NETLINK=m
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_NF_NAT_MASQUERADE_IPV4=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+
+#
+# stack protector for LS700
+#
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+
+#
+# /dev for LS700
+#
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+
+#
+# HFS+ and quota for LS700
+#
+CONFIG_HFSPLUS_FS=y
+CONFIG_HFSPLUS_FS_POSIX_ACL=y
+
+#
+# Packet Generator for LS700
+#
+CONFIG_NET_PKTGEN=y
+
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_USE_UPS=y
+# CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN is not set
+CONFIG_BUFFALO_SUPPORT_UPS_RECOVER=y
+# CONFIG_BUFFALO_UBOOT_PARAMS is not set
+CONFIG_BUFFALO_IOERRS=y
+CONFIG_BUFFALO_SKIP_RESYNC=y
+CONFIG_BUFFALO_IGNORE_LUN=y
+CONFIG_BUFFALO_SCSI_GUID=y
+CONFIG_BUFFALO_EXT23_EXTENSION=y
+# CONFIG_BUFFALO_SUPPORT_WOL is not set
+# CONFIG_BUFFALO_DISCONIRQ is not set
+CONFIG_BUFFALO_SUPPORT_BOARD_INFO=y
+CONFIG_BUFFALO_RTD16xx_PLATFORM=y
diff --git a/buffalo/arch/arm64/plat-rtd16xx/Makefile b/buffalo/arch/arm64/plat-rtd16xx/Makefile
new file mode 100644
index 00000000..eaaf3d9d
--- /dev/null
+++ b/buffalo/arch/arm64/plat-rtd16xx/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_BUFFALO_RTD16xx_PLATFORM)	+= sysfs.o
diff --git a/buffalo/arch/arm64/plat-rtd16xx/sysfs.c b/buffalo/arch/arm64/plat-rtd16xx/sysfs.c
new file mode 100644
index 00000000..8a1ec92
--- /dev/null
+++ b/buffalo/arch/arm64/plat-rtd16xx/sysfs.c
@@ -0,0 +1,35 @@
+/*
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/sysfs.h>
+
+static struct class *ls700_cls = NULL;
+
+static int
+init_sysfs_files(void)
+{
+	/* create /sys/class/ls700 */
+	ls700_cls = class_create(THIS_MODULE, "ls700");
+
+	return 0;
+}
+
+static int __init
+ls700_platform_init(void)
+{
+	return init_sysfs_files();
+}
+
+static void __exit
+ls700_platform_exit(void)
+{
+	class_destroy(ls700_cls);
+}
+
+module_init(ls700_platform_init);
+module_exit(ls700_platform_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BUFFALO");
diff --git a/buffalo/arch/x86/Kconfig b/buffalo/arch/x86/Kconfig
new file mode 100644
index 00000000..fe190d3
--- /dev/null
+++ b/buffalo/arch/x86/Kconfig
@@ -0,0 +1,31 @@
+config BUFFALO_MATSU_PLATFORM
+	bool "MATSU_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	---help---
+	  Enable hdd control driver / button control driver for matsu platform.
+
+config BUFFALO_MATSU_USE_EVT_BOARD
+	bool "MATSU_EVT_BOARD"
+	depends on BUFFALO_MATSU_PLATFORM
+	---help---
+	  EVT board and DVT board has difference for GPIO pin.
+	  If this value set to enable, use EVT GPIO settings.
+
+config BUFFALO_KIRI_PLATFORM
+	bool "KIRI_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	---help---
+	  Enable hdd control driver / button control driver for kiri platform.
+
+config BUFFALO_USI_PLATFORM
+	bool "USI_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	---help---
+	  Enable below drivers for usi platform.
+	  * hdd control driver(hot plug / power control)
+	  * fan control driver
+	  * button control driver
+	  * CMOS settings control driver
diff --git a/buffalo/arch/x86/Makefile b/buffalo/arch/x86/Makefile
new file mode 100644
index 00000000..e974bbf
--- /dev/null
+++ b/buffalo/arch/x86/Makefile
@@ -0,0 +1,4 @@
+# Note:	This file is included from $(srctree)/buffalo/Makefile,
+#	you have to specify relatively from $(srctree)/buffalo
+
+obj-$(CONFIG_BUFFALO_USI_PLATFORM)	+= arch/x86/plat-usi/
diff --git a/buffalo/arch/x86/boot/installkernel b/buffalo/arch/x86/boot/installkernel
new file mode 100755
index 00000000..1c5f89b
--- /dev/null
+++ b/buffalo/arch/x86/boot/installkernel
@@ -0,0 +1,83 @@
+#!/bin/sh
+# 
+# Copyright (C) 1995 - 1998, Ian A. Murdock <imurdock@debian.org>
+# Copyright (C) 1998, 1999, Guy Maor
+# Copyright (C) 2002, Matthew Wilcox
+# Copyright (C) 2002, 2004, 2005, 2007, 2009  Clint Adams
+# Copyright (C) 2009  Manoj Srivasta
+#
+# Install the kernel on a Debian Linux system.
+#
+# This script is called from /usr/src/linux/arch/i386/boot/install.sh.
+# If you install it as /sbin/installkernel, you can do a "make install"
+# from a generic kernel source tree, and the image will be installed to
+# the proper place for Debian GNU/Linux.
+
+set -e
+
+# Parse the command line options.  Of course, powerpc has to be all
+# different, and passes in a fifth argument, just because it is
+# "special". We ignore the fifth argument, and do not flag is as an
+# error, which it would be for any arch apart from powerpc
+if [ $# -eq 3 ] || [ $# -eq 4 ] || [ $# -eq 5 ] ; then
+  img="$2"
+  map="$3"
+  ver="$1"
+  if [ $# -ge 4 ] && [ -n "$4" ] ; then
+      dir="$4"
+  else
+      dir="/boot"
+  fi
+else
+  echo "Usage: installkernel <version> <image> <System.map> <directory>"
+  exit 1
+fi
+
+# Create backups of older versions before installing
+updatever () {
+  if [ -f "$dir/$1-$ver" ] ; then
+    mv "$dir/$1-$ver" "$dir/$1-$ver.old"
+  fi
+
+  cat "$2" > "$dir/$1-$ver"
+
+  # This section is for backwards compatibility only
+  if test -f "$dir/$1" ; then
+    # The presence of "$dir/$1" is unusual in modern intallations, and
+    # the results are mostly unused.  So only recreate them if they
+    # already existed.
+    if test -L "$dir/$1" ; then
+        # If we were using links, continue to use links, updating if
+        # we need to.
+        if [ "$(readlink -f ${dir}/${1})" = "${dir}/${1}-${ver}" ]; then
+            # Yup, we need to change
+            ln -sf "$1-$ver.old" "$dir/$1.old"
+        else
+            mv "$dir/$1" "$dir/$1.old"
+        fi
+        ln -sf "$1-$ver" "$dir/$1"
+    else                        # No links
+        mv "$dir/$1" "$dir/$1.old"
+        cat "$2" > "$dir/$1"
+    fi
+  fi
+}
+
+if [ "$(basename $img)" = "vmlinux" ] ; then
+  img_dest=vmlinux
+else
+  img_dest=vmlinuz
+fi
+updatever $img_dest "$img"
+updatever System.map "$map"
+
+config=$(dirname "$map")
+config="${config}/.config"
+if [ -f "$config" ] ; then
+  updatever config "$config"
+fi
+
+#run-parts --verbose --exit-on-error --arg="$ver" --arg="$dir/$img_dest-$ver" \
+#  /etc/kernel/postinst.d
+ 
+exit 0
diff --git a/buffalo/arch/x86/configs/buffalo_ts5000_defconfig b/buffalo/arch/x86/configs/buffalo_ts5000_defconfig
new file mode 100644
index 00000000..3a57f5d
--- /dev/null
+++ b/buffalo/arch/x86/configs/buffalo_ts5000_defconfig
@@ -0,0 +1,3042 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.10.20-buffalo Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_CPU_AUTOPROBE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_FHANDLE is not set
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+CONFIG_RCU_FAST_NO_HZ=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANTS_PROT_NUMA_PROT_NONE=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HOTPLUG=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+# CONFIG_X86_INTEL_LPSS is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_HYPERVISOR_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PROCESSOR_SELECT=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=256
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_NEED_BOUNCE_POOL=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+CONFIG_EFI=y
+# CONFIG_EFI_STUB is not set
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_I2C=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_CUSTOM_DSDT_FILE=""
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_BGRT is not set
+CONFIG_ACPI_APEI=y
+# CONFIG_ACPI_APEI_GHES is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_APEI_MEMORY_FAILURE is not set
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_INTEL_PSTATE is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+CONFIG_X86_POWERNOW_K8=y
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+# CONFIG_ISA_DMA_API is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+
+#
+# Xtables matches
+#
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+# CONFIG_SATA_ZPODD is not set
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_HIGHBANK is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_PATA_ACPI is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+# CONFIG_MD_RAID10 is not set
+CONFIG_MD_RAID456=y
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_MII is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+CONFIG_E1000=y
+CONFIG_E1000E=m
+CONFIG_IGB=y
+CONFIG_IGB_HWMON=y
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_NE2K_PCI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_ISI is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=32
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_DW is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_SMBUS=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=y
+CONFIG_I2C_ALI1563=y
+CONFIG_I2C_ALI15X3=y
+CONFIG_I2C_AMD756=y
+CONFIG_I2C_AMD756_S4882=y
+CONFIG_I2C_AMD8111=y
+CONFIG_I2C_I801=y
+CONFIG_I2C_ISCH=y
+# CONFIG_I2C_ISMT is not set
+CONFIG_I2C_PIIX4=y
+CONFIG_I2C_NFORCE2=y
+CONFIG_I2C_NFORCE2_S4985=y
+CONFIG_I2C_SIS5595=y
+CONFIG_I2C_SIS630=y
+CONFIG_I2C_SIS96X=y
+CONFIG_I2C_VIA=y
+CONFIG_I2C_VIAPRO=y
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=y
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_EG20T=y
+CONFIG_I2C_INTEL_MID=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_PCA_PLATFORM=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=y
+CONFIG_I2C_XILINX=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_PARPORT_LIGHT=y
+CONFIG_I2C_TAOS_EVM=y
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_SPI is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_INTEL_POWERCLAMP is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_LPC_ICH is not set
+CONFIG_LPC_SCH=y
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_SIS is not set
+CONFIG_AGP_VIA=y
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_GEODE=y
+# CONFIG_FB_GEODE_LX is not set
+# CONFIG_FB_GEODE_GX is not set
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_AMD_IOMMU=y
+CONFIG_AMD_IOMMU_STATS=y
+# CONFIG_AMD_IOMMU_V2 is not set
+# CONFIG_INTEL_IOMMU is not set
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+CONFIG_ISCSI_IBFT_FIND=y
+# CONFIG_ISCSI_IBFT is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+# CONFIG_UPROBE_EVENT is not set
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_ASYNC_CORE=y
+CONFIG_ASYNC_MEMCPY=y
+CONFIG_ASYNC_XOR=y
+CONFIG_ASYNC_PQ=y
+CONFIG_ASYNC_RAID6_RECOV=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
+
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+# CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT is not set
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_USE_UPS=y
+# CONFIG_BUFFALO_SUPPORT_UPS_RECOVER is not set
+CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN=y
+# CONFIG_BUFFALO_UBOOT_PARAMS is not set
+CONFIG_BUFFALO_IOERRS=y
+# CONFIG_BUFFALO_SKIP_RESYNC is not set
+# CONFIG_BUFFALO_IGNORE_LUN is not set
+# CONFIG_BUFFALO_SCSI_GUID is not set
+# CONFIG_BUFFALO_EXT23_EXTENSION is not set
+# CONFIG_BUFFALO_SUPPORT_WOL is not set
+# CONFIG_BUFFALO_MATSU_PLATFORM is not set
+# CONFIG_BUFFALO_KIRI_PLATFORM is not set
+CONFIG_BUFFALO_USI_PLATFORM=y
diff --git a/buffalo/arch/x86/configs/buffalo_ts6000_defconfig b/buffalo/arch/x86/configs/buffalo_ts6000_defconfig
new file mode 100644
index 00000000..dc94185
--- /dev/null
+++ b/buffalo/arch/x86/configs/buffalo_ts6000_defconfig
@@ -0,0 +1,1476 @@
+CONFIG_CC_STACKPROTECTOR_REGULAR=y
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_RCU_USER_QS is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_NUMA_BALANCING is not set
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_OPROFILE is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_LDM_PARTITION=y
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_X86_INTEL_LPSS is not set
+# CONFIG_HYPERVISOR_GUEST is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_X86_MCE_INJECT is not set
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+# CONFIG_EFI_STUB is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+CONFIG_HZ=100
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_VIDEO=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_BGRT is not set
+# CONFIG_ACPI_APEI_GHES is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_APEI_MEMORY_FAILURE is not set
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_X86_INTEL_PSTATE is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+# CONFIG_I7300_IDLE is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_PCI_IOV=y
+# CONFIG_ISA_DMA_API is not set
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_RAPIDIO is not set
+CONFIG_BINFMT_MISC=y
+# CONFIG_X86_X32 is not set
+# CONFIG_PACKET_DIAG is not set
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_BIC is not set
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_MASQUERADE_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_MARK is not set
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NETPRIO_CGROUP is not set
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_PKTGEN=y
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+# CONFIG_WIMAX is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_NVME=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=8
+CONFIG_BLK_DEV_RAM_SIZE=131072
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_RAID_ATTRS=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_ISCSI_TCP=m
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+CONFIG_SCSI_MPT3SAS=y
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_SATA_ZPODD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+CONFIG_SATA_SIL24=y
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_ACPI is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+CONFIG_DM_MIRROR=y
+CONFIG_DM_RAID=y
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+CONFIG_TARGET_CORE=m
+CONFIG_ISCSI_TARGET=m
+# CONFIG_FUSION is not set
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_MII is not set
+# CONFIG_IFB is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_ACENIC is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_AQTION=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+# CONFIG_B44 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_BNA is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_ENIC is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_BE2NET is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_HP100 is not set
+# CONFIG_E100 is not set
+CONFIG_E1000=y
+CONFIG_IGB=y
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+CONFIG_IXGBE=y
+# CONFIG_IXGBEVF is not set
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+# CONFIG_R6040 is not set
+# CONFIG_SC92031 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_FDDI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_AT803X_PHY=y
+# CONFIG_AMD_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_ISI is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+CONFIG_I2C_ALI1535=y
+CONFIG_I2C_ALI1563=y
+CONFIG_I2C_ALI15X3=y
+CONFIG_I2C_AMD756=y
+CONFIG_I2C_AMD756_S4882=y
+CONFIG_I2C_AMD8111=y
+CONFIG_I2C_I801=y
+CONFIG_I2C_ISCH=y
+# CONFIG_I2C_ISMT is not set
+CONFIG_I2C_PIIX4=y
+CONFIG_I2C_NFORCE2=y
+CONFIG_I2C_NFORCE2_S4985=y
+CONFIG_I2C_SIS5595=y
+CONFIG_I2C_SIS630=y
+CONFIG_I2C_SIS96X=y
+CONFIG_I2C_VIA=y
+CONFIG_I2C_VIAPRO=y
+CONFIG_I2C_SCMI=y
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_EG20T=y
+CONFIG_I2C_INTEL_MID=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_PCA_PLATFORM=y
+CONFIG_I2C_SIMTEC=y
+CONFIG_I2C_XILINX=y
+CONFIG_I2C_PARPORT_LIGHT=y
+CONFIG_I2C_TAOS_EVM=y
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_SPI is not set
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+CONFIG_PTP_1588_CLOCK=y
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_INTEL_POWERCLAMP is not set
+CONFIG_WATCHDOG=y
+# CONFIG_SSB is not set
+# CONFIG_BCMA is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_LPC_ICH is not set
+CONFIG_LPC_SCH=y
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+# CONFIG_AGP_SIS is not set
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE_LX is not set
+# CONFIG_FB_GEODE_GX is not set
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_SOUND is not set
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_I2C_HID is not set
+CONFIG_USB_COMMON=m
+CONFIG_USB=m
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=m
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+CONFIG_EDAC_MM_EDAC=y
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_AMD_IOMMU_V2 is not set
+# CONFIG_INTEL_IOMMU is not set
+CONFIG_IRQ_REMAP=y
+# CONFIG_STE_MODEM_RPROC is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_ISCSI_IBFT is not set
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_RT is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_NILFS2_FS is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_CUSE is not set
+# CONFIG_FSCACHE is not set
+CONFIG_ISO9660_FS=y
+# CONFIG_UDF_FS is not set
+CONFIG_MSDOS_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=y
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=7
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_UPROBE_EVENT is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_KGDB is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_EARLY_PRINTK_DBGP is not set
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_ASYNC_CORE=y
+CONFIG_ASYNC_MEMCPY=y
+CONFIG_ASYNC_XOR=y
+CONFIG_ASYNC_PQ=y
+CONFIG_ASYNC_RAID6_RECOV=y
+CONFIG_CRYPTO_AEAD=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_CMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_RAID6_PQ=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_USE_UPS=y
+CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN=y
+# CONFIG_BUFFALO_SUPPORT_UPS_RECOVER is not set
+# CONFIG_BUFFALO_UBOOT_PARAMS is not set
+CONFIG_BUFFALO_IOERRS=y
+CONFIG_BUFFALO_SKIP_RESYNC=y
+CONFIG_BUFFALO_IGNORE_LUN=y
+CONFIG_BUFFALO_SCSI_GUID=y
+# CONFIG_BUFFALO_EXT23_EXTENSION is not set
+# CONFIG_BUFFALO_SUPPORT_WOL is not set
+CONFIG_BUFFALO_SUPPORT_BOARD_INFO=y
+# CONFIG_BUFFALO_USE_MICON is not set
+# CONFIG_BUFFALO_MICON_V3 is not set
+# CONFIG_BUFFALO_MICON_V3_DEVTTY is not set
+# CONFIG_BUFFALO_MICON_REBOOT is not set
+# CONFIG_BUFFALO_MATSU_PLATFORM is not set
+# CONFIG_BUFFALO_KIRI_PLATFORM is not set
+CONFIG_BUFFALO_USI_PLATFORM=y
+CONFIG_BUFFALO_DISCONIRQ=y
diff --git a/buffalo/arch/x86/plat-usi/Makefile b/buffalo/arch/x86/plat-usi/Makefile
new file mode 100644
index 00000000..27b1907
--- /dev/null
+++ b/buffalo/arch/x86/plat-usi/Makefile
@@ -0,0 +1,32 @@
+
+# To build modules outside of the kernel tree, we run "make"
+# in the kernel source tree; the Makefile these then includes this
+# Makefile once again.
+# This conditional selects whether we are being included from the
+# kernel Makefile or not.
+ifeq ($(KERNELRELEASE),)
+
+    # Assume the source tree is where the running kernel was built
+    # You should set KERNELDIR in the environment if it's elsewhere
+    KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+    # The current directory is passed to sub-makes as argument
+    PWD := $(shell pwd)
+
+modules:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+
+modules_install:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
+
+.PHONY: modules modules_install clean
+
+else
+	# called from kernel build system: just declare what our modules are
+	obj-$(CONFIG_BUFFALO_USI_PLATFORM) += sugi_platform.o
+
+endif
+
+
diff --git a/buffalo/arch/x86/plat-usi/sugi_platform.c b/buffalo/arch/x86/plat-usi/sugi_platform.c
new file mode 100644
index 00000000..1bac6a3
--- /dev/null
+++ b/buffalo/arch/x86/plat-usi/sugi_platform.c
@@ -0,0 +1,1989 @@
+/*	Sugi Platform Driver - V1.2
+ *
+ * 	Author: Gary Chen
+ *	Date  : 2012/07/11
+ */
+
+
+#include <linux/version.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/errno.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include "sugi_platform.h"
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 1
+ * Description: Global variabls and strctures
+ * ---------------------------------------------------------------------------------------------- */
+
+/* Define for procfs directory and file */
+#if defined(CONFIG_BUFFALO_PLATFORM)
+#include <buffalo/kernevnt.h>
+#endif
+
+
+
+/* **************** Button Driver **************** */
+
+/* declare for file and directory of procfs */
+static struct proc_dir_entry *buffalo_dir;
+static struct proc_dir_entry *gpio_dir;
+static struct proc_dir_entry *switch_dir;
+static struct proc_dir_entry *switch_file[MAX_SUPPORTED_BUTTONS];
+
+/* GPIO set3 base addr */
+static unsigned int it87_gpioset3_base_addr;
+
+/* declare timer function */
+static struct timer_list btn_timer;
+
+/* button information strcture */
+static struct button_info_st button_info[] = {
+	{"func", IT87_DEB0},
+	{"display", IT87_DEB1}
+};
+
+/* ************** Fan Control Driver ************* */
+
+/* class and device nodes */
+struct class *sugi_cls;
+struct device *fan_dev;
+dev_t sugit_fan = MKDEV(sugi_fan_major, sugi_fan_minor);
+
+/* IT8721 EC base address */
+unsigned int EC_BASE_ADDR;
+unsigned int IT87_EC_ADDR_REG;
+unsigned int IT87_EC_DATA_REG;
+
+/* core temp used */
+unsigned int tjmax[2] = {100,100};
+unsigned int eax;
+unsigned int edx;
+
+/* fan, temp information strcture */
+struct fan_info_st fan_info[] =
+{
+	{IT87_EC_FAN_TACO1, IT87_EC_FAN_TACO1_EXT, IT87_EC_FAN_SMART_PWM1, IT87_EC_FAN_PWM1, 0x1},
+	{IT87_EC_FAN_TACO2, IT87_EC_FAN_TACO2_EXT, IT87_EC_FAN_SMART_PWM2, IT87_EC_FAN_PWM2, 0x2},
+};
+
+/* 4 steps of speed */
+static unsigned char fan_stop_speed = 0;
+static unsigned char fan_slow_speed = 150;
+static unsigned char fan_fast_speed = 200;
+static unsigned char fan_full_speed = 255;
+
+/* threshold & flag */
+static unsigned int fan_threshold = 100;
+static unsigned int flag_show_speed_by_string = 1;
+
+/* ************** HDD Control Driver ************* */
+
+/* pci device */
+struct pci_dev *pdev = NULL;
+
+/* declare for file and directory of procfs */
+static struct proc_dir_entry *hotplug_dir;
+static struct proc_dir_entry *power_control_dir;
+static struct proc_dir_entry *hotplug_sata_file[MAX_SUPPORTED_DISKS];
+static struct proc_dir_entry *power_control_hdd_file[MAX_SUPPORTED_DISKS];
+
+/* GPIO base address */
+unsigned int ich10r_gpio_base_addr;
+
+/* polling timer */
+struct timer_list sata_hotplug_polling_timer;
+
+/* hotplug status information strcture */
+struct sata_hotplug_data_st sata_hotplug_data[MAX_SUPPORTED_DISKS];
+
+/* HDD information strcture */
+static struct sugi_hdd_info_st sugi_hdd_info[] = {
+	{GP_LVL,	HDD0_PRESENT_BIT,	GP_LVL,		HDD0_POWER_BIT,	HDD0_POWER_MASK},
+	{GP_LVL,	HDD1_PRESENT_BIT,	GP_LVL,		HDD1_POWER_BIT,	HDD1_POWER_MASK},
+	{GP_LVL,	HDD2_PRESENT_BIT,	GP_LVL,		HDD2_POWER_BIT,	HDD2_POWER_MASK},
+	{GP_LVL,	HDD3_PRESENT_BIT,	GP_LVL,		HDD3_POWER_BIT,	HDD3_POWER_MASK},
+	{GP_LVL,	HDD4_PRESENT_BIT,	GP_LVL2,	HDD4_POWER_BIT,	HDD4_POWER_MASK},
+	{GP_LVL,	HDD5_PRESENT_BIT,	GP_LVL2,	HDD5_POWER_BIT,	HDD5_POWER_MASK},
+	{GP_LVL,	HDD6_PRESENT_BIT,	GP_LVL2,	HDD6_POWER_BIT,	HDD6_POWER_MASK},
+	{GP_LVL,	HDD7_PRESENT_BIT,	GP_LVL2,	HDD7_POWER_BIT,	HDD7_POWER_MASK},
+};
+
+/* ***************** CMOS Driver ***************** */
+/* device nodes */
+struct device *cmos_dev;
+dev_t sugit_cmos = MKDEV(sugi_cmos_major, sugi_cmos_minor);
+
+unsigned int ich10r_pm_base_addr;
+unsigned short afterg3_en;
+
+/* Device ID offset */
+unsigned char device_id_offset[32] = {0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
+																0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
+																0x56, 0x57, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e,
+																0x5f, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c};
+
+/* checksum offset */
+unsigned char checksum_offset[4] = {0x79, 0x7a, 0x7b, 0x7c};
+
+/* ASCII string to integer */																
+struct strtoint_st strtoint_info[] = {
+	{0x30, 0x0}, {0x31, 0x1}, {0x32, 0x2}, {0x33, 0x3},
+	{0x34, 0x4}, {0x35, 0x5}, {0x36, 0x6}, {0x37, 0x7},
+	{0x38, 0x8}, {0x39, 0x9}, {0x61, 0xa}, {0x62, 0xb},
+	{0x63, 0xc}, {0x64, 0xd}, {0x65, 0xe}, {0x66, 0xf},
+	{0x41, 0xa}, {0x42, 0xb}, {0x43, 0xc}, {0x44, 0xd},
+	{0x45, 0xe}, {0x46, 0xf},
+};
+
+static unsigned int bios_ver;
+
+/* *************** Boaed ID Driver *************** */
+
+struct device *boardid_dev;
+dev_t sugit_boardid = MKDEV(sugi_boardid_major, sugi_boardid_minor);
+unsigned int boardid_num;
+
+/* ************* protocol for IT8721 ************* */
+void EnterMBPnP(void)
+{
+	outb(0x87, CONFIG_ADDR_PORT);
+	outb(0x01, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+}
+void ExitMBPnP(void)
+{
+	outb(0x02, CONFIG_ADDR_PORT);
+	outb(0x02, CONFIG_DATA_PORT);
+}
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-1
+ * Description: Implement functions of button driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ************** implement function ************* */
+
+/* ----------- get GPIO status ----------- */
+static int it87_gpio_getsts(int pin)
+{
+	int	off;
+	if(pin == BTN_DISP){
+		off = IT87_GP35_BIT5;	//pin number of DISP button
+	}else{
+		off = IT87_GP34_BIT4;	//pin number of FUNC button
+	}		
+
+	return inb(it87_gpioset3_base_addr) & off;
+}
+
+/* ------------- button timer ------------ */	
+static void timer_function(unsigned long data)
+{
+	int	pin_sts;
+
+	pin_sts=it87_gpio_getsts(data);
+	
+	if(pin_sts){
+	//Clear de-bounce ping SMI status
+		EnterMBPnP();
+		outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+		outb(IT87_DEB0DEB1 | IT87_SMI_STS2_PBD, CONFIG_DATA_PORT);		
+		ExitMBPnP();
+	//Delete timer
+		del_timer(&btn_timer);
+	}
+	else
+		mod_timer(&btn_timer, jiffies + TIMER_DELAY);
+}
+
+/* ---------- get button status ---------- */
+static void *
+sugi_button_status_seq_start(struct seq_file *s, loff_t *pos)
+{
+	return *pos < 1 ? SEQ_START_TOKEN : NULL;
+}
+
+static void *
+sugi_button_status_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	++ *pos;
+	return NULL;
+}
+
+static void
+sugi_button_status_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int
+sugi_button_status_seq_show(struct seq_file *m, void *v)
+{
+	struct button_info_st *button_info = (struct button_info_st *)m->private;
+	unsigned char smi_sts;
+
+	EnterMBPnP();
+
+	//Get SMI status of two de-bounce pin
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+	smi_sts = inb(CONFIG_DATA_PORT);
+	smi_sts &= IT87_SMI_DEB_MASK;
+
+	ExitMBPnP();
+
+	//Check which button was pressed
+	if ((smi_sts & button_info->reg_stat))
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+static const
+struct seq_operations sugi_button_status_seq_ops = {
+	.start	= sugi_button_status_seq_start,
+	.next	= sugi_button_status_seq_next,
+	.stop	= sugi_button_status_seq_stop,
+	.show	= sugi_button_status_seq_show,
+};
+
+static int
+sugi_button_status_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct seq_file *m;
+	struct button_info_st *button_info = (struct button_info_st *)PDE_DATA(inode);
+
+	ret = seq_open_private(file, &sugi_button_status_seq_ops,
+			       sizeof(button_info));
+	if (ret) {
+		return ret;
+	}
+	m = file->private_data;
+	m->private = button_info;
+	return 0;
+}
+
+static const
+struct file_operations sugi_button_status_file_ops = {
+	.open		= sugi_button_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/* ----------- interrupt handler ---------- */
+static irqreturn_t sugi_interrupt(int irq, void *dev_id)
+{
+	int	pin=0;
+	unsigned char smi_sts;
+	
+#ifdef CONFIG_BUFFALO_PLATFORM
+	char msg[32];
+	memset(msg, 0, sizeof(msg));
+#endif
+	
+	/* get SMI status of two de-bounce pin */
+	EnterMBPnP();	
+	
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+	smi_sts = inb(CONFIG_DATA_PORT);
+	
+	ExitMBPnP();
+	
+	/* check if the interrupt source is PBD's IRQ */
+	if(smi_sts & IT87_SMI_STS2_PBD)
+	{
+		smi_sts &= IT87_SMI_DEB_MASK;
+		
+		/* check which button was pressed */
+		if(smi_sts == IT87_DEB0){
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				sprintf(msg, "micon_interrupts");
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			pin = BTN_FUNC;
+		}
+		else if(smi_sts == IT87_DEB1){
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				sprintf(msg, "micon_interrupts");
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			pin = BTN_DISP;
+		}
+		
+		/* setup timer for checking button GPIO status */
+ 		init_timer(&btn_timer);
+		btn_timer.expires = jiffies + TIMER_DELAY;
+		btn_timer.data = pin;
+		btn_timer.function = timer_function;
+		add_timer(&btn_timer);
+		
+		#ifdef CONFIG_BUFFALO_PLATFORM
+			if(msg[0] != '\0')
+				buffalo_kernevnt_queuein(msg);
+		#endif
+	}
+	return IRQ_HANDLED;
+}
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-2
+ * Description: Implement functions of fan control driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ************* implement functions ************* */
+
+/* ----------- get temperature ---------- */
+unsigned int get_temp(unsigned char temp_num)
+{
+	unsigned int	ret = 0;
+	
+	if(temp_num==2){
+		outb(IT87_EC_TMPIN3, IT87_EC_ADDR_REG);
+		ret = inb(IT87_EC_DATA_REG);
+		return ret;
+	}
+	
+	rdmsr_on_cpu(temp_num, MSR_IA32_THERM_STATUS, &eax, &edx);
+	ret = tjmax[temp_num] - ((eax >> 16)&0x7f);
+	
+	return ret;
+}
+
+/* ---------- get rotation speed --------- */
+unsigned int get_fan_rpm(unsigned char fan_num)
+{
+	unsigned int	read_value;
+	unsigned int	read_value_ext;
+	unsigned int	ret = 0;
+	
+	outb(fan_info[fan_num].reg, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	outb(fan_info[fan_num].reg_ext, IT87_EC_ADDR_REG);
+	read_value_ext = inb(IT87_EC_DATA_REG);
+	ret = 1350000/(read_value_ext*256+read_value)/2;
+
+	if(ret < fan_threshold)
+		ret = 0;
+	
+	return ret;
+}
+
+/* -------------- get speed -------------- */
+unsigned int get_fan_speed(unsigned char fan_num)
+{
+	unsigned int	read_value;
+
+		
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+
+	return read_value;
+}
+
+/* -------------- set speed -------------- */
+unsigned int set_fan_speed(unsigned char fan_num, unsigned char set_val)
+{
+	unsigned int	write_data;
+	unsigned char	read_value;
+
+	/*if(fan_info[fan_num].reg_smart_pwm == 0 ||
+		fan_info[fan_num].reg_pwm == 0)
+	{
+		return -EINVAL;
+	}*/
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	write_data = set_val;
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	outb(write_data, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value &= 0x7F;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	return 0;
+}
+
+/* --------- convert string to ul -------- */
+static unsigned long fan_speed_str_to_ul(char *buf)
+{
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len == 5) && (strncmp(buf, "stop", strlen("stop")) == 0))
+		return fan_stop_speed;
+	else if((len == 5) && (strncmp(buf, "slow", strlen("slow")) == 0))
+		return fan_slow_speed;
+	else if((len == 5) && (strncmp(buf, "fast", strlen("fast")) == 0))
+		return fan_fast_speed;
+	else if((len == 5) && (strncmp(buf, "full", strlen("full")) == 0))
+		return fan_full_speed;
+
+	return simple_strtoul(buf, NULL, 10);
+}
+
+/* --------- convert ul to string -------- */
+static unsigned long fan_speed_ul_to_str(char *buf, size_t len, unsigned long speed)
+{
+	if(speed <= fan_stop_speed)
+		snprintf(buf, len, "stop");
+	else if(speed > fan_stop_speed && speed <= fan_slow_speed)
+		snprintf(buf, len, "slow");
+	else if(speed > fan_slow_speed && speed <= fan_fast_speed)
+		snprintf(buf, len, "fast");
+	else if(speed > fan_fast_speed)
+		snprintf(buf, len, "full");
+	else
+		snprintf(buf, len, "Unknown");
+		
+	return 0;
+}
+
+/* ************** device attributes ************** */
+
+/* -------- temperature attributes ------- */
+static ssize_t show_temp1(struct device *dev, struct device_attribute *attr, char *buf)
+
+{
+	return sprintf(buf, "%d\n", get_temp(0));
+}
+
+static ssize_t show_temp2(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(1));
+}
+
+static ssize_t show_temp3(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(2));
+}
+
+DEVICE_ATTR(temp1, 0444, show_temp1, NULL);
+DEVICE_ATTR(temp2, 0444, show_temp2, NULL);
+DEVICE_ATTR(temp3, 0444, show_temp3, NULL);
+
+/* ------ rotation speed attributes ------ */
+static ssize_t show_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(0));
+}
+
+static ssize_t show_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(1));
+}
+
+DEVICE_ATTR(fan1_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan2_rpm, 0444, show_fan2_rpm, NULL);
+
+/* fan3_rpm and fan4_rpm nodes are added to fit Buffalo's requirement. */
+DEVICE_ATTR(fan3_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan4_rpm, 0444, show_fan2_rpm, NULL);
+
+/* ----------- speed attributes ---------- */
+static ssize_t show_fan1_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(0));
+}
+static ssize_t store_fan1_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+
+	return count;
+}
+
+static ssize_t show_fan2_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(1));
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(1));
+}
+static ssize_t store_fan2_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan3_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	unsigned int temp;
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+		/* get_fan_speed(1) is used to set fan4 as software control mode */
+		temp = get_fan_speed(1);
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else{
+		/* get_fan_speed(1) is used to set fan4 as software control mode */
+		temp = get_fan_speed(1);
+		return sprintf(buf, "%d\n", get_fan_speed(0));
+	}
+}
+static ssize_t store_fan3_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+	
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+DEVICE_ATTR(fan1_speed, 0644, show_fan1_speed, store_fan1_speed);
+DEVICE_ATTR(fan2_speed, 0644, show_fan2_speed, store_fan2_speed);
+
+/* fan3_speed and fan4_speed are added to fit Buffalo's requirement,
+   and their behavior are same to Matsu. */
+DEVICE_ATTR(fan3_speed, 0644, show_fan3_speed, store_fan3_speed);
+DEVICE_ATTR(fan4_speed, 0644, show_fan2_speed, store_fan2_speed);
+
+/* ---------- 4 steps attributes --------- */
+static ssize_t show_fan_stop_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_stop_speed);
+}
+static ssize_t store_fan_stop_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_stop_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_slow_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_slow_speed);
+}
+static ssize_t store_fan_slow_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_slow_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_fast_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_fast_speed);
+}
+static ssize_t store_fan_fast_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_fast_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_full_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_full_speed);
+}
+static ssize_t store_fan_full_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_full_speed = tmp_speed;
+	return count;
+}
+
+DEVICE_ATTR(fan_stop_speed, 0644, show_fan_stop_speed, store_fan_stop_speed);
+DEVICE_ATTR(fan_slow_speed, 0644, show_fan_slow_speed, store_fan_slow_speed);
+DEVICE_ATTR(fan_fast_speed, 0644, show_fan_fast_speed, store_fan_fast_speed);
+DEVICE_ATTR(fan_full_speed, 0644, show_fan_full_speed, store_fan_full_speed);
+
+/* --------- read mode attribute --------- */
+static ssize_t show_show_speed_by_string(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", flag_show_speed_by_string);
+}
+static ssize_t store_show_speed_by_string(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+	
+	if(value != 0 && value != 1)
+		return -EINVAL;
+
+	flag_show_speed_by_string = value;
+
+	return count;
+}
+DEVICE_ATTR(show_speed_by_string, 0644, show_show_speed_by_string, store_show_speed_by_string);
+
+/* --------- threshold attribute --------- */
+static ssize_t show_fan_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_threshold);
+}
+static ssize_t store_fan_threshold(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_threshold = simple_strtoul(buf, NULL, 10);
+	fan_threshold = tmp_threshold;
+	return count;
+}
+DEVICE_ATTR(fan_threshold, 0644, show_fan_threshold, store_fan_threshold);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_fan_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_fan_major);
+}
+DEVICE_ATTR(sugi_fan_dev, 0444, show_sugi_fan_dev, NULL);
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-3
+ * Description: Implement functions of HDD control driver
+ * ---------------------------------------------------------------------------------------------- */
+static void *
+sugi_hotplug_status_seq_start(struct seq_file *s, loff_t *pos)
+{
+	return *pos < 1 ? SEQ_START_TOKEN : NULL;
+}
+
+static void *
+sugi_hotplug_status_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	++ *pos;
+	return NULL;
+}
+
+static void
+sugi_hotplug_status_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int
+sugi_hotplug_status_seq_show(struct seq_file *m, void *v)
+{
+	struct sugi_hdd_info_st *hdd_info = (struct sugi_hdd_info_st *)m->private;
+
+	if (inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_PRESENT_REG) & hdd_info->HDD_PRESENT_BIT)
+		seq_printf(m, "unplugged\n");
+	else
+		seq_printf(m, "plugged\n");
+
+	return 0;
+}
+
+static const
+struct seq_operations sugi_hotplug_status_seq_ops = {
+	.start	= sugi_hotplug_status_seq_start,
+	.next	= sugi_hotplug_status_seq_next,
+	.stop	= sugi_hotplug_status_seq_stop,
+	.show	= sugi_hotplug_status_seq_show,
+};
+
+static int
+sugi_hotplug_status_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct seq_file *m;
+	struct sugi_hdd_info_st *hdd_info = (struct sugi_hdd_info_st *)PDE_DATA(inode);
+
+	ret = seq_open_private(file, &sugi_hotplug_status_seq_ops,
+			       sizeof(hdd_info));
+	if (ret) {
+		return ret;
+	}
+	m = file->private_data;
+	m->private = hdd_info;
+	return 0;
+}
+
+static const
+struct file_operations sugi_hotplug_status_file_ops = {
+	.open		= sugi_hotplug_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static void *
+sugi_power_control_seq_start(struct seq_file *s, loff_t *pos)
+{
+	return *pos < 1 ? SEQ_START_TOKEN : NULL;
+}
+
+static void *
+sugi_power_control_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	++ *pos;
+	return NULL;
+}
+
+static void
+sugi_power_control_seq_stop(struct seq_file *s, void *v)
+{
+}
+
+static int
+sugi_power_control_seq_show(struct seq_file *m, void *v)
+{
+	struct sugi_hdd_info_st *hdd_info = (struct sugi_hdd_info_st *)m->private;
+
+	if (inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG) & hdd_info->HDD_POWER_BIT)
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+static const
+struct seq_operations sugi_power_control_seq_ops = {
+	.start	= sugi_power_control_seq_start,
+	.next	= sugi_power_control_seq_next,
+	.stop	= sugi_power_control_seq_stop,
+	.show	= sugi_power_control_seq_show,
+};
+
+static int
+sugi_power_control_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct seq_file *m;
+	struct sugi_hdd_info *hdd_info = (struct sugi_hdd_info *)PDE_DATA(inode);
+
+	ret = seq_open_private(file, &sugi_power_control_seq_ops,
+			       sizeof(hdd_info));
+	if (ret) {
+		
+		return ret;
+	}
+	m = file->private_data;
+	m->private = hdd_info;
+	return 0;
+}
+
+static ssize_t
+sugi_power_control_write(struct file *file, const char __user *buffer,
+			 size_t count, loff_t *ppos)
+{
+	int tmpgpioval;
+	struct sugi_hdd_info_st *hdd_info = (struct sugi_hdd_info_st *)PDE_DATA(file_inode(file));
+	char *kbuf;
+
+	kbuf = kmalloc(count + 1, GFP_KERNEL);
+	if (kbuf == NULL) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, buffer, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+
+	kbuf[count] = '\0';
+
+	tmpgpioval = inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+
+	if (strncmp(kbuf, "off", strlen("off")) == 0) {
+		if (tmpgpioval & hdd_info->HDD_POWER_BIT) {
+			tmpgpioval &= hdd_info->HDD_POWER_MASK;
+			outl(tmpgpioval, ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+			return count;
+		}
+	}
+	
+	if(strncmp(kbuf, "on", strlen("on")) == 0){
+		if (!(tmpgpioval & hdd_info->HDD_POWER_BIT)){
+			tmpgpioval |= hdd_info->HDD_POWER_BIT;
+			outl(tmpgpioval, ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+			return count;
+		}
+	}
+out:
+	kfree(kbuf);
+	return count;
+}
+
+static const
+struct file_operations sugi_power_control_file_ops = {
+	.open		= sugi_power_control_open,
+	.read		= seq_read,
+	.write		= sugi_power_control_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/* ----------- polling function ---------- */
+
+static void SataHotplugPollingUpdatePinstat(void)
+{
+	unsigned int i = 0;
+	
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].presentpinstat = (inl(ich10r_gpio_base_addr + sugi_hdd_info[i].HDD_GPIO_PRESENT_REG) & sugi_hdd_info[i].HDD_PRESENT_BIT)? SATA_STAT_UNPLUGGED:SATA_STAT_PLUGGED;
+	}
+}
+
+static void SataHotplugPolling(unsigned long data)
+{
+	unsigned int i = 0;
+	char buf[32];
+
+	SataHotplugPollingUpdatePinstat();
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		if(sata_hotplug_data[i].prevplugstat == sata_hotplug_data[i].presentpinstat)
+		{
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			continue;
+		}
+		--sata_hotplug_data[i].loops;
+
+		if(sata_hotplug_data[i].loops == 0)
+		{
+			if(sata_hotplug_data[i].presentpinstat == SATA_STAT_PLUGGED)
+				sprintf(buf, PLUGGED_EVENT_MSG, i);
+			else
+				sprintf(buf, UNPLUGGED_EVENT_MSG, i);
+
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				buffalo_kernevnt_queuein(buf);
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			sata_hotplug_data[i].prevplugstat = sata_hotplug_data[i].presentpinstat;
+		}
+	}
+	sata_hotplug_polling_timer.expires += SATA_POL_INTERVAL;
+	add_timer(&sata_hotplug_polling_timer);
+}
+
+static unsigned long SataHotplugPollingStart(void)
+{
+	unsigned int i = 0;
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].prevplugstat = SATA_STAT_UNKNOWN;
+		sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+	}
+
+        init_timer(&sata_hotplug_polling_timer);
+        sata_hotplug_polling_timer.expires = jiffies + SATA_POL_INTERVAL;
+        sata_hotplug_polling_timer.function = SataHotplugPolling;
+        add_timer(&sata_hotplug_polling_timer);
+
+        return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-4
+ * Description: Implement functions of CMOS driver
+ * ---------------------------------------------------------------------------------------------- */
+static unsigned char checksum_caculation(unsigned char wol, unsigned char acp, unsigned char lan)
+{
+	return (CMOS_CHANGE_CHECKSUM - wol - (acp << 1) - (lan * 6));
+}
+static int smi_write(void)
+{
+	int smi_count = 0;
+	int read_count = 0;
+	
+	for(smi_count = 0; smi_count < 3; smi_count++){
+		outb(SW_SMI_WRITE, SW_SMI_OFFSET);
+		for(read_count = 0; read_count < 10; read_count++){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			/* return error code of write "pass" or "fail" */
+			if(inb(CMOS_DATA_PORT) == 0x40 || inb(CMOS_DATA_PORT) == 0xEF || inb(CMOS_DATA_PORT) == 0xFF)
+				return inb(CMOS_DATA_PORT);
+			mdelay(100);
+		}
+	}
+	/* return 0 after sending SMI 3 times and waiting for 0.5s delay 10 times  */
+	return 0;
+}
+
+static int smi_read(void)
+{
+	int smi_count = 0;
+	int read_count = 0;
+	
+	/* clear 73h to 0 */
+	outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+	while(inb(CMOS_DATA_PORT))
+		outb(0x00, CMOS_DATA_PORT);
+	
+	for(smi_count = 0; smi_count < 3; smi_count++){
+		outb(SW_SMI_READ, SW_SMI_OFFSET);
+		for(read_count = 0; read_count < 10; read_count++){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			/* return error code of read "pass" or "fail" */
+			if(inb(CMOS_DATA_PORT) == 0x40 || inb(CMOS_DATA_PORT) == 0xEF)
+				return inb(CMOS_DATA_PORT);
+			mdelay(100);
+		}
+	}
+	/* return 0 after sending SMI 3 times and waiting for 0.5s delay 10 times  */
+	return 0;
+}
+
+/* -------- wake on LAN attribute -------- */
+static ssize_t show_wol_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret == 0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret == 1){
+		return sprintf(buf, "on\n");
+	}
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_wol_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len != 3) && (len != 4)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return count;
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return count;
+			case 0x40:
+				outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+				lanboot_setting_value = inb(CMOS_DATA_PORT);
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return count;
+		}
+	}
+	
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	power_setting_value = inb(CMOS_DATA_PORT);
+		
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_ENABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		if(wol_setting_value == WOL_ENABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_DISABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		if(wol_setting_value == WOL_DISABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	if(bios_ver >=209){
+		ret = smi_write();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				break;
+			case 0xEF:
+				printk("NVRAM_CMOS_COMPARE_FAIL\n");
+				break;
+			case 0xFF:
+				printk("NVRAM_WRITE_FAIL\n");
+				break;
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				break;
+		}
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(wol_setting, 0644, show_wol_setting, store_wol_setting);
+
+/* ------- AC power loss attribute ------- */
+static ssize_t show_power_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret==0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret==1){
+		return sprintf(buf, "on\n");
+	}
+	else if(ret==2){
+		return sprintf(buf, "last state\n");
+	}
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_power_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+		
+//	if((len != 3) || (len != 4) || (len != 5)){
+//		printk("WRONG_STRING [%d]\n", len);
+//		return count;
+//	}
+		
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return count;
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return count;
+			case 0x40:
+				outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+				lanboot_setting_value = inb(CMOS_DATA_PORT);
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return count;
+		}
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	wol_setting_value = inb(CMOS_DATA_PORT);
+	
+//	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+	if(strncmp(buf, "on", strlen("on")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_ON, CMOS_DATA_PORT);
+		
+		if(bios_ver < 209){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &=(~0x0001);
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_ON){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+//	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+	if(strncmp(buf, "off", strlen("off")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_OFF, CMOS_DATA_PORT);
+		
+		if(bios_ver < 209){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en |= 0x0001;
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_OFF){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+//	if((len == 5) && (strncmp(buf, "last", strlen("last")) == 0)){
+	if(strncmp(buf, "last", strlen("last")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_LAST_STATE, CMOS_DATA_PORT);
+		
+		if(bios_ver){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &= 0xFFFE;
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_LAST_STATE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	if(bios_ver >=209){
+		ret = smi_write();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				break;
+			case 0xEF:
+				printk("NVRAM_CMOS_COMPARE_FAIL\n");
+				break;
+			case 0xFF:
+				printk("NVRAM_WRITE_FAIL\n");
+				break;
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				break;
+		}
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(power_setting, 0644, show_power_setting, store_power_setting);
+
+/* -------- Gbe LAN boot attribute ------- */
+static ssize_t show_lanboot_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret==0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret==1){
+		return sprintf(buf, "on\n");
+	}
+
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_lanboot_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len != 3) && (len != 4)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	ret = smi_read();
+		
+	switch(ret){
+		case 0: 
+			printk("BIOS_NO_RESPONSE\n");
+			return count;
+		case 0xEF:
+			printk("NVRAM_READ_FAIL\n");
+			return count;
+		case 0x40:
+			break;
+		default:
+			printk("UNKNOWN FAIL\n");
+			return count;
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	wol_setting_value = inb(CMOS_DATA_PORT);
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	power_setting_value = inb(CMOS_DATA_PORT);
+		
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+		outb(LANBOOT_ENABLE, CMOS_DATA_PORT);
+		
+		lanboot_setting_value = inb(CMOS_DATA_PORT);
+		if(lanboot_setting_value == LANBOOT_ENABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+		outb(LANBOOT_DISABLE, CMOS_DATA_PORT);
+		
+		lanboot_setting_value = inb(CMOS_DATA_PORT);
+		if(lanboot_setting_value == LANBOOT_DISABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	ret = smi_write();
+		
+	switch(ret){
+		case 0: 
+			printk("BIOS_NO_RESPONSE\n");
+			break;
+		case 0xEF:
+			printk("NVRAM_CMOS_COMPARE_FAIL\n");
+			break;
+		case 0xFF:
+			printk("NVRAM_WRITE_FAIL\n");
+			break;
+		case 0x40:
+			break;
+		default:
+			printk("UNKNOWN FAIL\n");
+			break;
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(lanboot_setting, 0644, show_lanboot_setting, store_lanboot_setting);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_cmos_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_cmos_major);
+}
+DEVICE_ATTR(sugi_cmos_dev, 0444, show_sugi_cmos_dev, NULL);
+
+/* ----------- PID attribute ------------ */
+static ssize_t show_device_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i=0;
+	char rv[32]; 
+	
+	for(i=0; i<=31; i++){
+		outb(device_id_offset[i], CMOS_INDEX_PORT);
+		rv[i] = inb(CMOS_DATA_PORT);
+	}
+	
+	return sprintf(buf, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
+	rv[0], rv[1], rv[2], rv[3], rv[4], rv[5], rv[6], rv[7], 
+	rv[8], rv[9], rv[10], rv[11], rv[12], rv[13], rv[14], rv[15],
+	rv[16], rv[17], rv[18], rv[19], rv[20], rv[21], rv[22], rv[23], 
+	rv[24], rv[25], rv[26], rv[27], rv[28], rv[29], rv[30], rv[31]);
+}
+
+static ssize_t store_device_id(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i;
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 33){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	if(len == 33){
+		for(i = 0; i <= 31; i++){
+			if((buf[i] < 32) || (buf[i] > 126)){
+				printk("WRONG_STRING\n");
+				return count;
+			}
+		}
+	
+		for(i = 0; i <= 31; i++){
+			outb(device_id_offset[i], CMOS_INDEX_PORT);
+			outb(buf[i], CMOS_DATA_PORT);
+		}
+	}
+	
+	return count;
+}
+
+DEVICE_ATTR(device_id, 0644, show_device_id, store_device_id);
+
+/* --------- checksum attribute ---------- */
+static ssize_t show_checksum(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i;
+	unsigned int rv = 0;
+	
+	for(i=0; i<=3; i++) {
+		outb(checksum_offset[i], CMOS_INDEX_PORT);
+		rv |= inb(CMOS_DATA_PORT) << 8*(3-i);
+	}
+	
+	return sprintf(buf, "%08x\n", rv);
+}
+
+static ssize_t store_checksum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i, j, tmp, len=0;
+	unsigned char checksum_orig[8];
+	unsigned char success_flag = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 9){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	else if(len == 9){
+		for(i=0; i<=7; i++) {
+			for(j=0; j<=21; j++) {
+				if(buf[i] == strtoint_info[j].strg){
+					checksum_orig[i] = strtoint_info[j].inte;
+					success_flag = 1;
+				}
+				else if (j == 21 && success_flag == 0){
+					printk("WRONG_STRING\n");
+					return count;
+				}
+			}
+			success_flag = 0;
+		}
+	
+		for(i=0; i<=3; i++) {
+			tmp = (checksum_orig[2*i] << 4) + checksum_orig[2*i+1];
+			outb(checksum_offset[i], CMOS_INDEX_PORT);
+			outb(tmp, CMOS_DATA_PORT);
+		}
+	}
+	
+	return count;
+}
+
+DEVICE_ATTR(checksum, 0644, show_checksum, store_checksum);
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-5
+ * Description: Implement functions of board ID driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ---------- board ID attribute --------- */
+static ssize_t show_board_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(boardid_num==0)
+		return sprintf(buf,"2HDD\n");
+	else if(boardid_num==1)
+		return sprintf(buf,"4HDD\n");
+	else if(boardid_num==2)
+		return sprintf(buf,"6HDD\n");
+	else if(boardid_num==3)
+		return sprintf(buf,"8HDD\n");
+	else if(boardid_num==4)
+		return sprintf(buf,"1U\n");
+	
+	return sprintf(buf, "Unknown\n");
+}
+
+DEVICE_ATTR(board_id, 0444, show_board_id, NULL);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_boardid_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_boardid_major);
+}
+
+DEVICE_ATTR(sugi_boardid_dev, 0444, show_sugi_boardid_dev, NULL);
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 3
+ * Description: Chipsets and file system sheeting
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ------- proc file system setting ------ */
+static int init_proc_files(void)
+{
+	int i = 0;
+	char buf[32];
+	
+	/* create /proc/buffalo */
+#ifdef CONFIG_BUFFALO_PLATFORM
+	extern struct proc_dir_entry *get_proc_buffalo(void);
+	buffalo_dir = get_proc_buffalo();
+#else	/* CONFIG_BUFFALO_PLATFORM */
+	buffalo_dir = proc_mkdir(BUFFALO_DIR, NULL);
+#endif	/* CONFIG_BUFFALO_PLATFORM */
+	
+	/* create /proc/buffalo/gpio */
+	gpio_dir = proc_mkdir(GPIO_DIR, NULL);
+	
+	
+	/* button driver */
+	/* create /proc/buffalo/gpio/switch */
+	switch_dir = proc_mkdir(SWITCH_DIR, NULL);
+	
+	/* create /proc/buffalo/gpio/switch/func(display) */
+	for(i = 0; i < MAX_SUPPORTED_BUTTONS; i++){
+		switch_file[i] =
+			proc_create_data(button_info[i].name,
+					 S_IRUGO,
+					 switch_dir,
+					 &sugi_button_status_file_ops,
+					 &button_info[i]);
+	}
+
+	/* HDD control driver */
+	/* create /proc/buffalo/gpio/hotplug */
+	hotplug_dir = proc_mkdir(HOTPLUG_DIR, NULL);
+	
+	/* create /proc/buffalo/gpio/hotplug/sata# */
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "sata%d", i);
+		hotplug_sata_file[i] =
+			proc_create_data(buf, S_IRUGO,
+					 hotplug_dir,
+					 &sugi_hotplug_status_file_ops,
+					 &sugi_hdd_info[i]);
+	}
+
+	/* create /proc/buffalo/gpio/power_control */
+	power_control_dir = proc_mkdir(POWER_CONTROL_DIR, NULL);
+
+	/* create /proc/buffalo/gpio/power_control/hdd# */
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "hdd%d", i);
+		power_control_hdd_file[i] =
+			proc_create_data(buf, S_IRUGO | S_IWUSR,
+					 power_control_dir,
+					 &sugi_power_control_file_ops,
+					 &sugi_hdd_info[i]);
+	}	
+
+	return 0;
+}
+
+
+/* ---------- sysfs file system ---------- */
+static int init_sysfs_files(void)
+{
+	int rv;
+	
+	if(sugi_cls)
+		return -EINVAL;
+
+	/* create /sys/class/sugi */
+	sugi_cls = class_create(THIS_MODULE, "sugi");
+
+
+	/* fan control driver */
+	/* create /sys/class/sugi/fan */
+	fan_dev = device_create(sugi_cls, NULL, sugit_fan, NULL, "fan");
+	
+	/* create /sys/class/sugi/fan/temp# */
+	rv = device_create_file(fan_dev, &dev_attr_temp1);
+	rv = device_create_file(fan_dev, &dev_attr_temp2);
+	rv = device_create_file(fan_dev, &dev_attr_temp3);
+	
+	/* create /sys/class/sugi/fan/fan#_rpm */
+	rv = device_create_file(fan_dev, &dev_attr_fan1_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan2_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan3_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan4_rpm);
+	
+	/* create /sys/class/sugi/fan/fan#_speed */
+	rv = device_create_file(fan_dev, &dev_attr_fan1_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan2_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan3_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan4_speed);
+    
+	/* create /sys/class/sugi/fan/fan_pattern_speed */
+	rv = device_create_file(fan_dev, &dev_attr_fan_stop_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_slow_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_fast_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_full_speed);
+    
+	/* create /sys/class/sugi/fan/show_speed_by string */
+	rv = device_create_file(fan_dev, &dev_attr_show_speed_by_string);
+    
+	/* create /sys/class/sugi/fan/fan_threshold */
+	rv = device_create_file(fan_dev, &dev_attr_fan_threshold);
+    
+	/* create /sys/class/sugi/fan/sugi_fan_dev */
+	rv = device_create_file(fan_dev, &dev_attr_sugi_fan_dev);
+	
+	
+	/* CMOS driver */
+	/* create /sys/class/sugi/cmos */
+	cmos_dev = device_create(sugi_cls, NULL, sugit_cmos, NULL, "cmos");
+	
+	/* create /sys/class/sugi/cmos/wol_setting */
+	rv = device_create_file(cmos_dev, &dev_attr_wol_setting);
+		
+	/* create /sys/class/sugi/cmos/power_setting */
+	rv = device_create_file(cmos_dev, &dev_attr_power_setting);
+		
+	/* create /sys/class/sugi/cmos/sugi_cmos_dev */
+	rv = device_create_file(cmos_dev, &dev_attr_sugi_cmos_dev);
+	
+		/* create /sys/class/sugi/cmos/pid */
+	rv = device_create_file(cmos_dev, &dev_attr_device_id);
+	
+	/* create /sys/class/sugi/cmos/checksum */
+	rv = device_create_file(cmos_dev, &dev_attr_checksum);
+  
+	/* create /sys/class/sugi/cmos/lanboot_setting */
+	/* this node and the related funciton will be 
+	   created if the BIOS version is newer than V209*/
+	if(bios_ver >= 209)
+		rv = device_create_file(cmos_dev, &dev_attr_lanboot_setting);
+  
+	
+	/* board ID driver */
+	/* create /sys/class/sugi/board */
+	boardid_dev = device_create(sugi_cls, NULL, sugit_boardid, NULL, "board");
+	
+	/* create /sys/class/sugi/board/board_id */
+	rv = device_create_file(boardid_dev, &dev_attr_board_id);
+		
+	/* create /sys/class/sugi/board/sugi_boardid_dev */
+	rv = device_create_file(boardid_dev, &dev_attr_sugi_boardid_dev);
+	
+	return 0;
+}
+
+/* ---------- BIOS version check --------- */
+static int bios_version_check(void)
+{
+	int i;
+	unsigned char* smbios_sm = NULL;
+	unsigned char* smbios_dmi = NULL;
+	unsigned char* smbios_eps = NULL;
+	unsigned char* smbios_base = NULL;
+	unsigned char* smbios_ver = NULL;
+	unsigned int smbios_base_addr = 0;
+
+	for(i = 0; i <= 0xFFF0; i += 0x01){
+		smbios_sm = ioremap(0x000F0000 + i, 4);
+		if(strncmp(smbios_sm, "_SM_", strlen("_SM_")) == 0){
+			smbios_dmi = ioremap(0x000F0000 + i + 0x10, 4);
+			if(strncmp(smbios_dmi, "_DMI_", strlen("_DMI_"))== 0){
+				smbios_eps = ioremap(0x000F0000 + i + 0x18, 4);
+				smbios_base_addr = ioread32(smbios_eps);
+				break;
+			}
+		}
+	}
+	
+	for(i = 0; i <= 0xFF; i += 0x01){
+		smbios_base = ioremap(smbios_base_addr + i, 1);
+		if(ioread8(smbios_base) == 0x33){
+			if(strncmp(smbios_base, "31SUG", strlen("31SUG")) == 0){
+				smbios_ver = ioremap(smbios_base_addr + i + 0x05, 1);
+				bios_ver = simple_strtoul(smbios_ver, NULL, 10);
+				iounmap(smbios_sm);
+				iounmap(smbios_dmi);
+				iounmap(smbios_eps);
+				iounmap(smbios_base);
+				iounmap(smbios_ver);
+				printk("BIOS VERSION : V%d\n",bios_ver);
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+/* ------------ IT8721 setting ----------- */
+	
+	/* button driver */
+void SetBTNMBPnP(void)
+{
+	unsigned int base_msb;
+	unsigned int base_lsb;
+	
+	/* select LDN 07h */	
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	/* find GPIO set3 base addr */
+	outb(IT87_SIMPLE_IO_BASE_MSB, CONFIG_ADDR_PORT);
+	base_msb = inb(CONFIG_DATA_PORT);
+	outb(IT87_SIMPLE_IO_BASE_LSB, CONFIG_ADDR_PORT);
+	base_lsb = inb(CONFIG_DATA_PORT);
+	it87_gpioset3_base_addr = (base_msb*256 + base_lsb) + GPIO_SET3_OFFSET;
+	
+	/* enable to generate SMI of PBD's IRQ */
+	outb(IT87_REG_SMI_CTL2, CONFIG_ADDR_PORT);
+	outb(inb(CONFIG_DATA_PORT)|0x01, CONFIG_DATA_PORT);
+	
+	/* set GPIO34/35 as de-bounce GPIO */
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(IT87_GP34_LOC | IT87_IRQEN, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(IT87_GP35_LOC, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(IT87_PNL_IRQ3, CONFIG_DATA_PORT);
+	}
+	
+/* fan control driver */
+void SetFANMBPnP(void)
+{
+	unsigned short BASE_ADDR_EXT;
+	unsigned short BASE_ADDR;
+
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_EC_LDN, CONFIG_DATA_PORT);
+	outb(0x60,CONFIG_ADDR_PORT);
+	BASE_ADDR_EXT = inb(CONFIG_DATA_PORT)*256;
+	outb(0x61,CONFIG_ADDR_PORT);
+	BASE_ADDR = inb(CONFIG_DATA_PORT);
+  EC_BASE_ADDR = BASE_ADDR_EXT+BASE_ADDR;
+  IT87_EC_ADDR_REG = EC_BASE_ADDR+0x05;
+  IT87_EC_DATA_REG = EC_BASE_ADDR+0x06;
+}
+
+/* ------------ ich10r setting ----------- */
+static int ich10r_setting(void)
+{
+	int ret;
+	
+	pdev = pci_get_device(INTEL_ICH10R_VID, INTEL_ICH10R_DID, NULL);
+	if(!pdev)
+		return -ENODEV;
+	
+	ret = pci_read_config_dword(pdev, GPIOBASE, &ich10r_gpio_base_addr);
+	if(ret)
+		return -EINVAL;
+		
+	ret = pci_read_config_dword(pdev, PMBASE, &ich10r_pm_base_addr);
+	if(ret)
+		return -EINVAL;
+		
+	ich10r_gpio_base_addr &= 0x0000FF80;
+	
+	ich10r_pm_base_addr &= 0x0000FF80;
+	
+	/* Board ID driver */
+	/* set GPIO pin 29, 30 ,31 as GPIO function */
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL)|0xE0000000), ich10r_gpio_base_addr+GP_USE_SEL);
+	
+	/* set GPIO pin 29, 30 ,31 as input */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)|0xE0000000), ich10r_gpio_base_addr+GP_IO_SEL);
+	
+	/* get board ID relative GPIO pins status */
+	boardid_num = (inl(ich10r_gpio_base_addr+GP_LVL)&BOARD_ID_MASK) >> BOARD_ID_OFFSET;
+	
+	/* HDD control driver */
+	/* set relative GPIO pins as GPIO function */
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL)|0x0002A6FD), ich10r_gpio_base_addr+GP_USE_SEL);
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL2)|0x01000007), ich10r_gpio_base_addr+GP_USE_SEL2);
+	
+	/* set hotplug relative GPIO pins as input */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)|0x0000A63C), ich10r_gpio_base_addr+GP_IO_SEL);
+	
+	/* set power control relative GPIO pins as outout */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)&0xFFFDFF3D), ich10r_gpio_base_addr+GP_IO_SEL);
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL2)&0xFEFFFFF8), ich10r_gpio_base_addr+GP_IO_SEL2);
+	
+	return 0;
+}
+
+/* ------------ initialization ----------- */
+static int __init sugi_platform_init(void)
+{  	
+	int ret;
+	
+	/* request IRQ3 */
+	ret = request_irq(3, sugi_interrupt, IRQF_SHARED, DRVNAME, sugi_interrupt);
+	if (ret) {
+		printk("%s: REQUEST IRQ3 FAIL\n", __FUNCTION__);
+		free_irq(3, 0);
+		return -EBUSY;
+	}
+	
+	/* chipsets initilization */
+	/* ICH10R */
+	ret = ich10r_setting();
+	if (ret) {
+		printk("%s: ICH10R INITIALIZE FAIL\n", __FUNCTION__);
+		return -ENODEV;
+	}
+	/* IT8721 */	
+	EnterMBPnP();
+	SetFANMBPnP();
+	//ExitMBPnP();
+	
+	//EnterMBPnP();
+	SetBTNMBPnP();
+	ExitMBPnP();
+	
+	/* register device to system */	
+	ret = register_chrdev_region(sugit_fan, sugi_dev_count, DRVNAME);
+	ret = register_chrdev_region(sugit_cmos, sugi_dev_count, DRVNAME);
+	ret = register_chrdev_region(sugit_boardid, sugi_dev_count, DRVNAME);
+	
+	/* check BIOS verion */
+	ret = bios_version_check();
+	if (ret) {
+		printk("%s: BIOS VERSION CHECK FAIL\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	
+	/* create sysfs file system */
+	ret = init_sysfs_files();
+	if (ret) {
+		printk("%s: SYSFS INITALIZE FAIL\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+		
+	/* create proc file system */
+	ret = init_proc_files();
+	if (ret) {
+		printk("%s: PROCFS INITALIZE FAIL\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	
+	SataHotplugPollingStart();
+	
+	printk("SUGI_PLATFORM MODULE HAS BEEN INITIALIZED\n");
+	
+	return 0;
+}
+
+/* ----------------- exit ---------------- */
+static void __exit sugi_platform_exit(void)
+{
+	int i = 0;
+	char buf[32];
+	
+	/* delete hotplug polling timer */
+	del_timer(&sata_hotplug_polling_timer);
+	
+	/* disable and release IRQ3 */
+	disable_irq(3);
+	free_irq(3, sugi_interrupt);
+	
+	/* remove proc file system nodes */
+	for(i = 0; i < MAX_SUPPORTED_BUTTONS; i++){
+		remove_proc_entry(button_info[i].name, switch_dir);
+	}
+	
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, power_control_dir);
+	}
+	
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hotplug_dir);
+	}
+	
+	remove_proc_entry(SWITCH_DIR, NULL);
+	remove_proc_entry(HOTPLUG_DIR, NULL);
+	remove_proc_entry(POWER_CONTROL_DIR, NULL);
+	remove_proc_entry(GPIO_DIR, NULL);
+	remove_proc_entry(BUFFALO_DIR, NULL);
+	
+	/* remove sysfs file system */
+	device_remove_file(fan_dev, &dev_attr_temp1);
+	device_remove_file(fan_dev, &dev_attr_temp2);
+	device_remove_file(fan_dev, &dev_attr_temp3);
+	device_remove_file(fan_dev, &dev_attr_fan1_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan2_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan1_speed);
+	device_remove_file(fan_dev, &dev_attr_fan2_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_stop_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_slow_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_fast_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_full_speed);
+	device_remove_file(fan_dev, &dev_attr_sugi_fan_dev);
+	device_remove_file(fan_dev, &dev_attr_fan_threshold);
+	device_remove_file(fan_dev, &dev_attr_show_speed_by_string);
+	
+	device_remove_file(cmos_dev, &dev_attr_wol_setting);
+	device_remove_file(cmos_dev, &dev_attr_power_setting);
+	device_remove_file(cmos_dev, &dev_attr_sugi_cmos_dev);
+	device_remove_file(cmos_dev, &dev_attr_device_id);
+	device_remove_file(cmos_dev, &dev_attr_checksum);
+	
+	if(bios_ver >= 209)
+		device_remove_file(cmos_dev, &dev_attr_lanboot_setting);
+	
+	device_remove_file(boardid_dev, &dev_attr_sugi_boardid_dev);
+	device_remove_file(boardid_dev, &dev_attr_board_id);
+	
+	device_destroy(sugi_cls, sugit_fan);
+	device_destroy(sugi_cls, sugit_cmos);
+	device_destroy(sugi_cls, sugit_boardid);
+	
+	class_destroy(sugi_cls);
+	
+	unregister_chrdev_region(sugit_fan, sugi_dev_count);
+	unregister_chrdev_region(sugit_cmos, sugi_dev_count);
+	unregister_chrdev_region(sugit_boardid, sugi_dev_count);
+  
+	printk("SUGI_PLATFORM MODULE HAS BEEN REMOVED\n");
+}
+
+module_init(sugi_platform_init);
+module_exit(sugi_platform_exit);
+MODULE_LICENSE("GPL");
diff --git a/buffalo/arch/x86/plat-usi/sugi_platform.h b/buffalo/arch/x86/plat-usi/sugi_platform.h
new file mode 100644
index 00000000..f4662fc
--- /dev/null
+++ b/buffalo/arch/x86/plat-usi/sugi_platform.h
@@ -0,0 +1,308 @@
+#if !defined __SUGI_PLATFORM_H__
+#define __SUGI_PLATFORM_H__
+
+/* common section */
+#define sugi_fan_major						125
+#define sugi_fan_minor						0
+#define sugi_cmos_major						124
+#define sugi_cmos_minor						0
+#define sugi_boardid_major				123
+#define sugi_boardid_minor				0
+#define sugi_dev_count        		1
+#define DRVNAME								"sugi_platform"
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 1
+ * Description: Definition of IT8721 registers
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ----------- Common Sections ----------- */
+ 
+/* IT8721 config section */
+#define CONFIG_ADDR_PORT	       	0x2E
+#define CONFIG_DATA_PORT	       	0x2F
+#define IT87_LDN_ADDR		       		0x07
+ 
+/* ------------ Button Driver ------------ */
+
+/* IT8721 logic device number */
+#define	IT87_GPIO_LDN							0x07
+ 
+/* panel button de-bounce mapping */
+#define IT87_REG_PNL_DBOUNCE0			0xE0
+#define IT87_REG_PNL_DBOUNCE1			0xE1
+#define IT87_GP34_LOC							0x1C
+#define IT87_GP35_LOC							0x1D
+#define	IT87_IRQEN								0x40
+
+/* panel button de-bounce interrupt level select */
+#define IT87_REG_PNL_IRQ_SEL			0x70
+#define IT87_PNL_IRQ3							0x03	
+
+/* SMI control register, bit0 is used to enable PBD's IRQ */
+#define IT87_REG_SMI_CTL2 				0xF1
+#define SMI_CTL2_EN_PBD						0x01
+
+/* SMI status register2, bit7-6 is used to detect panel button de-bounce */
+#define IT87_REG_SMI_STS2					0xF3
+#define IT87_SMI_DEB_MASK					0xC0
+
+/* SMI status register2, bit0 is PBD's IRQ */
+#define IT87_SMI_STS2_PBD					0x01
+
+/* Simple I/O base addr */
+#define IT87_SIMPLE_IO_BASE_MSB		0x62
+#define IT87_SIMPLE_IO_BASE_LSB		0x63
+#define GPIO_SET3_OFFSET					0x2
+
+
+/* ---------- Fan Control Driver --------- */
+
+/* IT8721 logic device number */
+#define	IT87_EC_LDN								0x04
+
+/* IT8721 main fan control registers */
+#define IT87_EC_FAN_MAIN_CTL	   	0x13
+#define IT87_EC_FAN_CTL		       	0x14
+
+/* IT8721 fan tachometer registers */
+#define IT87_EC_FAN_TACO1	       	0x0D // FAN1
+#define IT87_EC_FAN_TACO2	       	0x0E // FAN2
+
+#define IT87_EC_FAN_TACO1_EXT	   	0x18
+#define IT87_EC_FAN_TACO2_EXT	   	0x19
+
+/* select PWM control mode  */
+#define IT87_EC_FAN_PWM1					0x15
+#define IT87_EC_FAN_PWM2					0x16
+
+/* set the PWM value */
+#define IT87_EC_FAN_SMART_PWM1		0x63
+#define IT87_EC_FAN_SMART_PWM2		0x6B
+
+/* IT8721 temprature registers */
+#define IT87_EC_TMPIN3						0x2B // SYSTIN(TMPIN3@schematic)
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2
+ * Description: Definition of ICH10R registers
+ * ---------------------------------------------------------------------------------------------- */ 
+ 
+/* ----------- Common Sections ----------- */
+
+/* vendor and device ID for Intel ICH10R */
+#define INTEL_ICH10R_VID					0x8086
+#define INTEL_ICH10R_DID					0x3A16
+#define GPIOBASE									0x48
+#define PMBASE										0x40
+
+/* GPIO register*/
+#define GP_USE_SEL								0x00
+#define GP_USE_SEL2								0x30
+#define GP_IO_SEL									0x04
+#define GP_IO_SEL2								0x34
+#define GP_LVL										0x0C
+#define GP_LVL2										0x38
+
+/* Power management register */
+#define PMBASE										0x40
+#define PM1_STS										0x00
+#define PM1_EN										0x02
+#define GEN_PMCON_3								0xA4
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 3
+ * Description: Path of proc file system
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ----------- Common Sections ----------- */
+#define BUFFALO_DIR								"buffalo"
+#define GPIO_DIR									"buffalo/gpio" 
+ 
+/* ------------ Button Driver ------------ */
+#define SWITCH_DIR								"buffalo/gpio/switch"
+#define MAX_SUPPORTED_BUTTONS 		2
+
+/* ---------- HDD Control Driver --------- */
+#define HOTPLUG_DIR								"buffalo/gpio/hotplug"
+#define POWER_CONTROL_DIR					"buffalo/gpio/power_control"
+#define MAX_SUPPORTED_DISKS				8
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 4
+ * Description: Definitions of individual drivers
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ------------ Button Driver ------------ */
+
+/* period of timer */      
+#define TIMER_DELAY								(HZ/500)
+
+/* Buttons section */
+#define BTN_FUNC	    	   				0
+#define BTN_DISP	 	  		 				1
+
+/* select SMI status bit7-6 */
+#define IT87_DEB0									0x40	
+#define IT87_DEB1									0x80	
+#define IT87_DEB0DEB1							0xC0
+
+/* bit5-4 in GPIO set3 */
+#define IT87_GP34_BIT4						0x10
+#define IT87_GP35_BIT5						0x20
+
+/* button information structure */
+struct button_info_st
+{
+	char name[32];
+	unsigned char reg_stat;
+};
+
+/* ---------- Fan Control Driver --------- */
+
+/* fan control information */
+struct fan_info_st{
+	unsigned char reg;
+	unsigned char reg_ext;
+	unsigned char reg_smart_pwm;
+	unsigned char reg_pwm;
+	unsigned char offset;
+};
+
+/* ---------- HDD Control Driver --------- */
+
+/*
+    hotplug     |	power control
+----------------------------------
+sata0 -> GPIO2	|	hdd0 -> GPIO17
+sata1 -> GPIO3	|	hdd1 -> GPIO1
+sata2 -> GPIO4	|	hdd2 -> GPIO6
+sata3 -> GPIO5	|	hdd3 -> GPIO7
+sata4 -> GPIO15	|	hdd4 -> GPIO56
+sata5 -> GPIO9	|	hdd5 -> GPIO32
+sata6 -> GPIO13	|	hdd6 -> GPIO33
+sata7 -> GPIO10	|	hdd7 -> GPIO34
+
+*/
+
+/* GPIO pin definition */
+#define HDD0_PRESENT_BIT					0x00000004	/* GPIO2 */
+#define HDD1_PRESENT_BIT					0x00000008	/* GPIO3 */
+#define HDD2_PRESENT_BIT					0x00000010	/* GPIO4 */
+#define HDD3_PRESENT_BIT					0x00000020	/* GPIO5 */
+#define HDD4_PRESENT_BIT					0x00008000	/* GPIO15*/
+#define HDD5_PRESENT_BIT					0x00000200	/* GPIO9 */
+#define HDD6_PRESENT_BIT					0x00002000	/* GPIO13*/
+#define HDD7_PRESENT_BIT					0x00000400	/* GPIO10*/
+
+#define HDD0_POWER_BIT						0x00020000	/*GPIO17*/
+#define HDD1_POWER_BIT						0x00000002	/*GPIO1*/
+#define HDD2_POWER_BIT						0x00000040	/*GPIO6*/
+#define HDD3_POWER_BIT						0x00000080	/*GPIO7*/
+#define HDD4_POWER_BIT						0x01000000	/*GPIO56*/
+#define HDD5_POWER_BIT						0x00000001	/*GPIO32*/
+#define HDD6_POWER_BIT						0x00000002	/*GPIO33*/
+#define HDD7_POWER_BIT						0x00000004	/*GPIO34*/
+
+#define HDD0_POWER_MASK						0xFFFDFFFF
+#define HDD1_POWER_MASK						0xFFFFFFFD
+#define HDD2_POWER_MASK						0xFFFFFFBF
+#define HDD3_POWER_MASK						0xFFFFFF7F
+#define HDD4_POWER_MASK						0xFEFFFFFF
+#define HDD5_POWER_MASK						0xFFFFFFFE
+#define HDD6_POWER_MASK						0xFFFFFFFD
+#define HDD7_POWER_MASK						0xFFFFFFFB
+
+
+/* HDD information structure */
+struct sugi_hdd_info_st {
+	uint32_t HDD_GPIO_PRESENT_REG;
+	uint32_t HDD_PRESENT_BIT;
+	uint32_t HDD_GPIO_POWER_REG;
+	uint32_t HDD_POWER_BIT;
+	uint32_t HDD_POWER_MASK;
+};
+
+/* definitions of status */
+#define PLUGGED_EVENT_MSG       	"SATA %d plugged"
+#define UNPLUGGED_EVENT_MSG     	"SATA %d unplugged"
+
+/* polling timer */
+#define SATA_POL_INTERVAL       	HZ/100
+#define SATA_POL_LOOPS          	10
+
+/* hotplug ststus strcture */
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+/* hotplug information strcture */
+struct sata_hotplug_data_st {
+	SATA_PLUG_STATE presentpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+};
+
+/* ------------- CMOS Driver ------------- */
+
+/* IO index */
+#define	CMOS_INDEX_PORT						0x70
+#define	CMOS_DATA_PORT						0x71
+
+/* wake on LAN setting */
+#define WOL_OFFSET								0x70
+#define WOL_DISABLE								0x00
+#define WOL_ENABLE								0x01
+
+/* AC power loss setting */
+#define	AC_POWER_LOSS_OFFSET			0x71
+#define AC_POWER_LOSS_POWER_OFF 	0x00
+#define AC_POWER_LOSS_POWER_ON  	0x01
+#define AC_POWER_LOSS_LAST_STATE	0x02
+
+/* Gbe LAN boot setting */
+#define LANBOOT_OFFSET						0x75
+#define LANBOOT_DISABLE						0x00
+#define LANBOOT_ENABLE						0x01
+
+/* CMOS setting */
+#define CMOS_CHECKSUM_OFFSET			0x73
+#define CMOS_CHANGE_CHECKSUM			0xBF
+
+
+/* ASCII string strcture */
+struct strtoint_st {
+	unsigned char strg;
+	unsigned char inte;
+};
+
+/* SW SMI setting and return code */
+#define SW_SMI_OFFSET							0xB2
+#define SW_SMI_READ								0x76
+#define SW_SMI_WRITE							0x77 
+
+/* ----------- Board ID Driver ----------- */
+ 
+/*
+     SKU   | GPIO31   GPIO30   GPIO29 
+ ----------|-------- -------- --------
+  2HDD box |   0        0        0    
+  4HDD box |   0        0        1    
+  6HDD box |   0        1        0    
+  8HDD box |   0        1        1    
+  1U       |   1        0        0    
+*/
+
+#define GPIO29										0x20000000
+#define GPIO30										0x40000000
+#define GPIO31										0x80000000
+#define BOARD_ID_MASK							(GPIO29 | GPIO30 | GPIO31)
+#define BOARD_ID_OFFSET						29
+
+
+#endif
\ No newline at end of file
diff --git a/buffalo/drivers/Makefile b/buffalo/drivers/Makefile
new file mode 100644
index 00000000..b21427e
--- /dev/null
+++ b/buffalo/drivers/Makefile
@@ -0,0 +1,20 @@
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= proc_entry.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= buffalocore.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= kernevntProc.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= kernevnt.o
+
+obj-$(CONFIG_BUFFALO_MICON_V3)		+= micon_v3.o
+
+obj-$(CONFIG_BUFFALO_USE_UPS)		+= upsdrv.o rtc_nvram.o
+
+
+
+buffalo/drivers/buffalocore.o: buffalo/include/generated/builddate.h
+
+       chk_builddate.h = :
+ quiet_chk_builddate.h = echo '  CHK     $@'
+silent_chk_builddate.h = :
+buffalo/include/generated/builddate.h: FORCE
+	$(Q)mkdir -p buffalo/include/generated
+	@$($(quiet)chk_builddate.h)
+	$(Q)$(CONFIG_SHELL) $(srctree)/buffalo/scripts/mkbuilddate_h $@
diff --git a/buffalo/drivers/buffalocore.c b/buffalo/drivers/buffalocore.c
new file mode 100644
index 00000000..91c363d
--- /dev/null
+++ b/buffalo/drivers/buffalocore.c
@@ -0,0 +1,547 @@
+/*
+ *  Driver routines for BUFFALO Platform
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+#include "buffalocore.h"
+#include "kernevntProc.h"
+#include "buffalo/kernevnt.h"
+#include "proc_entry.h"
+#include "builddate.h"
+
+
+#define BUFCORE_VERSION "0.20"
+
+/* Module parameters */
+MODULE_AUTHOR("BUFFALO");
+MODULE_DESCRIPTION("Buffalo Platform Linux Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(BUFCORE_VERSION);
+
+//#define DEBUG
+#ifdef DEBUG
+#define FUNCTRACE(x)	x
+#else
+#define FUNCTRACE(x)	/* none */
+#endif
+
+void *
+buffalo_generic_seq_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < 1 ? SEQ_START_TOKEN : NULL;
+}
+
+void *
+buffalo_generic_seq_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++ *pos;
+	return NULL;
+}
+
+void
+buffalo_generic_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+
+/*
+ *	/proc/buffalo/booting
+ */
+int buffalo_booting = 1;
+
+static int
+buffalo_booting_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%d\n", buffalo_booting);
+	return 0;
+}
+
+static const struct seq_operations buffalo_booting_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_booting_show,
+};
+
+static int
+buffalo_booting_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_booting_op);
+}
+
+static ssize_t
+buffalo_booting_write(struct file *file, const char __user *buffer,
+		      size_t count, loff_t *ppos)
+{
+	char *kbuf;
+
+	kbuf = kmalloc(count + 1, GFP_KERNEL);
+	if (kbuf == NULL) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, buffer, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+
+	if (kbuf[count - 1] == '\n') {
+		kbuf[count - 1] = '\0';
+	}
+	else {
+		kbuf[count] = '\0';
+	}
+
+	if (strncmp(kbuf, "0", 1) == 0) {
+		buffalo_booting = 0;
+	}
+	else if (strncmp(kbuf, "1", 1) == 0) {
+		buffalo_booting = 1;
+	}
+	else {
+		printk("unknown value for booting(%s)\n", kbuf);
+		count = -EINVAL;
+	}
+out:
+	kfree(kbuf);
+
+	return count;
+}
+
+static struct file_operations buffalo_booting_fops = {
+	.open		= buffalo_booting_open,
+	.read		= seq_read,
+	.write		= buffalo_booting_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_entry_data buffalo_booting_entry =
+{
+	.path		= "booting",
+	.mode		= S_IRUGO|S_IWUSR,
+	.proc_fops	= &buffalo_booting_fops,
+	.data		= NULL,
+};
+
+
+/*
+ *	/proc/buffalo/cpu_status
+ */
+unsigned int bfMagicKey = MagicKeyHwPoff;
+
+static unsigned int
+bfGetMagicKey(void)
+{
+	return bfMagicKey;
+}
+
+/*
+ * define as 'weak',
+ * you can define architecture-depend bfSetMagicKey_arch()
+ */
+void (*bfSetMagicKey_arch)(unsigned int key) __attribute__((weak)) = NULL;
+
+static void
+bfSetMagicKey(unsigned int key)
+{ 
+	bfMagicKey = key;
+	if (bfSetMagicKey_arch != NULL) {
+		bfSetMagicKey_arch(key);
+	}
+}
+
+static struct buffalo_cpu_status_defs buffalo_cpu_status[] = {
+	{ MagicKeyNormalState,		"normal_state" },
+	{ MagicKeyReboot,		"reboot" },
+	{ MagicKeyWOLReadyState,	"WOLReady" },
+	{ MagicKeySwPoff,		"swpoff" },
+
+	{ MagicKeyTerminator,		NULL },
+};
+
+/*
+ * define as 'weak',
+ * you can define architecture-depend buffalo_cpu_status_arch
+ */
+struct buffalo_cpu_status_defs *buffalo_cpu_status_arch __attribute__((weak)) = NULL;
+
+
+static char *
+buffalo_find_cpu_status_str(unsigned int key,
+			    struct buffalo_cpu_status_defs *defs,
+			    struct buffalo_cpu_status_defs *defs_arch)
+{
+	int i;
+
+	for (i = 0; defs[i].stat != MagicKeyTerminator; i ++) {
+		if (defs[i].stat == key) {
+			return defs[i].str;
+		}
+	}
+
+	if (defs_arch != NULL) {
+		for (i = 0; defs_arch[i].stat != MagicKeyTerminator; i ++) {
+			if (defs_arch[i].stat == key) {
+				return defs_arch[i].str;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static unsigned int
+buffalo_find_cpu_status_id(char *stat_str,
+			   struct buffalo_cpu_status_defs *defs,
+			   struct buffalo_cpu_status_defs *defs_arch)
+{
+	int i;
+
+	for (i = 0; defs[i].stat != MagicKeyTerminator; i ++) {
+		if (strcmp(defs[i].str, stat_str) == 0) {
+			return defs[i].stat;
+		}
+	}
+
+	if (defs_arch != NULL) {
+		for (i = 0; defs_arch[i].stat != MagicKeyTerminator; i ++) {
+			if (strcmp(defs_arch[i].str, stat_str) == 0) {
+				return defs_arch[i].stat;
+			}
+		}
+	}
+
+	return MagicKeyTerminator;
+}
+
+static int
+buffalo_cpu_status_show(struct seq_file *m, void *v)
+{
+	unsigned int CpuStatus = bfGetMagicKey();
+	char *stat_str;
+
+	stat_str = buffalo_find_cpu_status_str(CpuStatus,
+					       buffalo_cpu_status,
+					       buffalo_cpu_status_arch);
+	if (stat_str != NULL) {
+		seq_printf(m, "%s\n", stat_str);
+	}
+	else {
+		seq_printf(m, "Unknown(CpuStatus=%u)\n", CpuStatus);
+	}
+
+	return 0;
+}
+
+static const struct seq_operations buffalo_cpu_status_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_cpu_status_show,
+};
+
+static int
+buffalo_cpu_status_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_cpu_status_op);
+}
+
+static ssize_t
+buffalo_cpu_status_write(struct file *file, const char __user *buffer,
+			 size_t count, loff_t *ppos)
+{
+	char *kbuf;
+	unsigned int CpuStatus;
+
+	kbuf = kmalloc(count + 1, GFP_KERNEL);
+	if (kbuf == NULL) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, buffer, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+
+	if (kbuf[count - 1] == '\n') {
+		kbuf[count -1] = '\0';
+	}
+	else {
+		kbuf[count] = '\0';
+	}
+
+	CpuStatus = buffalo_find_cpu_status_id(kbuf,
+					       buffalo_cpu_status,
+					       buffalo_cpu_status_arch);
+
+	if (CpuStatus != MagicKeyTerminator) {
+		bfSetMagicKey(CpuStatus);
+	}
+	else{
+		printk("unknown cpu_status(%s)\n", kbuf);
+		count = -EINVAL;
+	}
+out:
+	kfree(kbuf);
+
+	return count;
+}
+
+static struct file_operations buffalo_cpu_status_fops = {
+	.open		= buffalo_cpu_status_open,
+	.read		= seq_read,
+	.write		= buffalo_cpu_status_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_entry_data buffalo_cpu_status_entry =
+{
+	.path		= "cpu_status",
+	.mode		= S_IRUGO|S_IWUSR,
+	.proc_fops	= &buffalo_cpu_status_fops,
+	.data		= NULL,
+};
+
+
+
+/*
+ *	/proc/buffalo/firmware
+ */
+char buffalo_bootver[32] = { 0 };
+char buffalo_series_name[32] = { 0 };
+char buffalo_product_name[32] = { 0 };
+char buffalo_product_id[32] = { 0 };
+
+struct {
+	char *key;
+	char *value;
+	char *default_val;
+} cmdline_opts[] = {
+	{ "BOOTVER=",		buffalo_bootver,	"Unknown" },
+	{ "SERIES=",		buffalo_series_name,	"Unknown" },
+	{ "PRODUCTNAME=",	buffalo_product_name,	"Unknown" },
+	{ "PRODUCTID=",		buffalo_product_id,	"0x00000000" },
+};
+
+static int
+buffalo_firmware_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(cmdline_opts); i ++) {
+		char *p, *pe;
+
+		if (!isalpha(cmdline_opts[i].value[0])) {
+			memset(cmdline_opts[i].value, 0,
+			       strlen(cmdline_opts[i].value) + 1);
+			p = strstr(saved_command_line, cmdline_opts[i].key);
+			if (p != NULL) {
+				p += strlen(cmdline_opts[i].key);
+				pe = strstr(p, " ");
+
+				if ((pe != NULL) &&
+				    ((pe - p) < strlen(cmdline_opts[i].value))){
+					strncpy(cmdline_opts[i].value,
+						p, pe - p);
+				}
+				else {
+					strncpy(cmdline_opts[i].value,
+						p, strlen(cmdline_opts[i].value) + 1);
+				}
+			}
+			else {
+				sprintf(cmdline_opts[i].value, "%s",
+					cmdline_opts[i].default_val);
+			}
+		}
+	}
+
+	seq_printf(m, "SERIES=%s\n", buffalo_series_name);
+	seq_printf(m, "PRODUCTNAME=%s\n", buffalo_product_name);
+	seq_printf(m, "VERSION=%s\n", BUFCORE_VERSION);
+	seq_printf(m, "SUBVERSION=FLASH 0.00\n");
+	seq_printf(m, "PRODUCTID=%s\n", buffalo_product_id);
+	seq_printf(m, "BUILDDATE=%s %s\n",
+		   BUFFALO_BUILD_DATE, BUFFALO_BUILD_TIME);
+	seq_printf(m, "BOOTVER=%s\n", buffalo_bootver);
+
+	return 0;
+}
+
+static const struct seq_operations buffalo_firmware_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_firmware_show,
+};
+
+static int
+buffalo_firmware_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_firmware_op);
+}
+
+static struct file_operations buffalo_firmware_fops = {
+	.open		= buffalo_firmware_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_entry_data buffalo_firmware_entry =
+{
+	.path		= "firmware",
+	.mode		= S_IRUGO,
+	.proc_fops	= &buffalo_firmware_fops,
+	.data		= NULL,
+};
+
+
+/*
+ *	/proc/buffalo/micon
+ */
+#if defined(CONFIG_BUFFALO_USE_MICON) && !defined(CONFIG_BUFFALO_MICON_V3)
+static int
+buffalo_micon_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "on\n");
+	return 0;
+}
+
+static const struct seq_operations buffalo_micon_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_micon_show,
+};
+
+static int
+buffalo_micon_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_micon_op);
+}
+
+static struct file_operations buffalo_micon_fops = {
+	.open		= buffalo_micon_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_entry_data buffalo_micon_entry =
+{
+	.path		= "micon",
+	.mode		= S_IRUGO,
+	.proc_fops	= &buffalo_micon_fops,
+	.data		= NULL,
+};
+
+
+/*
+ * /proc/buffalo/miconint_en
+ */
+static int
+buffalo_miconint_en_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "MiconAct\n");
+	return 0;
+}
+
+static const struct seq_operations buffalo_miconint_en_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_miconint_en_show,
+};
+
+static int
+buffalo_miconint_en_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_miconint_en_op);
+}
+
+static struct file_operations buffalo_miconint_en_fops = {
+	.open		= buffalo_miconint_en_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static struct proc_entry_data buffalo_micon_entry =
+{
+	.path		= "miconint_en",
+	.mode		= S_IRUGO0,
+	.proc_fops	= &buffalo_miconint_en_fops,
+	.data		= NULL,
+};
+#endif	/* CONFIG_BUFFALO_USE_MICON && !CONFIG_BUFFALO_MICON_V3 */
+
+static struct proc_entry_data *ped_list[] = {
+	&buffalo_booting_entry,
+	&buffalo_cpu_status_entry,
+	&buffalo_firmware_entry,
+#if defined(CONFIG_BUFFALO_USE_MICON) && !defined(CONFIG_BUFFALO_MICON_V3)
+	&buffalo_micon_entry,
+	&buffalo_miconint_en_entry,
+#endif	/* CONFIG_BUFFALO_USE_MICON && !CONFIG_BUFFALO_MICON_V3 */
+	NULL,
+};
+
+//----------------------------------------------------------------------
+int __init
+buffaloDriver_init (void)
+{
+	int i;
+
+        FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	for (i = 0; ped_list[i]; i ++) {
+		make_proc_entry(ped_list[i]);
+	}
+
+	return 0;
+}
+
+//----------------------------------------------------------------------
+void
+buffaloDriver_exit(void)
+{
+	int i;
+	struct proc_dir_entry *buffalo;
+
+	FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	buffalo = get_proc_buffalo();
+	for (i = 0; ped_list[i]; i++) {
+		remove_proc_entry(ped_list[i]->path, buffalo);
+	}
+
+	remove_proc_entry ("buffalo", 0);
+}
+
+module_init(buffaloDriver_init);
+module_exit(buffaloDriver_exit);
diff --git a/buffalo/drivers/buffalocore.h b/buffalo/drivers/buffalocore.h
new file mode 100644
index 00000000..880c6cf
--- /dev/null
+++ b/buffalo/drivers/buffalocore.h
@@ -0,0 +1,27 @@
+#if !defined(_BUFFALOCORE_H_)
+#define _BUFFALOCORE_H_
+
+#ifdef CONFIG_X86
+#else // CONFIG_X86
+#if defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+#include "boardEnv/buffalo/buffalo78100BoardEnv.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#endif
+
+#endif // CONFIG_X86
+
+#if defined(CONFIG_ARCH_FEROCEON_KW) || defined(CONFIG_ARCH_ARMADA370) || defined(CONFIG_ARCH_ARMADA_XP)
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+struct bf_proc_entry_tab {
+  const char *name;
+  int isDirectory;
+  read_proc_t *read_proc;
+  write_proc_t *write_proc;
+  void *data;
+  MV_BOARD_GPP_CLASS class;
+};
+#endif
+
+#endif
diff --git a/buffalo/drivers/kernevnt.c b/buffalo/drivers/kernevnt.c
new file mode 100644
index 00000000..710029c
--- /dev/null
+++ b/buffalo/drivers/kernevnt.c
@@ -0,0 +1,359 @@
+/*
+ *  LinkStation/TeraStation Kernel Event Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#ifdef CONFIG_PHYLIB
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#endif /*CONFIG_PHYLIB*/
+#include <asm/string.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/serial.h>
+#include "buffalo/kernevnt.h"
+#include "kernevntProc.h"
+
+#define bzero(p,sz) memset(p,0,sz)
+
+//#define DEBUG
+//#define FUNCMSG
+
+#ifdef DEBUG
+#define TRACE(x)	x
+#else
+#define TRACE(x)	/* none */
+#endif
+
+#ifdef FUNCMSG
+#define FUNC_MSG(x)	x
+#else	/* FUNCMSG */
+#define FUNC_MSG(x)	/* none */
+#endif	/* FUNCMSG */
+
+static DEFINE_SPINLOCK(BuffaloMicon_event_lock);
+
+wait_queue_head_t buffalo_kernevnt_WaitQueue;
+static int initialized=0;
+static struct tag_MiconDevice {
+	struct {
+		char cmd[MAX_CMDLEN+1];
+	} cmdqueue[MAX_QUELEN];
+	int rindex,windex;
+} MiconDevice;
+
+//--------------------------------------------------------------
+void
+buffalo_kernevnt_queuein(const char *cmd)
+{
+	if (!initialized){
+		return;
+	}
+	printk(KERN_DEBUG "kernevnt: %s\n", cmd);
+	if (MiconDevice.cmdqueue[MiconDevice.windex].cmd[0] == 0) {
+		unsigned long flags;
+		spin_lock_irqsave(&BuffaloMicon_event_lock, flags);
+
+		strncpy(MiconDevice.cmdqueue[MiconDevice.windex].cmd,
+			cmd, MAX_CMDLEN - 1);
+		MiconDevice.windex ++;
+		if (MiconDevice.windex == ARRAY_SIZE(MiconDevice.cmdqueue)) {
+			MiconDevice.windex = 0;
+		}
+
+		spin_unlock_irqrestore(&BuffaloMicon_event_lock, flags);
+
+		TRACE(printk("queue in : r=%d w=%d [%s]\n",
+			     MiconDevice.rindex, MiconDevice.windex, cmd));
+	}
+	else {
+		TRACE(printk("queue full [%s]\n",cmd));
+	}
+	wake_up_interruptible(&buffalo_kernevnt_WaitQueue);
+}
+
+//--------------------------------------------------------------
+int
+buffalo_kernevnt_queueout(unsigned char *cmd, int *len)
+{
+	if (!initialized){
+		return -1;
+	}
+	if (MiconDevice.cmdqueue[MiconDevice.rindex].cmd[0] != 0){
+		int index;
+		index = MiconDevice.rindex;
+
+		TRACE(printk("queue out : r=%d w=%d [%s]\n",
+			     MiconDevice.rindex, MiconDevice.windex,
+			     MiconDevice.cmdqueue[index].cmd));
+
+		spin_lock_irq(&BuffaloMicon_event_lock);
+		
+		if (MiconDevice.cmdqueue[index].cmd[0] != 0) {
+			strncpy(cmd, MiconDevice.cmdqueue[index].cmd,
+				MAX_CMDLEN);
+			*len = strlen(cmd) + 1;  // for NULL terminate.
+			MiconDevice.cmdqueue[index].cmd[0] = 0;
+		}
+		MiconDevice.rindex ++;
+		if (MiconDevice.rindex == ARRAY_SIZE(MiconDevice.cmdqueue)) {
+			MiconDevice.rindex = 0;
+		}
+
+		spin_unlock_irq (&BuffaloMicon_event_lock);
+
+		return index;
+	}
+	else{
+		TRACE(printk("queue none\n"));
+	}
+	return -1;
+}
+
+#ifdef CONFIG_MD
+//--------------------------------------------------------------
+void
+kernevnt_RaidRecovery(int devno, int on, int isRecovery, int major, int minor)
+{
+	static int opencnt = 0;
+	char buff[64];
+
+	FUNC_MSG(printk(">%s:md%d on=%d cnt=%d isRecovery=%d %d %d\n",
+			__FUNCTION__, devno, on, opencnt, isRecovery,
+			major, minor));
+	
+	if (on) {
+		opencnt ++;
+	}
+	else {
+		opencnt --;
+	}
+	
+	if (isRecovery) {
+		sprintf(buff,"raidrecovery %d %d %d %d %d %d",
+			devno, on, opencnt, isRecovery, major, minor);
+	}
+	else{
+		sprintf(buff,"raidresync %d %d %d %d",
+			devno, on, opencnt, isRecovery);
+	}
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void
+kernevnt_RaidScan(int devno, int on)
+{
+	static int opencnt = 0;
+	char buff[64];
+
+	FUNC_MSG(printk(">%s:md%d on=%d cnt=%d\n",
+			__FUNCTION__, devno, on, opencnt));
+
+	if (on) {
+		opencnt ++;
+	}
+	else {
+		opencnt --;
+	}
+
+	sprintf(buff, "raidscan %d %d %d", devno, on, opencnt);
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void
+kernevnt_RaidDegraded(int devno, int major, int minor)
+{
+	char buff[64];
+
+	FUNC_MSG(printk(">%s:md%d %d %d\n",
+			__FUNCTION__, devno, major, minor));
+
+	sprintf(buff,"raiddegraded %d %d %d", devno, major, minor);
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void
+kernevnt_RaidReshape(int devno, int on)
+{
+	static int opencnt = 0;
+	char buff[64];
+
+	if (on) {
+		opencnt++;
+	}
+	else {
+		opencnt--;
+	}
+
+	sprintf(buff, "raidreshape %d %d %d", devno, on, opencnt);
+	buffalo_kernevnt_queuein(buff);
+}
+
+#endif /* CONFIG_MD */
+
+//--------------------------------------------------------------
+void
+kernevnt_FlashUpdate(int on)
+{
+	char msg[32];
+
+	FUNC_MSG(printk(">%s (%d)\n", __FUNCTION__, on));
+
+	sprintf(msg, "flashupdate %d", on);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+#ifdef CONFIG_PHYLIB
+void
+kernevnt_LanAct_phydev(void *data)
+{
+	struct phy_device *phydev = data;
+	struct net_device *netdev;
+	char msg[128];
+
+	BUG_ON(!phydev);
+	netdev = phydev->attached_dev;
+	BUG_ON(!netdev);
+	sprintf(msg, "lanact %d %s %s",
+	    phydev->link ? phydev->speed : 0,
+	    phydev->duplex ? "full" : "half",
+	    netdev->name);
+	buffalo_kernevnt_queuein(msg);
+}
+void (*kernevnt_LanAct_arch)(void *data) = kernevnt_LanAct_phydev;
+#else /*CONFIG_PHYLIB*/
+void (*kernevnt_LanAct_arch)(void *data) = NULL;
+#endif /*CONFIG_PHYLIB*/
+void
+kernevnt_LanAct(void *data)
+{
+	if (kernevnt_LanAct_arch != NULL) {
+		kernevnt_LanAct_arch(data);
+	}
+}
+void
+kernevnt_LanAct_params(char *name, int speed, int duplex)
+{
+	char msg[128];
+
+	sprintf(msg, "lanact %d %s %s",
+	    speed,
+	    duplex ? "full" : "half",
+	    name);
+	buffalo_kernevnt_queuein(msg);
+}
+
+void
+kernevnt_SwitchHubAct(const char *msg)
+{
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void
+kernevnt_IOErr(const char *kdevname, const char *dir, unsigned long long sector, unsigned int errcnt)
+{
+	char msg[64];
+
+	FUNC_MSG(printk(">%s(%s): I/O error, dev %s, sector %llu\n",
+			__FUNCTION__,kdevname, dir,
+			(unsigned long long)sector, errcnt));
+
+	sprintf(msg,"ioerr %s %s %llu %u",kdevname, dir,
+		(unsigned long long)sector, errcnt);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void
+kernevnt_DriveDead(const char *drvname)
+{
+	char msg[64];
+
+	FUNC_MSG(printk(">%s: drive %s is dead.\n",__FUNCTION__,drvname));
+
+	sprintf(msg,"drivedead %s",drvname);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void
+kernevnt_I2cErr(void)
+{
+	printk(">%s\n",__FUNCTION__);
+	buffalo_kernevnt_queuein("i2c_error");
+}
+
+//--------------------------------------------------------------
+void
+kernevnt_MiconInt(void)
+{
+	FUNC_MSG(printk(">%s\n",__FUNCTION__));
+
+	buffalo_kernevnt_queuein("micon_interrupts");
+}
+
+//--------------------------------------------------------------
+void
+kernevnt_EnetOverload(const char *name)
+{
+	char msg[64];
+
+	FUNC_MSG(printk(">%s\n",__FUNCTION__));
+
+	sprintf(msg,"enetover %s",name);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+/*
+ * Initialize driver.
+ */
+int __init
+BuffaloMicon_init (void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	printk("MICON ctrl (C) BUFFALO INC. V.1.00 installed.\n"); 
+	
+	// Initialize Local valiables
+	bzero(&MiconDevice, sizeof(MiconDevice));
+	init_waitqueue_head(&buffalo_kernevnt_WaitQueue);
+	initialized=1;
+	return 0;
+}
+
+//--------------------------------------------------------------
+void
+BuffaloMicon_exit(void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	printk("MICON ctrl removed.\n");
+	initialized=0;
+
+}
+
+EXPORT_SYMBOL(buffalo_kernevnt_queuein);
+EXPORT_SYMBOL(buffalo_kernevnt_queueout);
+EXPORT_SYMBOL(buffalo_kernevnt_WaitQueue);
+
+module_init(BuffaloMicon_init);
+module_exit(BuffaloMicon_exit);
+MODULE_LICENSE("GPL");
diff --git a/buffalo/drivers/kernevntProc.c b/buffalo/drivers/kernevntProc.c
new file mode 100644
index 00000000..ec833ff
--- /dev/null
+++ b/buffalo/drivers/kernevntProc.c
@@ -0,0 +1,130 @@
+/*
+ *  LinkStation/TeraStation Kernel Event Proc Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+
+#include "buffalocore.h"
+#include "kernevntProc.h"
+#include "proc_entry.h"
+
+#define bzero(p,sz) memset(p,0,sz)
+
+//#define DEBUG
+
+#ifdef DEBUG
+ #define TRACE(x) x
+#else
+ #define TRACE(x)
+#endif
+
+extern void buffalo_kernevnt_queuein(const char *cmd);
+extern int buffalo_kernevnt_queueout(unsigned char *cmd, int *len);
+extern wait_queue_head_t  buffalo_kernevnt_WaitQueue;
+
+
+// event notice from kernel
+static int
+BuffaloKernevnt_show(struct seq_file *m, void *v)
+{
+	int len = 0;
+	char retbuff[MAX_CMDLEN + 1 + 2];
+
+	if (wait_event_interruptible(buffalo_kernevnt_WaitQueue,
+		buffalo_kernevnt_queueout(retbuff, &len) >= 0) != 0) {
+		return -EIO;	/* XXX : reasonable ? */
+	}
+	
+	seq_printf(m, "%s", retbuff);
+	return 0;
+}
+
+extern void *buffalo_generic_seq_start(struct seq_file *m, loff_t *pos);
+extern void *buffalo_generic_seq_next(struct seq_file *m, void *v, loff_t *pos);
+extern void buffalo_generic_seq_stop(struct seq_file *m, void *v);
+
+static const struct seq_operations buffalo_kernevnt_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= BuffaloKernevnt_show,
+};
+
+static int
+BuffaloKernevnt_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_kernevnt_op);
+}
+static ssize_t
+BuffaloKernevnt_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char kbuf[MAX_CMDLEN + 1 + 2];
+
+	if (count >= sizeof(kbuf)) {
+		count = sizeof(kbuf) - 1;
+	}
+	if (copy_from_user(kbuf, buf, count)) {
+		return -EFAULT;
+	}
+	kbuf[count] = 0;
+	buffalo_kernevnt_queuein(kbuf);
+	*ppos += count;
+	return count;
+}
+
+static struct file_operations kernevnt_fops = {
+	.open		= BuffaloKernevnt_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+	.write		= BuffaloKernevnt_write,
+};
+
+
+/*
+ * Initialize driver.
+ */
+int
+BuffaloKernevnt_init (void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	printk("Kernel event proc (C) BUFFALO INC. V.1.00 installed.\n"); 
+
+	proc_create("kernevnt", S_IRUGO|S_IWUSR, get_proc_buffalo(), &kernevnt_fops);
+	
+	return 0;
+}
+
+void
+BuffaloKernevnt_exit(void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	remove_proc_entry("kernevnt", get_proc_buffalo());
+	printk("Kernel event proc removed.\n");
+}
+
+
+module_init(BuffaloKernevnt_init);
+module_exit(BuffaloKernevnt_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/buffalo/drivers/kernevntProc.h b/buffalo/drivers/kernevntProc.h
new file mode 100644
index 00000000..75570e1
--- /dev/null
+++ b/buffalo/drivers/kernevntProc.h
@@ -0,0 +1,11 @@
+#ifndef _KERNEVNTPROC_H_
+#define _KERNEVNTPROC_H_
+
+#define MAX_CMDLEN  32
+#define MAX_QUELEN  32
+
+int BuffaloKernevnt_init (void);
+void BuffaloKernevnt_exit(void);
+
+#endif
+
diff --git a/buffalo/drivers/micon_v3.c b/buffalo/drivers/micon_v3.c
new file mode 100644
index 00000000..3fcbc1d
--- /dev/null
+++ b/buffalo/drivers/micon_v3.c
@@ -0,0 +1,328 @@
+/*
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/delay.h>
+#include <buffalo/micon_v3.h>
+
+
+#ifdef CONFIG_BUFFALO_MICON_V3_DEVTTY
+#define MICON_DEV		CONFIG_BUFFALO_MICON_V3_DEVTTY
+#else	/* CONFIG_BUFFALO_MICON_V3_DEVTTY */
+#warning "CONFIG_BUFFALO_MICON_V3_DEVTTY is not defined, use /dev/ttyS1"
+#define MICON_DEV		"/dev/ttyS1"
+#endif	/* CONFIG_BUFFALO_MICON_V3_DEVTTY */
+#define MICON_BAUD		115200
+#define MICON_BAUD_SYM		B115200
+
+#define MICON_INIT_MARK		0x1b	/* (ESC) */
+#define MICON_DELIMITER		0x0d	/* "\r" */
+
+#define MICON_CMD_POW_OFF	"POW_OFF"
+#define MICON_CMD_REBOOT	"REBOOT"
+
+#define MICON_RSP_ACK		"OK"
+#define MICON_RSP_NACK		"NG"
+
+#define MICON_RSP_MAX		256	/* XXX: reasonable ? */
+#define MICON_RETRY_MAX		3
+
+
+#define DEBUG
+#ifdef DEBUG
+#define TRACE(arg)	arg
+#else	/* DEBUG */
+#define TRACE(arg)	/* none */
+#endif	/* DEBUG */
+
+
+static int
+micon_v3_serial_io(char *indata, int inlen, char *outdata, int outlen)
+{
+	int fd;
+	int sys_val = 0;
+	struct termios termios;
+	struct termios termios_save;
+	char *cmdbuf = NULL;
+	int cmdbuflen;
+	char rspbuf[MICON_RSP_MAX];
+	int rsplen;
+	mm_segment_t oldfs;
+	int try;
+	int i;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	fd = sys_open(MICON_DEV, O_RDWR | O_NDELAY, 0);
+	if (fd < 0) {
+		printk(KERN_ERR "Micon device(%s): open failed.(%d)\n",
+		       MICON_DEV, fd);
+		set_fs(oldfs);
+		return fd;
+	}
+
+	sys_val = sys_ioctl(fd, TCGETS, (long)&termios_save);
+	if (sys_val < 0) {
+		printk(KERN_ERR "Micon device(%s): ioctl(TCGETS) failed.(%d)\n",
+		       MICON_DEV, sys_val);
+		sys_close(fd);
+		set_fs(oldfs);
+		return sys_val;
+	}
+
+	memset(&termios, 0, sizeof(termios));
+	termios.c_cflag = MICON_BAUD_SYM | CS8 | CLOCAL | CREAD;
+	termios.c_iflag = IGNPAR;
+	sys_val = sys_ioctl(fd, TCSETS, (unsigned long)&termios);
+	if (sys_val < 0) {
+		printk(KERN_ERR "Micon device(%s): ioctl(TCSETS) failed.(%d)\n",
+		       MICON_DEV, sys_val);
+		goto out;
+	}
+
+	/* read all data before real I/O */
+	while (1) {
+		sys_val = sys_read(fd, rspbuf, sizeof(rspbuf));
+		if (sys_val == 0) {
+			TRACE(printk(KERN_DEBUG "Micon buffer cleared.\n"));
+			break;
+		}
+		else if (sys_val < 0) {
+			printk(KERN_ERR "Micon buffer clear failed.\n");
+			goto out;
+		}
+	}
+
+	cmdbuflen = 1;	/* at least 1 byte */
+	if (inlen > cmdbuflen) {
+		cmdbuflen = inlen;
+	}
+	cmdbuflen ++;	/* for string terminator '\0' */
+	cmdbuf = kmalloc(cmdbuflen, GFP_KERNEL);
+	if (cmdbuf == NULL) {
+		printk(KERN_ERR "Micon I/O buffer allocation failed.\n");
+		return -ENOMEM;
+	}
+
+	for (try = 0; try < MICON_RETRY_MAX; try ++) {
+		/* initialize */
+		memset(cmdbuf, 0, cmdbuflen);
+		snprintf(cmdbuf, cmdbuflen, "%c", MICON_INIT_MARK);
+		sys_val = sys_write(fd, cmdbuf, strlen(cmdbuf));
+		TRACE(printk(KERN_DEBUG "CPU->MICON: INIT\n"));
+		if (sys_val < 0) {
+			printk(KERN_ERR "Micon device(%s): write(init) failed.\n",
+			       MICON_DEV);
+			continue;
+		}
+		else if (sys_val != strlen(cmdbuf)) {
+			printk(KERN_ERR "Micon device(%s): write(init) failed."
+			       " expect %d bytes, but %d bytes was written\n",
+			       MICON_DEV, strlen(cmdbuf), sys_val);
+			continue;
+		}
+		msleep_interruptible(10);	/* 10ms */
+		sys_val = sys_read(fd, rspbuf, sizeof(rspbuf));
+
+		/* send command */
+		memset(cmdbuf, 0, cmdbuflen);
+		snprintf(cmdbuf, cmdbuflen, "%s", indata);
+		sys_val = sys_write(fd, cmdbuf, strlen(cmdbuf));
+		/*
+		 * XXX:
+		 *	it might need sys_write() loop in strictly sense,
+		 *	but this driver doesn't care
+		 *	because command is enough short.
+		 */
+		if (sys_val < 0) {
+			printk(KERN_ERR "Micon device(%s): write(%s) failed.(%d)\n",
+			       MICON_DEV, cmdbuf, sys_val);
+			continue;
+		}
+		else if (sys_val != strlen(cmdbuf)) {
+			printk(KERN_ERR "Micon device(%s): write(%s) failed."
+			       "expect %d bytes, but %d bytes was written\n",
+			       MICON_DEV, cmdbuf, strlen(cmdbuf), sys_val);
+			continue;
+		}
+		TRACE(printk(KERN_DEBUG "CPU->MICON: send [%s]\n", cmdbuf));
+
+		/* check echo-back */
+		rsplen = 0;
+		memset(rspbuf, 0, sizeof(rspbuf));
+		for (i = 0; i < 10/*???*/; i++) {
+			if (rsplen >= sizeof(rspbuf)) {
+				break;
+			}
+			sys_val = sys_read(fd, rspbuf + rsplen,
+					   sizeof(rspbuf) - rsplen);
+			if (sys_val == 0) {
+				break;
+			}
+			else if (sys_val < 0) {
+				if (sys_val == -EAGAIN) {
+					msleep_interruptible(1000);/* XXX */
+					continue;
+				}
+				printk(KERN_ERR "Micon device(%s): read() failed.(%d)\n",
+				       MICON_DEV, sys_val);
+				continue;
+			}
+			else {
+				rsplen += sys_val;
+			}
+			if (rsplen == strlen(cmdbuf)) {
+				break;
+			}
+			msleep_interruptible(10);
+		}
+		TRACE(printk(KERN_DEBUG
+			     "MICON->CPU: echo-back [%s], ", rspbuf));
+		if (strncmp(rspbuf, cmdbuf, rsplen) == 0) {
+			TRACE(printk(KERN_DEBUG "OK"));
+			break;
+		}
+		else {
+			TRACE(printk(KERN_DEBUG "NG"));
+		}
+	}
+	if (try >= MICON_RETRY_MAX) {
+		printk(KERN_ERR
+		       "Micon device(%s): give up to write, can't get echo-back\n",
+		       MICON_DEV);
+		goto out;
+	}
+
+	/* send delimiter */
+	memset(cmdbuf, 0, cmdbuflen);
+	snprintf(cmdbuf, cmdbuflen, "%c", MICON_DELIMITER);
+	sys_val = sys_write(fd, cmdbuf, strlen(cmdbuf));
+	if (sys_val < 0) {
+		printk(KERN_ERR
+		       "Micon device(%s): write(delimiter) failed. (%d)\n",
+		       MICON_DEV, sys_val);
+		goto out;
+	}
+	msleep_interruptible(10);
+	sys_val = sys_read(fd, rspbuf, strlen(cmdbuf));
+	if (sys_val < 0) {
+		printk(KERN_ERR
+		       "Micon device(%s): write(delimiter) failed. (%d)\n",
+		       MICON_DEV, sys_val);
+		goto out;
+	}
+	TRACE(printk(KERN_DEBUG "CPU->MICON: send delimiter\n"));
+
+	/* read response */
+	rsplen = 0;
+	memset(rspbuf, 0, sizeof(rspbuf));
+	for (i = 0; i < 10/*XXX*/; i ++) {
+		int j;
+
+		if (rsplen >= sizeof(rspbuf)) {
+			break;
+		}
+		sys_val = sys_read(fd, rspbuf + rsplen,
+				   sizeof(rspbuf) - rsplen);
+		if (sys_val == 0) {
+			break;
+		}
+		else if (sys_val < 0) {
+			if (sys_val == -EAGAIN) {
+				msleep_interruptible(10);/* XXX */
+				continue;
+			}
+			printk(KERN_ERR "Micon device(%s): read() failed.(%d)\n",
+			       MICON_DEV, sys_val);
+			continue;
+		}
+		else {
+			rsplen += sys_val;
+			for (j = 0; j < rsplen; j ++) {
+				if (rspbuf[j] == '\n') {
+					break;
+				}
+			}
+			if (rspbuf[j] == '\n') {
+				break;
+			}
+		}
+		msleep_interruptible(10);
+	}
+	TRACE(printk(KERN_DEBUG "MICON->CPU: [%s]\n", rspbuf));
+	memcpy(outdata, rspbuf, (sys_val > outlen) ? outlen : sys_val);
+
+out:
+	if (cmdbuf != NULL) {
+		kfree(cmdbuf);
+	}
+	sys_ioctl(fd, TCSETS, (long)&termios_save);
+	sys_close(fd);
+	set_fs(oldfs);
+	return sys_val;
+}
+
+
+static int
+micon_v3_send_simple_command(char *cmd, int cmdlen)
+/* expect "OK" or "NG" */
+{
+	char rspbuf[MICON_RSP_MAX];
+	int micon_ret;
+
+	memset(rspbuf, 0, sizeof(rspbuf));
+	micon_ret = micon_v3_serial_io(cmd, cmdlen, rspbuf, sizeof(rspbuf));
+	if (micon_ret < 0) {
+		return micon_ret;
+	}
+
+	if (strncmp(rspbuf, MICON_RSP_ACK, strlen(MICON_RSP_ACK)) == 0) {
+		TRACE(printk(KERN_DEBUG "Micon ACK(OK) is found\n"));
+	}
+	else if (strncmp(rspbuf, MICON_RSP_NACK, strlen(MICON_RSP_NACK)) == 0) {
+		printk(KERN_ERR "Micon NACK(NG) is found\n");
+		/* XXX: need retry ??? */
+		return -1;
+	}
+	else {
+		printk(KERN_ERR "Micon unexpected response[%s]\n", rspbuf);
+		/* XXX: need retry ??? */
+		return -1;
+	}
+
+	return 0;
+}
+
+void
+miconCntl_PowerOff(void)
+{
+	int rsp;
+
+	rsp = micon_v3_send_simple_command(MICON_CMD_POW_OFF,
+					   strlen(MICON_CMD_POW_OFF));
+	if (rsp != 0) {
+		printk(KERN_ERR "%s() failed\n", __FUNCTION__);
+	}
+
+	return;
+}
+
+void
+miconCntl_Reboot(void)
+{
+	int rsp;
+
+	rsp = micon_v3_send_simple_command(MICON_CMD_REBOOT,
+					   strlen(MICON_CMD_REBOOT));
+	if (rsp != 0) {
+		printk(KERN_ERR "%s() failed\n", __FUNCTION__);
+	}
+
+	return;
+}
diff --git a/buffalo/drivers/proc_entry.c b/buffalo/drivers/proc_entry.c
new file mode 100644
index 00000000..0ad7b2d
--- /dev/null
+++ b/buffalo/drivers/proc_entry.c
@@ -0,0 +1,38 @@
+#include <linux/string.h>
+#include "proc_entry.h"
+
+
+static struct proc_dir_entry *proc_buffalo = NULL;
+
+struct proc_dir_entry *
+get_proc_buffalo(void)
+{
+	if (proc_buffalo == NULL)
+		proc_buffalo = proc_mkdir("buffalo", NULL);
+
+	return proc_buffalo;
+}
+
+void
+make_proc_entry(struct proc_entry_data *entry)
+{
+	struct proc_dir_entry *proc_buffalo;
+	struct proc_dir_entry *pde;
+
+	proc_buffalo = get_proc_buffalo();
+	if (proc_buffalo == NULL) {
+		/* XXX */
+	}
+
+	pde = proc_create_data(entry->path, entry->mode,
+			       proc_buffalo, entry->proc_fops, entry->data);
+	if (pde == NULL) {
+		/* XXX */
+	}
+}
+
+void
+delete_proc_entry(char *path)
+{
+	remove_proc_entry(path, NULL);
+}
diff --git a/buffalo/drivers/proc_entry.h b/buffalo/drivers/proc_entry.h
new file mode 100644
index 00000000..ff4fa53e
--- /dev/null
+++ b/buffalo/drivers/proc_entry.h
@@ -0,0 +1,20 @@
+#ifndef _BUFFALO_PROC_ENTRY_H_
+#define _BUFFALO_PROC_ENTRY_H_
+
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+
+
+struct proc_entry_data {
+	char			path[64];
+	umode_t			mode;
+	struct file_operations	*proc_fops;
+	void			*data;
+};
+
+struct proc_dir_entry* get_proc_buffalo(void);
+void make_proc_entry(struct proc_entry_data *entry);
+void delete_proc_entry(char *path);
+
+
+#endif	/* _BUFFALO_PROC_ENTRY_H_ */
diff --git a/buffalo/drivers/rtc_nvram.c b/buffalo/drivers/rtc_nvram.c
new file mode 100644
index 00000000..35ba102
--- /dev/null
+++ b/buffalo/drivers/rtc_nvram.c
@@ -0,0 +1,29 @@
+/*
+ *
+ */
+#include "rtc_nvram.h"
+
+void
+BuffaloRtc_UPSRecoverInit(void)
+{
+	/* XXX: TODO */
+}
+
+extern void
+BuffaloRtc_UPSRecoverEnable(int8_t TargetType)
+{
+	/* XXX: TODO */
+}
+
+extern void
+BuffaloRtc_UPSRecoverDisable(void)
+{
+	/* XXX: TODO */
+}
+
+extern int
+BuffaloRtc_UPSRecoverReadStatus(void)
+{
+	/* XXX: TODO */
+	return 0;
+}
diff --git a/buffalo/drivers/rtc_nvram.h b/buffalo/drivers/rtc_nvram.h
new file mode 100644
index 00000000..8715909
--- /dev/null
+++ b/buffalo/drivers/rtc_nvram.h
@@ -0,0 +1,16 @@
+#ifndef _RTC_NVRAM_H_
+#define _RTC_NVRAM_H_
+
+#include <linux/types.h>
+
+#define RECOVER_TARGET_UPS_APC  1
+#define RECOVER_TARGET_UPS_OMR  2
+#define RECOVER_TARGET_UPS_USB  3
+#define RECOVER_TARGET_UPS_ALL  4
+
+extern void BuffaloRtc_UPSRecoverInit(void);
+extern void BuffaloRtc_UPSRecoverEnable(int8_t TargetType);
+extern void BuffaloRtc_UPSRecoverDisable(void);
+extern int BuffaloRtc_UPSRecoverReadStatus(void);
+
+#endif	/* _RTC_NVRAM_H_ */
diff --git a/buffalo/drivers/upsdrv.c b/buffalo/drivers/upsdrv.c
new file mode 100644
index 00000000..539358a
--- /dev/null
+++ b/buffalo/drivers/upsdrv.c
@@ -0,0 +1,301 @@
+/*
+ *  LinkStation/TeraStation UPS port Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include "buffalocore.h"
+#include "rtc_nvram.h"
+
+
+extern void *buffalo_generic_seq_start(struct seq_file *m, loff_t *pos);
+extern void *buffalo_generic_seq_next(struct seq_file *m, void *v, loff_t *pos);
+extern void buffalo_generic_seq_stop(struct seq_file *m, void *v);
+
+
+#define bzero(p,sz) memset(p,0,sz)
+
+//#define DEBUG_UPS
+
+/* Function prototypes */
+
+
+/* variables */
+static struct proc_dir_entry *proc_buffalo_ups;
+
+
+#ifdef CONFIG_BUFFALO_SUPPORT_UPS_RECOVER
+//--------------------------------------------------------------
+static void
+BuffaloUpsRecoverInit(void)
+{
+	BuffaloRtc_UPSRecoverInit();
+	printk("BUFFALO UPS Recover Function Initialized.\n");
+
+}
+
+//--------------------------------------------------------------
+static struct {
+	int	mode;
+	char	*w_str;
+	char	*r_str;
+} buffalo_ups_mode_defs[] = {
+	{ 0,	/* default */		"off",		"off"		},
+	{ RECOVER_TARGET_UPS_ALL,	"on",		"on"		},
+};
+
+static int
+buffalo_ups_recover_show(struct seq_file *m, void *v)
+{
+	int i;
+	int stat = BuffaloRtc_UPSRecoverReadStatus();
+	int found = 0;	/* default */
+
+	for (i = 1; i < ARRAY_SIZE(buffalo_ups_mode_defs); i ++) {
+		if (buffalo_ups_mode_defs[i].mode == stat) {
+			found = i;
+			break;
+		}
+	}
+
+	seq_printf(m, "%s\n", buffalo_ups_mode_defs[found].r_str);
+
+	return 0;
+}
+
+static const
+struct seq_operations buffalo_ups_recover_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_ups_recover_show,
+};
+
+static int
+buffalo_ups_recover_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_ups_recover_op);
+}
+
+static ssize_t
+buffalo_ups_recover_write(struct file *file, const char __user *buffer,
+			  size_t count, loff_t *ppos)
+{
+	int8_t OnTarget = -1;
+	char *kbuf;
+	int i;
+
+	kbuf = kmalloc(count + 1, GFP_KERNEL);
+	if (kbuf == NULL) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(kbuf, buffer, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+
+	kbuf[count] = 0;
+
+	for (i = 0; i < ARRAY_SIZE(buffalo_ups_mode_defs); i ++) {
+		if (strncmp(kbuf, buffalo_ups_mode_defs[i].w_str,
+			    strlen(buffalo_ups_mode_defs[i].w_str)) == 0) {
+			OnTarget = buffalo_ups_mode_defs[i].mode;
+			break;
+		}
+	}
+
+	if (OnTarget > 0) {
+		BuffaloRtc_UPSRecoverEnable(OnTarget);
+	}
+	else if (OnTarget == 0) {
+		BuffaloRtc_UPSRecoverDisable();
+	}
+
+out:
+	kfree(kbuf);
+	return count;
+}
+
+static
+struct file_operations buffalo_ups_recover_fops = {
+	.open		= buffalo_ups_recover_open,
+	.read		= seq_read,
+	.write		= buffalo_ups_recover_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+#endif /* CONFIG_BUFFALO_SUPPORT_UPS_RECOVER */
+
+
+#ifdef CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+static unsigned int OmronShutdownEnable = 0;
+
+static int
+buffalo_ups_omron_shutdown_enable_show(struct seq_file *m, void *v)
+{
+	if (OmronShutdownEnable) {
+		seq_printf(m, "on\n");
+	}
+	else {
+		seq_printf(m, "off\n");
+	}
+	return 0;
+}
+
+static const
+struct seq_operations buffalo_ups_omron_shutdown_enable_op = {
+	.start	= buffalo_generic_seq_start,
+	.next	= buffalo_generic_seq_next,
+	.stop	= buffalo_generic_seq_stop,
+	.show	= buffalo_ups_omron_shutdown_enable_show,
+};
+
+static int
+buffalo_ups_omron_shutdown_enable_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &buffalo_ups_omron_shutdown_enable_op);
+}
+
+static ssize_t
+buffalo_ups_omron_shutdown_enable_write(struct file *file,
+					const char __user *buffer,
+					size_t count, loff_t *ppos)
+{
+	char *kbuf;
+
+	kbuf = kmalloc(count + 1, GFP_KERNEL);
+	if (kbuf == NULL) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(&kbuf, buffer, count)) {
+		count = -EFAULT;
+		goto out;
+	}
+
+	kbuf[count] = '\0';
+
+	if (strncmp(kbuf, "on", 2) == 0) {
+		OmronShutdownEnable = 1;
+	}
+	else if (strncmp(kbuf, "off", 3) == 0) {
+		OmronShutdownEnable = 0;
+	}
+
+out:
+	kfree(kbuf);
+	return count;
+}
+
+static
+struct file_operations buffalo_ups_omron_shutdown_enable_fops = {
+	.open		= buffalo_ups_omron_shutdown_enable_open,
+	.read		= seq_read,
+	.write		= buffalo_ups_omron_shutdown_enable_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+void
+BuffaloUps_ShutdownUps(void)
+{
+	int timeout = 15;
+	int i = 0;
+
+	if (OmronShutdownEnable == 1) {
+#if 0	/* XXX: TODO */
+		/*
+		 * sireal driver is refactored in newer kernel,
+		 * we can't access uart_ports[] structure.
+		 * need to re-implement mctrl setting procedure.
+		 */
+		unsigned int mctrl = uart_ports[UPSPORT]->ops->get_mctrl(uart_ports[UPSPORT]);
+		printk("Shuttting down OMRON ups ... \n");
+
+#if defined(CONFIG_ARCH_FEROCEON_KW) || defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+		mctrl &= ~TIOCM_DTR;	// ARMTIOCM_DTR
+#else //ARMADA_XP
+		mctrl |= TIOCM_DTR;
+#endif
+		uart_ports[UPSPORT]->ops->set_mctrl(uart_ports[UPSPORT], mctrl);
+#endif	/* XXX */
+		while (timeout) {
+			for (i = 0; i < 1000; i++) {
+				udelay(1000);
+			}
+			timeout--;
+		}
+		if(timeout == 0)
+			printk("Failed?\n");
+	}
+}
+#endif	/* CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN */
+
+//--------------------------------------------------------------
+/*
+ * Initialize driver.
+ */
+int __init
+BuffaloUpsdrv_init (void)
+{
+	printk("UPSDRV (C) BUFFALO INC. V.1.10 installed.\n"); 
+	
+	proc_buffalo_ups = proc_mkdir("buffalo/ups", 0);
+
+#ifdef CONFIG_BUFFALO_SUPPORT_UPS_RECOVER
+	BuffaloUpsRecoverInit();
+	proc_create("ups_recover", S_IRUGO|S_IWUSR, proc_buffalo_ups,
+		    &buffalo_ups_recover_fops);
+#endif	/* CONFIG_BUFFALO_SUPPORT_UPS_RECOVER */
+
+#ifdef CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+	proc_create("omron_shutdown_enable", S_IRUGO|S_IWUSR, proc_buffalo_ups,
+		    &buffalo_ups_omron_shutdown_enable_fops);
+	printk("  OMRON contact type ups shutdown support enabled!\n");
+#endif	/* CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN */
+
+	return 0;
+}
+
+//--------------------------------------------------------------
+void
+BuffaloUpsdrv_exit(void)
+{
+	printk("UPSDRV removed.");
+
+#ifdef CONFIG_BUFFALO_SUPPORT_UPS_RECOVER
+	remove_proc_entry("ups_recover", proc_buffalo_ups);
+	proc_buffalo_ups = NULL;
+#endif	/* CONFIG_BUFFALO_SUPPORT_UPS_RECOVER */
+
+#ifdef CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+	remove_proc_entry("omron_shutdown_enable", proc_buffalo_ups);
+#endif	/* CONFIG_BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN */
+
+	proc_buffalo_ups = NULL;
+	remove_proc_entry("buffalo/ups", 0);
+}
+
+module_init(BuffaloUpsdrv_init);
+module_exit(BuffaloUpsdrv_exit);
+MODULE_LICENSE("GPL");
diff --git a/buffalo/include/buffalo/kernevnt.h b/buffalo/include/buffalo/kernevnt.h
new file mode 100644
index 00000000..547e4a8
--- /dev/null
+++ b/buffalo/include/buffalo/kernevnt.h
@@ -0,0 +1,75 @@
+#ifndef _KERNEVNT_H_
+#define _KERNEVNT_H_
+
+// variable definition.
+#define POWER_STATUS_REBOOTING                  1
+#define POWER_STATUS_REBOOTING_UBOOT_PASSED     2
+#define POWER_STATUS_NORMAL_STATE               3
+#define POWER_STATUS_HW_POWER_OFF               4
+#define POWER_STATUS_SW_POWER_OFF               5
+#define POWER_STATUS_SW_POFF_UBOOT_PASSED       6
+#define POWER_STATUS_FWUPDATING                 7
+#define POWER_STATUS_REBOOT_REACHED_HALT        8
+#define	POWER_STATUS_SW_POFF_REACHED_HALT       9
+#define POWER_STATUS_UPS_SHUTDOWN		10
+#define POWER_STATUS_UPS_SHUTDOWN_REACHED_HALT	11
+#define POWER_STATUS_WOL_READY_STATE		12
+#define POWER_STATUS_WOL_READY_UBOOT_PASSED	13
+
+// difinition for MagicKey.
+// DEF4CPU = (CONFIG_ARCH_FEROCEON_MV78XX0, CONFIG_ARCH_ARMADA_XP, other)
+
+#if defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+#define DEF4CPU(x,y,z)  x
+#elif defined(CONFIG_ARCH_ARMADA_XP)
+#define DEF4CPU(x,y,z)  y
+#else
+#define DEF4CPU(x,y,z)  z
+#endif
+
+#define MagicKeyReboot                  0x18
+#define MagicKeyRebootUbootPassed       0x3a
+#define MagicKeyNormalState             0x71
+#define MagicKeyHwPoff                  0x43
+#define MagicKeySwPoff                  DEF4CPU(0x02,	0x41,	0x02)
+#define MagicKeySWPoffUbootPassed       0x5c
+#define MagicKeyFWUpdating              0x6f
+#define MagicKeyRebootReachedHalt       0x2b
+#define MagicKeySWPoffReachedHalt       0x7a
+#define MagicKeyUpsShutdown             DEF4CPU(0x45,   0x21,   0x21)
+#define MagicKeyUpsShutdownReachedHalt  DEF4CPU(0x16,   0x32,   0x32)
+#define MagicKeyWOLReadyState           DEF4CPU(0x75,   0x02,   0x75)
+#define MagicKeyWOLReadyUbootPasswd	0x70
+
+#define MagicKeyTerminator		0x00	/* use as terminator in defs,
+						 * it must not conflict
+						 * with meaningful values
+						 */
+
+/* routines are in buffalo/drivers/kernevnt.c */
+void kernevnt_LanAct(void *data);
+void kernevnt_LanAct_params(char *name, int speed, int duplex);
+void kernevnt_SwitchHubAct(const char *msg);
+#ifdef CONFIG_MD
+void kernevnt_RaidRecovery(int devno,int on, int isRecovery, int major, int minor);
+void kernevnt_RaidScan(int devno, int on);
+void kernevnt_RaidDegraded(int devno, int major, int minor);
+void kernevnt_RaidReshape(int devno, int on);
+#endif
+
+struct buffalo_cpu_status_defs {
+	unsigned int stat;
+	char *str;
+};
+
+void kernevnt_IOErr(const char *kdevname, const char *dir, unsigned long long sector, unsigned int errcnt);
+void kernevnt_FlashUpdate(int on);
+void kernevnt_DriveDead(const char *drvname);
+void kernevnt_I2cErr(void);
+void kernevnt_MiconInt(void);
+void kernevnt_EnetOverload(const char *name);
+void buffalo_kernevnt_queuein(const char *cmd);
+
+extern void (*kernevnt_LanAct_arch)(void *data);
+
+#endif
diff --git a/buffalo/include/buffalo/micon_v3.h b/buffalo/include/buffalo/micon_v3.h
new file mode 100644
index 00000000..90f3b2e
--- /dev/null
+++ b/buffalo/include/buffalo/micon_v3.h
@@ -0,0 +1,11 @@
+/*
+ *
+ */
+
+#ifndef __BUFFALO_MICON_V3_H__
+#define __BUFFALO_MICON_V3_H__
+
+extern void miconCntl_PowerOff(void);
+extern void miconCntl_Reboot(void);
+
+#endif	/* __BUFFALO_MICON_V3_H__ */
diff --git a/buffalo/scripts/debianize.sh b/buffalo/scripts/debianize.sh
new file mode 100755
index 00000000..7973398
--- /dev/null
+++ b/buffalo/scripts/debianize.sh
@@ -0,0 +1,399 @@
+#!/bin/bash
+#
+export LANGUAGE=C
+export LC_ALL=C
+
+# force fixup kernel build user/host, default:"root@buffalo.jp"
+#
+: ${KBUILD_BUILD_USER:="root"}
+: ${KBUILD_BUILD_HOST:="buffalo.jp"}
+export KBUILD_BUILD_USER KBUILD_BUILD_HOST
+
+# kernel version dependent settings:
+#
+: ${KERNELVERSION:="4.9.119"}
+: ${UBUNTUCORE_NAME:="v${KERNELVERSION}"}
+: ${UBUNTUCORE_URL:="http://kernel.ubuntu.com/~kernel-ppa/mainline/${UBUNTUCORE_NAME}"}
+:
+UBUNTU_PATCHES='
+	0001-base-packaging.patch
+	0002-UBUNTU-SAUCE-add-vmlinux.strip-to-BOOT_TARGETS1-on-p.patch
+	0003-UBUNTU-SAUCE-tools-hv-lsvmbus-add-manual-page.patch
+	0004-adhoc-from-__future__-import-syncconfig.patch
+	0005-UBUNTU-SAUCE-no-up-disable-pie-when-gcc-has-it-enabl.patch
+	0006-dh_builddeb-switch-to-Zgzip-to-avoid-dpkg-bug-on-lar.patch
+	0007-debian-changelog.patch
+	0008-configs-based-on-Ubuntu-4.9.0-11.12.patch
+'
+: ${ENABLE_UBUNTU_PATCHES:=1}
+
+# target architecutre/machine dependent settings:
+#
+: ${ARCH:="arm64"}
+: ${SRCARCH:="arm64"}
+: ${MACHINE:="buffalo_ls700"}
+: ${DTSNAMES:="rtd-1619-nas-mjolnir-2GB.dts"}
+: ${FLAVOUR:="generic"}
+: ${FLAVOUR_SUPPORTED:="Generic"}
+: ${GCCNAME:="gcc-7"}
+: ${GCCPREFIX:="/usr/bin/aarch64-linux-gnu-"}
+: ${DEFCONFIG:="buffalo/arch/${ARCH}/configs/${MACHINE}_defconfig"}
+: ${PACKAGE_ARCHIVE:="kernel_ls700_with_buffalo"}
+: ${KERNEL_DTSDIR:="arch/${ARCH}/boot/dts/realtek/"}
+: ${EXTRA_DTSDIR:="buffalo/arch/${ARCH}/boot/dts/"}
+
+fetch_ubuntu_patch () {
+	[ ${ENABLE_UBUNTU_PATCHES} -ne 1 ] && return 0
+	curl -OL ${UBUNTUCORE_URL}/$1 || exit 1
+}
+
+apply_ubuntu_patch () {
+	[ ${ENABLE_UBUNTU_PATCHES} -ne 1 ] && return 0
+
+	rm -rf debian debian.master
+	for file in ${UBUNTU_PATCHES}; do
+		[ -f ${file} ] || fetch_ubuntu_patch $file
+		patch -p1 < $file || exit 1
+	done
+	chmod +x debian/rules
+	chmod -R u+x debian/scripts/*
+	fakeroot debian/rules clean
+}
+
+fixup_kernel_flavour () {
+	[ ${ENABLE_UBUNTU_PATCHES} -ne 1 ] && return 0
+
+	# create debian.master/control.d/vars.${FLAVOUR}
+	#
+	sed -e "s/^arch=.*/arch=\"${SRCARCH}\"/" \
+	    -e "s/^supported=.*/supported=\"${FLAVOUR_SUPPORTED}\"/" \
+	    debian.master/control.d/vars.$1 \
+	    > debian.master/control.d/vars.$2
+
+	# create debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+	#
+	cp debian.master/config/${SRCARCH}/config.flavour.$1 \
+	   debian.master/config/${SRCARCH}/config.flavour.$2
+
+	fakeroot debian/rules clean
+}
+
+fixup_buffalo_configs () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    [ -d debian.master ] || apply_ubuntu_patch
+
+	    # create new flavour based on 'generic', if needed.
+	    #
+	    [ -f debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR} ] \
+		|| fixup_kernel_flavour generic ${FLAVOUR}
+
+	    # merge machine dependent configs to flavour, except for
+	    # CONFIG_LOCALVERSION setting.
+	    #
+	    egrep -v '^CONFIG_LOCALVERSION' ${DEFCONFIG} \
+		>> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR} \
+		|| exit 1
+	else
+	    # copy defconfig for fixup_$SRCARCH_configs() and keeping original defconfig
+	    local defconfig="$(mktemp "${DEFCONFIG%_defconfig}_XXXX_defconfig")"
+	    trap "rm -f ${defconfig}" EXIT INT QUIT TERM
+	    cp "${DEFCONFIG}" "${defconfig}"
+	    DEFCONFIG="${defconfig}"
+	    echo '# CONFIG_LOCALVERSION_AUTO is not set' >>${DEFCONFIG}
+	    echo 'CONFIG_LOCALVERSION=""' >>${DEFCONFIG}
+	fi
+
+	fixup_ubuntu_configs || exit 1
+	fixup_${SRCARCH}_configs || true
+
+	for name in ${DTSNAMES}; do
+	    dts="$(basename $name .dts).dts"
+	    if [ -f "${EXTRA_DTSDIR}${dts}" ]; then
+		rm -f "${KERNEL_DTSDIR}${dts}"
+		cat "${EXTRA_DTSDIR}${dts}" > "${KERNEL_DTSDIR}${dts}" \
+		|| exit 1
+	    fi
+	done
+}
+
+# fixup configes drived from UBUNTU.
+#
+fixup_ubuntu_configs () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    # Subject: UBUNTU: [Config] CONFIG_ANDROID=n
+	    # Author: Tim Gardner <tim.gardner@canonical.com>
+	    # Date: 2013-10-07 13:54:56 (GMT)
+	    # commit: b50a787fbcd6f42e9c552b201e58953049ac4428
+	    # BugLink: http://bugs.launchpad.net/bugs/1235161
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_ANDROID is not set
+EOF
+	else
+	    true
+	fi
+}
+
+fixup_amd64_configs () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    # To disable asking configs in 'make menuconfig', append default
+	    # value to undefined configs.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_EXT2_FS_XATTR is not set
+EOF
+
+	    # for Low Level Debugging:
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_ALPINE_UART0=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_UART_PHYS=0xfd883000
+CONFIG_DEBUG_UART_VIRT=0xfd883000
+CONFIG_DEBUG_UART_8250_SHIFT=2
+CONFIG_DEBUG_UART_8250_WORD=y
+# CONFIG_DEBUG_UART_8250_FLOW_CONTROL is not set
+EOF
+
+	    # To fixup user/kernel vm-page split layout configuration
+	    # from 1/3 split (ubuntu original) to 2/2 split.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+EOF
+	else
+	    true
+	fi
+}
+
+fixup_armhf_configs () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    # To disable asking configs in 'make menuconfig', append default
+	    # value to undefined configs.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_ARM_PAGE_SIZE_64KB is not set
+CONFIG_ARM_PAGE_SIZE_32KB=y
+# CONFIG_ARM_PAGE_SIZE_4KB is not set
+# CONFIG_FUNC_REORDER is not set
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_AL_ETH_ALLOC_FRAG=y
+# CONFIG_AL_ETH_ALLOC_PAGE is not set
+# CONFIG_AL_ETH_ALLOC_SKB is not set
+# CONFIG_AL_TRACE is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_GPIO_AL_SGPO is not set
+# CONFIG_AL_TDM_TEST_MODULE is not set
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_CRYPTO_FIPS is not set
+EOF
+	    # disable non-Alpine ARM platforms:
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_AXXIA is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHMOBILE_MULTI is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+EOF
+
+	    # Avoiding compile failure with Ubuntu core configurations,
+	    # * CONFIG_DRM:
+	    #	compile failure in "drivers/gpu/drm".
+	    # * CONFIG_F2FS_FS
+	    #	ERROR: "__aeabi_uldivmod" undefined! in modules.
+	    # * CONFIG_FB
+	    #	ERROR: "__aeabi_uldivmod" undefined! in modules.
+	    # * CONFIG_STAGING
+	    #	ERROR: "__aeabi_uldivmod" undefined! in modules.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_DRM is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FB is not set
+# CONFIG_STAGING is not set
+EOF
+
+	    # for Low Level Debugging:
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_ALPINE_UART0=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_LL_UART_8250 is not set
+# CONFIG_DEBUG_LL_UART_PL01X is not set
+CONFIG_DEBUG_UART_PHYS=0xfd883000
+CONFIG_DEBUG_UART_VIRT=0xfd883000
+CONFIG_DEBUG_UART_8250_SHIFT=2
+CONFIG_DEBUG_UART_8250_WORD=y
+# CONFIG_DEBUG_UART_8250_FLOW_CONTROL is not set
+EOF
+
+	    # To fixup user/kernel vm-page split layout configuration
+	    # from 1/3 split (ubuntu original) to 2/2 split.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+EOF
+	else
+	    true
+	fi
+}
+
+fixup_arm64_configs () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    # To disable asking configs in 'make menuconfig', append default
+	    # value to undefined configs.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+EOF
+
+	    # Avoiding link error with Ubuntu core configurations.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+# CONFIG_SOUND is not set
+# CONFIG_XEN is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_RTK_SFC is not set
+# CONFIG_SFC is not set
+EOF
+
+	    # Avoiding link error with rtd16xx_lede_emmc_defconfig.
+	    #
+	    cat <<'EOF' >> debian.master/config/${SRCARCH}/config.flavour.${FLAVOUR}
+CONFIG_R8125=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_MD_MULTIPATH=y
+EOF
+
+	    # Disabling unused network device drivers
+	    #
+	    cat <<'EOF' >>"${DEFCONFIG}"
+# CONFIG_R8168 is not set
+EOF
+	else
+	    # Avoiding link error with rtd16xx_lede_emmc_defconfig.
+	    #
+	    cat <<'EOF' >>"${DEFCONFIG}"
+CONFIG_R8125=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_MD_MULTIPATH=y
+EOF
+
+	    # Avoiding runtime errors caused by XFS
+	    #
+	    cat <<'EOF' >>"${DEFCONFIG}"
+CONFIG_XFS_FS=m
+EOF
+
+	    # Disabling unused network device drivers
+	    #
+	    cat <<'EOF' >>"${DEFCONFIG}"
+# CONFIG_R8168 is not set
+EOF
+	fi
+}
+
+fixup_buffalo_rules () {
+	[ ${ENABLE_UBUNTU_PATCHES} -ne 1 ] && return 0
+
+	[ -d debian.master ] || apply_ubuntu_patch
+
+	sed -e "/^flavours/s/=.*/= ${FLAVOUR}/" \
+	    -e "/^gcc/s/=.*/= ${GCCNAME}/" \
+	    -i debian.master/rules.d/${SRCARCH}.mk
+	if ! egrep -q "^gcc\s+=.*" debian.master/rules.d/${SRCARCH}.mk; then
+		echo "gcc		= ${GCCNAME}" >> debian.master/rules.d/${SRCARCH}.mk
+	fi
+	for name in ${DTSNAMES}; do
+		dts="$(basename $name .dts)"
+		/bin/echo -e "dtb_files_${FLAVOUR}\t+= ${dts}.dtb" \
+		>> debian.master/rules.d/${SRCARCH}.mk
+	done
+}
+
+build_buffalo_packages () {
+	if [ ${ENABLE_UBUNTU_PATCHES} -eq 1 ]; then
+	    fakeroot debian/rules do_tools=0 no_dumpfile=1 binary-headers
+	    fakeroot debian/rules clean
+	    dpkg-architecture -a${SRCARCH} -c debian/rules \
+		do_extras_package=false do_tools=0 no_dumpfile=1 build-arch
+	    dpkg-architecture -a${SRCARCH} -c fakeroot debian/rules \
+		do_extras_package=false do_tools=0 no_dumpfile=1 binary-debs
+	else
+	    make -j $(nproc || echo 1) LOCALVERSION= localver-extra= KERNELVERSION=${KERNELVERSION}-0000000-${FLAVOUR} ARCH=${ARCH} CROSS_COMPILE="${GCCPREFIX}" O="$(pwd)/debian/build/" mrproper "$(basename ${DEFCONFIG})" deb-pkg
+	    rm -f "${DEFCONFIG}"
+	    trap '' EXIT INT QUIT TERM
+	    mv debian/linux-* ../
+	fi
+}
+
+TARGET_FILE=rtd-1619-sata.dtsi
+TARGET_PATH=./arch/arm64/boot/dts/realtek/rtd16xx/${TARGET_FILE}
+case ${TARGET_PLATFORM} in
+LS700)
+	if [ "${TARGET_MODEL}" = "" ]; then
+		TARGET_MODEL=LS720D
+	fi
+	cp "${TARGET_FILE}_${TARGET_MODEL}" "${TARGET_PATH}"
+	;;
+*)
+	echo "undefined PLATFORM. do nothing here."
+	;;
+esac
+
+fixup_buffalo_configs
+fixup_buffalo_rules
+build_buffalo_packages
+
+( cd ..; tar cvf ${PACKAGE_ARCHIVE}.tar linux-*.deb )
diff --git a/buffalo/scripts/mkbuilddate_h b/buffalo/scripts/mkbuilddate_h
new file mode 100644
index 00000000..c046309
--- /dev/null
+++ b/buffalo/scripts/mkbuilddate_h
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+TARGET=$1
+
+vecho() { [ "${quiet}" = "silent_" ] || echo "$@" ; }
+
+# Do not expand names
+set -f
+
+# Fix the language to get consistent output
+LC_ALL=C
+export LC_ALL
+
+vecho "  UPD     $TARGET"
+
+( echo /\* This file is auto generated \*/
+
+  date "+#define BUFFALO_BUILD_DATE \"%Y/%m/%d\"%n#define BUFFALO_BUILD_TIME \"%T\""
+
+) > $TARGET
+
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
index 90c3877..d9e4da7 100644
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@ -592,6 +592,9 @@ void ata_scsi_error(struct Scsi_Host *host)
 	struct ata_port *ap = ata_shost_to_port(host);
 	unsigned long flags;
 	LIST_HEAD(eh_work_q);
+#ifdef CONFIG_BUFFALO_PLATFORM
+	extern int buffalo_booting;
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	DPRINTK("ENTER\n");
 
@@ -605,6 +608,12 @@ void ata_scsi_error(struct Scsi_Host *host)
 	   recover nr_timedout == 0 why exactly are we doing error recovery ? */
 	ata_scsi_port_error_handler(host, ap);
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (!buffalo_booting) {
+		/* do nothing */
+	}
+	else
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* finish or retry handled scmd's and clean up */
 	WARN_ON(!list_empty(&eh_work_q));
 
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index f4195b4..8ae0538 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -29,7 +29,7 @@ obj-$(CONFIG_BT_QCA)		+= btqca.o
 btmrvl-y			:= btmrvl_main.o
 btmrvl-$(CONFIG_DEBUG_FS)	+= btmrvl_debugfs.o
 
-hci_uart-y				:= hci_ldisc.o hci_rtk_h5.o rtk_coex.o
+hci_uart-y				:= hci_ldisc.o
 hci_uart-$(CONFIG_BT_HCIUART_H4)	+= hci_h4.o
 hci_uart-$(CONFIG_BT_HCIUART_BCSP)	+= hci_bcsp.o
 hci_uart-$(CONFIG_BT_HCIUART_LL)	+= hci_ll.o
diff --git a/drivers/gpio/gpio-rtd16xx-suspend.c b/drivers/gpio/gpio-rtd16xx-suspend.c
index 549c143..21b13fb 100644
--- a/drivers/gpio/gpio-rtd16xx-suspend.c
+++ b/drivers/gpio/gpio-rtd16xx-suspend.c
@@ -137,7 +137,7 @@ static void rtk_gpio_init_wu(struct device_node *nd)
 				pr_err("[%s] wakeup-gpio[%d] Request failed! (en:%d act:%d gpio:%d)\n",
 					DEV_NAME, i, en, act, wu_gpio);
 			} else {
-				//gpio_free(wu_gpio);
+				gpio_free(wu_gpio);
 			}
 
 			gpio_direction_input(wu_gpio);
diff --git a/drivers/md/md.c b/drivers/md/md.c
index ff53829..462c644 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -55,6 +55,9 @@
 #include "md.h"
 #include "bitmap.h"
 #include "md-cluster.h"
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include <buffalo/kernevnt.h>
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
 
 #ifndef MODULE
 static void autostart_arrays(int part);
@@ -101,7 +104,17 @@ static int remove_and_add_spares(struct mddev *mddev,
  */
 
 static int sysctl_speed_limit_min = 1000;
+#ifdef CONFIG_BUFFALO_PLATFORM
+static int sysctl_speed_limit_max = 50000;
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+static int sysctl_skip_resync = 0;
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+static int sysctl_use_kernevnt = 1;
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
+#else	/* CONFIG_BUFFALO_PLATFORM */
 static int sysctl_speed_limit_max = 200000;
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 static inline int speed_min(struct mddev *mddev)
 {
 	return mddev->sync_speed_min ?
@@ -124,6 +137,24 @@ static inline int speed_max(struct mddev *mddev)
 		.mode		= S_IRUGO|S_IWUSR,
 		.proc_handler	= proc_dointvec,
 	},
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	{
+		.procname	= "skip_resync",
+		.data		= &sysctl_skip_resync,
+		.maxlen		= sizeof(int),
+		.mode		= S_IRUGO|S_IWUSR,
+		.proc_handler	= proc_dointvec,
+	},
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+	{
+		.procname	= "use_kernevnt",
+		.data		= &sysctl_use_kernevnt,
+		.maxlen		= sizeof(int),
+		.mode		= S_IRUGO|S_IWUSR,
+		.proc_handler	= proc_dointvec,
+	},
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
 	{
 		.procname	= "speed_limit_max",
 		.data		= &sysctl_speed_limit_max,
@@ -3781,6 +3812,55 @@ int strict_strtoul_scaled(const char *cp, unsigned long *res, int scale)
 static struct md_sysfs_entry md_chunk_size =
 __ATTR(chunk_size, S_IRUGO|S_IWUSR, chunk_size_show, chunk_size_store);
 
+#ifdef CONFIG_BUFFALO_ERRCNT
+static ssize_t
+maxerr_cnt_show(struct mddev *mddev, char *page)
+{
+	return sprintf(page, "%d\n", atomic_read(&mddev->maxerr_cnt));
+}
+
+static ssize_t
+maxerr_cnt_store(struct mddev *mddev, const char *buf, size_t len)
+{
+	char *e;
+	unsigned long n = simple_strtol(buf, &e, 10);
+
+	if (*buf &&
+	    (*e == 0 || *e == '\n') &&
+	    (n == -1 || (signed int)n >= 0)) {
+		atomic_set(&mddev->maxerr_cnt, n);
+		return len;
+	}
+	return -EINVAL;
+}
+static struct md_sysfs_entry md_maxerr_cnt =
+__ATTR(maxerr_cnt, S_IRUGO|S_IWUSR, maxerr_cnt_show, maxerr_cnt_store);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+static ssize_t
+skip_resync_show(struct mddev *mddev, char *page)
+{
+	return sprintf(page, "%d\n", atomic_read(&mddev->skip_resync));
+}
+static ssize_t
+skip_resync_store(struct mddev *mddev, const char *buf, size_t len)
+{
+	char *e;
+	unsigned long n = simple_strtol(buf, &e, 10);
+
+	if (*buf &&
+	    (*e == 0 || *e == '\n') &&
+	    (n == 1 || n == 0)) {
+		atomic_set(&mddev->skip_resync, n);
+		return len;
+	}
+	return -EINVAL;
+}
+static struct md_sysfs_entry md_skip_resync =
+__ATTR(skip_resync, S_IRUGO|S_IWUSR, skip_resync_show, skip_resync_store);
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+
 static ssize_t
 resync_start_show(struct mddev *mddev, char *page)
 {
@@ -4866,6 +4946,12 @@ static int match_word(const char *word, char **list)
 static struct attribute *md_default_attrs[] = {
 	&md_level.attr,
 	&md_layout.attr,
+#ifdef CONFIG_BUFFALO_ERRCNT
+	&md_maxerr_cnt.attr,
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	&md_skip_resync.attr,
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 	&md_raid_disks.attr,
 	&md_chunk_size.attr,
 	&md_size.attr,
@@ -4989,6 +5075,15 @@ static void mddev_delayed_delete(struct work_struct *ws)
 
 static int md_alloc(dev_t dev, char *name)
 {
+	/*
+	 * If dev is zero, name is the name of a device to allocate with
+	 * an arbitrary minor number.  It will be "md_???"
+	 * If dev is non-zero it must be a device number with a MAJOR of
+	 * MD_MAJOR or mdp_major.  In this case, if "name" is NULL, then
+	 * the device is being created by opening a node in /dev.
+	 * If "name" is not NULL, the device is being created by
+	 * writing to /sys/module/md_mod/parameters/new_array.
+	 */
 	static DEFINE_MUTEX(disks_mutex);
 	struct mddev *mddev = mddev_find(dev);
 	struct gendisk *disk;
@@ -5014,7 +5109,7 @@ static int md_alloc(dev_t dev, char *name)
 	if (mddev->gendisk)
 		goto abort;
 
-	if (name) {
+	if (name && !dev) {
 		/* Need to ensure that 'name' is not a duplicate.
 		 */
 		struct mddev *mddev2;
@@ -5028,6 +5123,11 @@ static int md_alloc(dev_t dev, char *name)
 			}
 		spin_unlock(&all_mddevs_lock);
 	}
+	if (name && dev)
+		/*
+		 * Creating /dev/mdNNN via "newarray", so adjust hold_active.
+		 */
+		mddev->hold_active = UNTIL_STOP;
 
 	error = -ENOMEM;
 	mddev->queue = blk_alloc_queue(GFP_KERNEL);
@@ -5100,21 +5200,31 @@ static struct kobject *md_probe(dev_t dev, int *part, void *data)
 
 static int add_named_array(const char *val, const struct kernel_param *kp)
 {
-	/* val must be "md_*" where * is not all digits.
-	 * We allocate an array with a large free minor number, and
+	/*
+	 * val must be "md_*" or "mdNNN".
+	 * For "md_*" we allocate an array with a large free minor number, and
 	 * set the name to val.  val must not already be an active name.
+	 * For "mdNNN" we allocate an array with the minor number NNN
+	 * which must not already be in use.
 	 */
 	int len = strlen(val);
 	char buf[DISK_NAME_LEN];
+	unsigned long devnum;
 
 	while (len && val[len-1] == '\n')
 		len--;
 	if (len >= DISK_NAME_LEN)
 		return -E2BIG;
 	strlcpy(buf, val, len+1);
-	if (strncmp(buf, "md_", 3) != 0)
-		return -EINVAL;
-	return md_alloc(0, buf);
+	if (strncmp(buf, "md_", 3) == 0)
+		return md_alloc(0, buf);
+	if (strncmp(buf, "md", 2) == 0 &&
+	    isdigit(buf[2]) &&
+	    kstrtoul(buf+2, 10, &devnum) == 0 &&
+	    devnum <= MINORMASK)
+		return md_alloc(MKDEV(MD_MAJOR, devnum), NULL);
+
+	return -EINVAL;
 }
 
 static void md_safemode_timeout(unsigned long data)
@@ -5356,6 +5466,12 @@ int md_run(struct mddev *mddev)
 	if (mddev->flags & MD_UPDATE_SB_FLAGS)
 		md_update_sb(mddev, 0);
 
+#ifdef CONFIG_BUFFALO_ERRCNT
+	atomic_set(&mddev->maxerr_cnt, MAXERR_CNT_DEFAULT);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	atomic_set(&mddev->skip_resync, 0);
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 	md_new_event(mddev);
 	sysfs_notify_dirent_safe(mddev->sysfs_state);
 	sysfs_notify_dirent_safe(mddev->sysfs_action);
@@ -7255,6 +7371,12 @@ void md_error(struct mddev *mddev, struct md_rdev *rdev)
 	if (!rdev || test_bit(Faulty, &rdev->flags))
 		return;
 
+#ifdef CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT
+	if (sysctl_use_kernevnt)
+		kernevnt_RaidDegraded(mddev->md_minor,
+				      MAJOR(rdev->bdev->bd_dev),
+				      MINOR(rdev->bdev->bd_dev));
+#endif	/* CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT */
 	if (!mddev->pers || !mddev->pers->error_handler)
 		return;
 	mddev->pers->error_handler(mddev,rdev);
@@ -7840,7 +7962,13 @@ void md_do_sync(struct md_thread *thread)
 	char *desc, *action = NULL;
 	struct blk_plug plug;
 	int ret;
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	int isRecovery, major=0, minor=0;
+#endif /* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	set_user_nice(current, 4);
+#endif /* CONFIG_BUFFALO_PLATFORM */
 	/* just incase thread restarts... */
 	if (test_bit(MD_RECOVERY_DONE, &mddev->recovery))
 		return;
@@ -7872,6 +8000,12 @@ void md_do_sync(struct md_thread *thread)
 			action = "repair";
 		} else
 			desc = "resync";
+#ifdef CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT
+		if (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_CHECK, &mddev->recovery))
+			kernevnt_RaidScan(mddev->md_minor, 1);
+#endif	/* CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT */
 	} else if (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))
 		desc = "reshape";
 	else
@@ -7988,6 +8122,30 @@ void md_do_sync(struct md_thread *thread)
 			mddev->pers->quiesce(mddev, 0);
 		}
 	}
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	if (sysctl_use_kernevnt) {
+		if((test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) ||
+		   (!test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_RECOVER, &mddev->recovery))) {
+			struct md_rdev *rdev_tmp;
+			list_for_each_entry(rdev_tmp, &mddev->disks, same_set){
+				if (rdev_tmp->flags != In_sync) {
+					major = MAJOR(rdev_tmp->bdev->bd_dev);
+					minor = MINOR(rdev_tmp->bdev->bd_dev);
+					break;
+				}
+			}
+			isRecovery = !test_bit(MD_RECOVERY_SYNC,
+					       &mddev->recovery);
+			kernevnt_RaidRecovery(mddev->md_minor, 1,
+					      isRecovery, major, minor);
+		}
+		else if ((test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))) {
+			kernevnt_RaidReshape(mddev->md_minor, 1);
+		}
+	}
+#endif	/* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
 
 	printk(KERN_INFO "md: %s of RAID array %s\n", desc, mdname(mddev));
 	printk(KERN_INFO "md: minimum _guaranteed_  speed:"
@@ -8033,6 +8191,12 @@ void md_do_sync(struct md_thread *thread)
 	while (j < max_sectors) {
 		sector_t sectors;
 
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+		if (sysctl_skip_resync || atomic_read(&mddev->skip_resync)) {
+			mddev->curr_resync = max_sectors;
+			break;
+		}
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 		skipped = 0;
 
 		if (!test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&
@@ -8155,6 +8319,20 @@ void md_do_sync(struct md_thread *thread)
 	 */
 	blk_finish_plug(&plug);
 	wait_event(mddev->recovery_wait, !atomic_read(&mddev->recovery_active));
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	if (sysctl_use_kernevnt) {
+		if((test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) ||
+		   (!test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_RECOVER, &mddev->recovery)))
+			kernevnt_RaidRecovery(mddev->md_minor, 0,
+					      isRecovery, major, minor);
+                else if((test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))) {
+			printk("RaidReshape(mddev->md_minor, 0)\n");
+			kernevnt_RaidReshape(mddev->md_minor, 0);
+		}
+	}
+#endif	/* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
 
 	if (!test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&
 	    !test_bit(MD_RECOVERY_INTR, &mddev->recovery) &&
@@ -8228,6 +8406,12 @@ void md_do_sync(struct md_thread *thread)
 	set_bit(MD_RECOVERY_DONE, &mddev->recovery);
 	mddev->curr_resync = 0;
 	spin_unlock(&mddev->lock);
+#ifdef CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT
+	if (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+	    test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&
+	    !test_bit(MD_RECOVERY_CHECK, &mddev->recovery))
+		kernevnt_RaidScan(mddev->md_minor, 0);
+#endif /* CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT */
 
 	wake_up(&resync_wait);
 	md_wakeup_thread(mddev->thread);
diff --git a/drivers/md/md.h b/drivers/md/md.h
index 2b20417..33f2c7d 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -440,6 +440,18 @@ struct mddev {
 	void (*sync_super)(struct mddev *mddev, struct md_rdev *rdev);
 	struct md_cluster_info		*cluster_info;
 	unsigned int			good_device_nr;	/* good device num within cluster raid */
+#ifdef CONFIG_BUFFALO_ERRCNT
+#define MAXERR_CNT_DEFAULT		1000
+	atomic_t			maxerr_cnt; /* If rdev->bdev->bd_disk->
+						     * nr_err reaches to
+						     * maxerr_cnt (excepting
+						     * maxerr_cnt is -1),
+						     * disk will be faulty.
+						     */
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	atomic_t			skip_resync;
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 };
 
 static inline int __must_check mddev_lock(struct mddev *mddev)
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 9981026..a47bf98 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -317,11 +317,29 @@ static void raid1_end_read_request(struct bio *bio)
 	struct r1bio *r1_bio = bio->bi_private;
 	struct r1conf *conf = r1_bio->mddev->private;
 	struct md_rdev *rdev = conf->mirrors[r1_bio->read_disk].rdev;
+#ifdef CONFIG_BUFFALO_ERRCNT
+	struct md_rdev *rdev2;
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 
 	/*
 	 * this branch is our 'one mirror IO has finished' event handler:
 	 */
 	update_head_pos(r1_bio->read_disk, r1_bio);
+#ifdef CONFIG_BUFFALO_ERRCNT
+	rcu_read_lock();
+	rdev2 = rcu_dereference(conf->mirrors[r1_bio->read_disk].rdev);
+	if (rdev2 != NULL) {
+		int maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+
+		if (atomic_read(&rdev2->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			if (conf->raid_disks - r1_bio->mddev->degraded != 1) {
+				rcu_read_unlock();
+				goto do_degrade;
+			}
+	}
+	rcu_read_unlock();
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 
 	if (uptodate)
 		set_bit(R1BIO_Uptodate, &r1_bio->state);
@@ -347,6 +365,9 @@ static void raid1_end_read_request(struct bio *bio)
 		 * oops, read error:
 		 */
 		char b[BDEVNAME_SIZE];
+#ifdef CONFIG_BUFFALO_ERRCNT
+do_degrade:
+#endif /* CONFIG_BUFFALO_ERRCNT */
 		printk_ratelimited(
 			KERN_ERR "md/raid1:%s: %s: "
 			"rescheduling sector %llu\n",
@@ -2013,6 +2034,23 @@ static void sync_request_write(struct mddev *mddev, struct r1bio *r1_bio)
 
 	if (test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery))
 		process_checks(r1_bio);
+#ifdef CONFIG_BUFFALO_ERRCNT
+	rcu_read_lock();
+	for (i = 0; i < mddev->raid_disks; i++) {
+		struct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);
+		int maxerr_cnt = atomic_read(&mddev->maxerr_cnt);
+
+		if (r1_bio->bios[i]->bi_end_io != end_sync_read ||
+		    rdev == NULL)
+			continue;
+
+		if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			if (!test_bit(Faulty, &conf->mirrors[i].rdev->flags))
+				md_error(mddev, conf->mirrors[i].rdev);
+	}
+	rcu_read_unlock();
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 
 	/*
 	 * schedule writes
@@ -2321,6 +2359,16 @@ static void handle_read_error(struct r1conf *conf, struct r1bio *r1_bio)
 		freeze_array(conf, 1);
 		fix_read_error(conf, r1_bio->read_disk,
 			       r1_bio->sector, r1_bio->sectors);
+#ifdef CONFIG_BUFFALO_ERRCNT
+		rdev = conf->mirrors[r1_bio->read_disk].rdev;
+		if (rdev != NULL) {
+			int maxerr_cnt =
+				atomic_read(&mddev->maxerr_cnt);
+			if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+			    maxerr_cnt != -1)
+				md_error(mddev, rdev);
+		}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		unfreeze_array(conf);
 	} else {
 		r1_bio->bios[r1_bio->read_disk] = IO_BLOCKED;
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index e43b9f8..af95083 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2322,6 +2322,9 @@ static void raid5_end_read_request(struct bio * bi)
 	char b[BDEVNAME_SIZE];
 	struct md_rdev *rdev = NULL;
 	sector_t s;
+#ifdef CONFIG_BUFFALO_ERRCNT
+	int error = bi->bi_error;
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 
 	for (i=0 ; i<disks; i++)
 		if (bi == &sh->dev[i].req)
@@ -2349,7 +2352,22 @@ static void raid5_end_read_request(struct bio * bi)
 		s = sh->sector + rdev->new_data_offset;
 	else
 		s = sh->sector + rdev->data_offset;
+#ifdef CONFIG_BUFFALO_ERRCNT
+	if (!(conf->mddev->degraded)) {
+		int maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+
+		rdev = conf->disks[i].rdev;
+		if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			if (!error)
+				error = -EIO;
+	}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_ERRCNT
+	if (!error) {
+#else	/* CONFIG_BUFFALO_ERRCNT */
 	if (!bi->bi_error) {
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		set_bit(R5_UPTODATE, &sh->dev[i].flags);
 		if (test_bit(R5_ReadError, &sh->dev[i].flags)) {
 			/* Note that this cannot happen on a
@@ -2415,12 +2433,38 @@ static void raid5_end_read_request(struct bio * bi)
 		if (set_bad && test_bit(In_sync, &rdev->flags)
 		    && !test_bit(R5_ReadNoMerge, &sh->dev[i].flags))
 			retry = 1;
+#ifdef CONFIG_BUFFALO_ERRCNT
+		if (retry) {
+			int maxerr_cnt;
+
+			if (test_bit(R5_ReadNoMerge, &sh->dev[i].flags)) {
+				set_bit(R5_ReadError, &sh->dev[i].flags);
+				clear_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+			} else
+				set_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+
+			printk("debug: Read Error dev[%d]: sector %llu(sh->sector=%llu)\n",
+			       i, (unsigned long long)sh->dev[i].sector,
+			       (unsigned long long)sh->sector);
+			/*
+			 * Don't forget the bracket {} put in the outside of
+			 * this macro, if you port this code to another
+			 * version of Linux.
+			 */
+			maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+			rdev = conf->disks[i].rdev;
+			if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+			    maxerr_cnt != -1)
+				md_error(conf->mddev, conf->disks[i].rdev);
+		}
+#else	/* CONFIG_BUFFALO_ERRCNT */
 		if (retry)
 			if (test_bit(R5_ReadNoMerge, &sh->dev[i].flags)) {
 				set_bit(R5_ReadError, &sh->dev[i].flags);
 				clear_bit(R5_ReadNoMerge, &sh->dev[i].flags);
 			} else
 				set_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		else {
 			clear_bit(R5_ReadError, &sh->dev[i].flags);
 			clear_bit(R5_ReWrite, &sh->dev[i].flags);
diff --git a/drivers/mtd/nand/rtk_nand.c b/drivers/mtd/nand/rtk_nand.c
index 39f11b3..bb75732 100644
--- a/drivers/mtd/nand/rtk_nand.c
+++ b/drivers/mtd/nand/rtk_nand.c
@@ -901,7 +901,7 @@ static int rtk_nand_profile (void)
 	rc = parse_mtd_partitions (rtk_mtd, ptypes, &mtd_parts, 0);
 	pnum = mtd_parts.nr_parts;
 #else
-	rc = mtd_device_parse_register(rtk_mtd, ptypes, 0, &mtd_parts, 0);
+	rc = mtd_device_parse_register(rtk_mtd, ptypes, 0, mtd_parts.parts, 0);
 	NF_INFO_PRINT("[%s] mtd_device_parse_register rc = 0x%x\n", __FUNCTION__, rc);
 #endif
 
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 8cc7467..9a0e778 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -180,4 +180,6 @@ source "drivers/net/ethernet/wiznet/Kconfig"
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 
+source "drivers/net/ethernet/aquantia/Kconfig"
+
 endif # ETHERNET
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index a09423d..4eb5211 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -89,3 +89,4 @@ obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_AQTION) += aquantia/
diff --git a/drivers/net/ethernet/aquantia/Kconfig b/drivers/net/ethernet/aquantia/Kconfig
new file mode 100644
index 00000000..5edc4ef
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/Kconfig
@@ -0,0 +1,9 @@
+#
+# aQuantia device configuration
+#
+
+config AQTION
+	tristate "aQuantia AQtion(tm) Support"
+	depends on PCI
+	---help---
+	  This enables the support for the aQuantia AQtion(tm) Ethernet card.
diff --git a/drivers/net/ethernet/aquantia/Makefile b/drivers/net/ethernet/aquantia/Makefile
new file mode 100644
index 00000000..f6e9adb
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/Makefile
@@ -0,0 +1,86 @@
+################################################################################
+#
+# aQuantia Ethernet Controller AQtion Linux Driver
+# Copyright(c) 2014-2017 aQuantia Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+# Contact Information: <rdc-drv@aquantia.com>
+# aQuantia Corporation, 105 E. Tasman Dr. San Jose, CA 95134, USA
+#
+################################################################################
+
+#
+# Makefile for the AQtion(tm) Ethernet driver
+#
+
+
+TARGET := atlantic
+
+CC = gcc
+
+ifeq "$(CC)" "gcc"
+	ccflags-y := -Wall
+endif
+
+ifeq "$(CC)" "clang-3.5"
+	ccflags-y := -Wno-date-time -W --system-header-prefix=linux/ \
+	-fsanitize=integer,address,undefined,alignment,bool,bounds,null,\
+	enum,integer-divide-by-zero,shift,unreachable,unsigned-integer-overflow
+endif
+
+ifneq ($(KERNELRELEASE),)
+	$(TARGET)-objs:=aq_main.o aq_nic.o aq_pci_func.o aq_nic.o aq_vec.o aq_ring.o \
+	aq_hw_utils.o aq_ethtool.o aq_drvinfo.o hw_atl/hw_atl_a0.o hw_atl/hw_atl_b0.o hw_atl/hw_atl_utils.o\
+	hw_atl/hw_atl_utils_fw2x.o \
+	hw_atl/hw_atl_llh.o
+
+	obj-$(CONFIG_AQTION):=$(TARGET).o
+else
+	ifndef KDIR
+		BUILD_DIR:=/lib/modules/$(shell uname -r)/build
+	else
+		BUILD_DIR:=$(KDIR)
+	endif
+
+	PWD:=$(shell pwd)
+
+all:
+	$(MAKE) -j4 CC=$(CC) -C $(BUILD_DIR) M=$(PWD) modules
+
+dox:	.doxygen
+	@doxygen $<
+
+clean:
+	$(MAKE) -j4 -C $(BUILD_DIR) M=$(PWD) clean
+	@-rm -rdf doc/html 2 > /dev/null
+
+load:
+	insmod ./$(TARGET).ko
+
+unload:
+	rmmod ./$(TARGET).ko
+
+install:
+	@install -D -m 644 ${TARGET}.ko /lib/modules/$(shell uname -r)/aquantia/${TARGET}.ko
+	@depmod -a $(shell uname -r)
+
+uninstall:
+	@rm -f /lib/modules/$(shell uname -r)/aquantia/${TARGET}.ko
+	@depmod -a $(shell uname -r)
+
+endif
+
diff --git a/drivers/net/ethernet/aquantia/README.txt b/drivers/net/ethernet/aquantia/README.txt
new file mode 100644
index 00000000..2f4cdc6
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/README.txt
@@ -0,0 +1,464 @@
+Linux* aQuantia AQtion Driver for the aQuantia Multi-Gigabit PCI Express Family of
+Ethernet Adapters
+=============================================================================
+
+Contents
+========
+
+- Important Note
+- In This Release
+- Identifying Your Adapter
+- Building and Installation
+- Command Line Parameters
+- Additional Configurations
+- Support
+
+IMPORTANT NOTE
+==============
+
+WARNING:  The AQtion driver compiles by default with the LRO (Large Receive
+Offload) feature enabled.  This option offers the lowest CPU utilization for
+receives, but is completely incompatible with *routing/ip forwarding* and
+*bridging*.  If enabling ip forwarding or bridging is a requirement, it is
+necessary to disable LRO using compile time options as noted in the LRO
+section later in this document.  The result of not disabling LRO when combined
+with ip forwarding or bridging can be low throughput or even a kernel panic.
+
+In This Release
+===============
+
+This file describes the aQuantia AQtion Driver for the aQuantia Multi-Gigabit PCI Express Family of
+Ethernet Adapters.  This driver supports the linux kernels >= 3.10, 
+and includes support for x86_64 and ARM Linux system.
+
+This release contains source tarball and (optional) src.rpm package.
+
+Identifying Your Adapter
+========================
+
+The driver in this release is compatible with AQC-100, AQC-107, AQC-108 based ethernet adapters.
+
+
+SFP+ Devices (for AQC-100 based adapters)
+----------------------------------
+
+This release tested with passive Direct Attach Cables (DAC) and SFP+/LC Optical Transceiver.
+
+Building and Installation
+=========================
+
+To manually build this driver:
+------------------------------------------------------------
+1. Make sure you have all the environment to build standalone kernel module.
+   On debian based systems you may do the following:
+
+	sudo apt install linux-headers build-essential
+
+2. Move the base driver tar file to the directory of your choice. For example,
+   use /home/username/aquantia.
+   Untar/unzip archive:
+
+	cd ~/aquantia
+	tar zxf Aquantia-AQtion-x.y.z.tar.gz
+
+3. Change to the driver src directory:
+
+	cd Aquantia-AQtion-x.y.z/
+
+4. Compile the driver module:
+	make
+
+5. Load the module:
+	sudo insmod atlantic.ko
+
+6. Unload the driver
+	sudo rmmod atlantic
+
+7. Install the driver in the system
+	make && make install
+
+driver will be in:
+
+	/lib/modules/`uname -r`/aquantia/atlantic.ko
+
+8. Uninstall the driver:
+	make uninstall
+or run the following commands:
+	sudo rm -f /lib/modules/`uname -r`/aquantia/atlantic.ko
+	depmod -a `uname -r`
+
+Alternatively build and install driver with dkms
+------------------------------------------------------------
+1. Make sure you have all the environment to build standalone kernel module.
+   On debian based systems you may do the following:
+
+	sudo apt-get install linux-headers-`uname -r` build-essential gawk dkms
+
+   On redhat based systems you may do the following:
+
+	sudo yum install kernel-devel-`uname -r` gcc gcc-c++ make gawk dkms
+
+2. Move the base driver tar file to the directory of your choice. For example,
+   use /home/username/aquantia.
+   Untar/unzip archive:
+
+	cd ~/aquantia
+	tar zxf Aquantia-AQtion-x.y.z.tar.gz
+
+3. Change to the driver source directory:
+
+	cd Aquantia-AQtion-x.y.z/
+
+4. Build and install driver:
+
+	sudo ./dkms.sh install
+
+driver will be in:
+
+	/lib/modules/`uname -r`/updates/dkms/atlantic.ko
+
+5. Uninstall the driver:
+
+	sudo ./dkms.sh uninstall
+
+Alternatively you can use Aquantia-AQtion-x.y.z.src.rpm
+------------------------------------------------------------
+1. Move the Aquantia-AQtion-x.y.z.src.rpm file to the directory of your choice. For example,
+   use /home/username/aquantia.
+
+2. Execute the commands:
+    cd /home/username/aquantia
+    sudo rpm -ivh Aquantia-AQtion-x.y.z.x86_64.rpm
+	
+    After this driver will be installed.
+    (You can check this via "rpm -qa | grep Aquantia")
+
+3. Uninstall the driver:
+   Run the following commands:
+   sudo rpm -e Aquantia-AQtion-x.y.z.x86_64
+
+Check that the driver is working
+------------------------------------------------------------
+	
+1. Verify ethernet interface appears:
+	ifconfig
+	or
+	ip addr show
+	
+	If no new interface appears, check dmesg output.
+	If you see "Bad firmware detected" please update firmware on your ethernet card.
+
+2. Assign an IP address to the interface by entering the following, where
+   x is the interface number:
+
+	ifconfig ethX <IP_address> netmask <netmask>
+    or
+	ip addr add <IP_address> dev <DEV>
+
+3. Verify that the interface works. Enter the following, where <IP_address>
+   is the IP address for another machine on the same subnet as the interface
+   that is being tested:
+
+	ping  <IP_address>
+or (for IPv6)
+	ping6 <IPv6_address>
+
+4. Check the correct version of the driver is active (assume interface is eth1):
+
+        ethtool -i eth1
+
+Troubleshooting
+-----------------------
+
+Some distributions do not provide kernel sources ready for thirdparty module build.
+In general, the following could be used to prepare kernel source tree for build:
+
+	sudo su
+	cd /lib/modules/`uname -r`/build
+	make oldconfig
+	make prepare
+	make modules_prepare
+
+Command Line Parameters
+=======================
+The following command line parameters are available on atlantic driver:
+
+aq_itr -Interrupt throttling mode
+----------------------------------------
+Accepted values: 0, 1, 0xFFFF
+Default value: 0xFFFF
+0      - Disable interrupt throttling.
+1      - Enable interrupt throttling and use specified tx and rx rates.
+0xFFFF - Auto throttling mode. Driver will choose the best RX and TX
+         interrupt throtting settings based on link speed.
+
+aq_itr_tx - TX interrupt throttle rate
+----------------------------------------
+Accepted values: 0 - 0x1FF
+Default value: 0
+TX side throttling in microseconds. Adapter will setup maximum interrupt delay
+to this value. Minimum interrupt delay will be a half of this value
+
+aq_itr_rx - RX interrupt throttle rate
+----------------------------------------
+Accepted values: 0 - 0x1FF
+Default value: 0
+RX side throttling in microseconds. Adapter will setup maximum interrupt delay
+to this value. Minimum interrupt delay will be a half of this value
+
+Note: ITR settings could be changed in runtime by ethtool -c means (see below)
+
+aq_rxpageorder
+----------------------------------------
+Default value: 0
+RX page order override. Thats a power of 2 number of RX pages allocated for
+each descriptor. Received descriptor size is still limited by AQ_CFG_RX_FRAME_MAX.
+Increasing pageorder makes page reuse better (actual on iommu enabled systems).
+
+aq_rx_refill_thres
+----------------------------------------
+Default value: 32
+RX refill threshold. RX path will not refill freed descriptors until the
+specified number of free descriptors is observed. Larger values may help
+better page reuse but may lead to packet drops as well.
+
+
+Config file parametes
+=======================
+Some parameters can be changed in the {source_dir}/aq_cfg.h file:
+
+AQ_CFG_VECS_DEF
+------------------------------------------------------------
+Number of queues
+Valid Range: 0 - 8 (up to AQ_CFG_VECS_MAX)
+Default value: 4
+
+AQ_CFG_IS_RSS_DEF
+------------------------------------------------------------
+Enable/disable Receive Side Scaling
+
+This feature allows the adapter to distribute receive processing
+across multiple CPU-cores and to prevent from overloading a single CPU core.
+
+Valid values
+0 - disabled
+1 - enabled
+
+Default value: 1
+
+AQ_CFG_NUM_RSS_QUEUES_DEF
+------------------------------------------------------------
+Number of queues for Receive Side Scaling
+Valid Range: 0 - 4 (up to AQ_CFG_VECS_DEF)
+
+Default value: 4
+
+AQ_CFG_IS_LRO_DEF
+------------------------------------------------------------
+Enable/disable Large Receive Offload
+
+This offload enables the adapter to coalesce multiple TCP segments and indicate
+them as a single coalesced unit to the OS networking subsystem.
+The system consumes less energy but it also introduces more latency in packets processing.
+
+Valid values
+0 - disabled
+1 - enabled
+
+Default value: 1
+
+AQ_CFG_TX_CLEAN_BUDGET
+----------------------------------------
+Maximum descriptors to cleanup on TX at once.
+Default value: 256
+
+After the aq_cfg.h file changed the driver must be rebuilt to take effect.
+
+Additional Configurations
+=========================
+  Viewing Link Messages
+  ---------------------
+  Link messages will not be displayed to the console if the distribution is
+  restricting system messages. In order to see network driver link messages on
+  your console, set dmesg to eight by entering the following:
+
+       dmesg -n 8
+
+  NOTE: This setting is not saved across reboots.
+
+  Jumbo Frames
+  ------------
+  The driver supports Jumbo Frames for all adapters. Jumbo Frames support is
+  enabled by changing the MTU to a value larger than the default of 1500.
+  The maximum value for the MTU is 16000.  Use the ifconfig command to
+  increase the MTU size.  For example:
+
+        ifconfig <ethX> mtu 9000 up
+
+  ethtool
+  -------
+  The driver utilizes the ethtool interface for driver configuration and
+  diagnostics, as well as displaying statistical information. The latest 
+  ethtool version is required for this functionality.
+ 
+  
+  NAPI
+  ----
+  NAPI (Rx polling mode) is supported in the atlantic driver. 
+
+  See ftp://robur.slu.se/pub/Linux/net-development/NAPI/usenix-paper.tgz for 
+  more information on NAPI.
+
+Supported ethtool options
+============================
+ Viewing adapter settings
+ ---------------------
+ ethtool <ethX>
+ 
+ Output example:
+ Settings for enp1s0:
+        Supported ports: [ ]
+        Supported link modes:   100baseT/Full
+                                1000baseT/Full
+                                10000baseT/Full
+        Supported pause frame use: Symmetric
+        Supports auto-negotiation: Yes
+        Advertised link modes:  100baseT/Full
+                                1000baseT/Full
+                                10000baseT/Full
+        Advertised pause frame use: Symmetric
+        Advertised auto-negotiation: Yes
+        Speed: 10000Mb/s
+        Duplex: Full
+        Port: FIBRE
+        PHYAD: 0
+        Transceiver: external
+        Auto-negotiation: on
+        Link detected: yes
+
+ ---
+ Note: AQrate speeds (2.5/5 Gb/s) will be displayed only with linux kernels > 4.10.
+    But you can still use these speeds:
+	ethtool -s eth0 autoneg off speed 2500
+		
+ Viewing adapter information
+ ---------------------
+ ethtool -i <ethX>
+
+ Output example:
+ driver: atlantic
+ version: 1.6.9.0
+ firmware-version: 1.5.49
+ expansion-rom-version:
+ bus-info: 0000:01:00.0
+ supports-statistics: yes
+ supports-test: no
+ supports-eeprom-access: no
+ supports-register-dump: yes
+ supports-priv-flags: no
+
+ Viewing Ethernet adapter statistics:
+ ---------------------
+ ethtool -S <ethX>
+
+ Output example:
+ NIC statistics:
+     InPackets: 13238607
+     InUCast: 13293852
+     InMCast: 52
+     InBCast: 3
+     InErrors: 0
+     OutPackets: 23703019
+     OutUCast: 23704941
+     OutMCast: 67
+     OutBCast: 11
+     InUCastOctects: 213182760
+     OutUCastOctects: 22698443
+     InMCastOctects: 6600
+     OutMCastOctects: 8776
+     InBCastOctects: 192
+     OutBCastOctects: 704
+     InOctects: 2131839552
+     OutOctects: 226938073
+     InPacketsDma: 95532300
+     OutPacketsDma: 59503397
+     InOctetsDma: 1137102462
+     OutOctetsDma: 2394339518
+     InDroppedDma: 0
+     Queue[0] InPackets: 23567131
+     Queue[0] OutPackets: 20070028
+     Queue[0] InJumboPackets: 0
+     Queue[0] InLroPackets: 0
+     Queue[0] InErrors: 0
+     Queue[1] InPackets: 45428967
+     Queue[1] OutPackets: 11306178
+     Queue[1] InJumboPackets: 0
+     Queue[1] InLroPackets: 0
+     Queue[1] InErrors: 0
+     Queue[2] InPackets: 3187011
+     Queue[2] OutPackets: 13080381
+     Queue[2] InJumboPackets: 0
+     Queue[2] InLroPackets: 0
+     Queue[2] InErrors: 0
+     Queue[3] InPackets: 23349136
+     Queue[3] OutPackets: 15046810
+     Queue[3] InJumboPackets: 0
+     Queue[3] InLroPackets: 0
+     Queue[3] InErrors: 0
+
+ Disable GRO when routing/bridging
+ ---------------------------------
+ Due to a known kernel issue, GRO must be turned off when routing/bridging. 
+ Its can be done with command:
+ 
+ ethtool -K <ethX> gro off
+
+ 
+ Disable LRO when routing/bridging
+ ---------------------------------
+ Due to a known kernel issue, LRO must be turned off when routing/bridging. 
+ Its can be done with command:
+ 
+ ethtool -K <ethX> lro off
+
+ Interrupt coalescing support
+ ---------------------------------
+ ITR mode, TX/RX coalescing timings could be viewed with:
+ 
+ ethtool -c <ethX>
+ 
+ and changed with:
+ 
+ ethtool -C <ethX> tx-usecs <usecs> rx-usecs <usecs>
+ 
+ To disable coalescing:
+
+ ethtool -C <ethX> tx-usecs 0 rx-usecs 0 tx-max-frames 1 tx-max-frames 1
+ 
+ Wake on LAN support
+ ---------------------------------
+
+ WOL support by magic packet:
+
+ ethtool -s <ethX> wol g
+ 
+ To disable WOL:
+
+ ethtool -s <ethX> wol d
+
+Support
+=======
+
+If an issue is identified with the released source code on the supported
+kernel with a supported adapter, email the specific information related
+to the issue to support@aquantia.com
+
+License
+=======
+
+aQuantia Corporation Network Driver
+Copyright(c) 2014 - 2018 aQuantia Corporation.
+
+This program is free software; you can redistribute it and/or modify it
+under the terms and conditions of the GNU General Public License,
+version 2, as published by the Free Software Foundation.
diff --git a/drivers/net/ethernet/aquantia/aq_cfg.h b/drivers/net/ethernet/aquantia/aq_cfg.h
new file mode 100644
index 00000000..f7b69c8
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_cfg.h
@@ -0,0 +1,96 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_cfg.h: Definition of configuration parameters and constants. */
+
+#ifndef AQ_CFG_H
+#define AQ_CFG_H
+
+#define AQ_CFG_VECS_DEF   4U
+#define AQ_CFG_TCS_DEF    1U
+
+#define AQ_CFG_TXDS_DEF    4096U
+#define AQ_CFG_RXDS_DEF    2048U
+
+#define AQ_CFG_IS_POLLING_DEF 0U
+
+#define AQ_CFG_FORCE_LEGACY_INT 0U
+
+#define AQ_CFG_INTERRUPT_MODERATION_OFF		0
+#define AQ_CFG_INTERRUPT_MODERATION_ON		1
+#define AQ_CFG_INTERRUPT_MODERATION_AUTO	0xFFFFU
+
+#define AQ_CFG_INTERRUPT_MODERATION_USEC_MAX (0x1FF * 2)
+
+#define AQ_CFG_IRQ_MASK                      0x1FFU
+
+#define AQ_CFG_VECS_MAX   8U
+#define AQ_CFG_TCS_MAX    8U
+
+#define AQ_CFG_TX_FRAME_MAX  (16U * 1024U)
+#define AQ_CFG_RX_FRAME_MAX  (2U * 1024U)
+
+#define AQ_CFG_TX_CLEAN_BUDGET 256U
+
+#define AQ_CFG_RX_HDR_SIZE 256U
+
+/* LRO */
+#define AQ_CFG_IS_LRO_DEF           1U
+
+/* RSS */
+#define AQ_CFG_RSS_INDIRECTION_TABLE_MAX  128U
+#define AQ_CFG_RSS_HASHKEY_SIZE           320U
+
+#define AQ_CFG_IS_RSS_DEF           1U
+#define AQ_CFG_NUM_RSS_QUEUES_DEF   AQ_CFG_VECS_DEF
+#define AQ_CFG_RSS_BASE_CPU_NUM_DEF 0U
+
+#define AQ_CFG_PCI_FUNC_MSIX_IRQS   9U
+#define AQ_CFG_PCI_FUNC_PORTS       2U
+
+#define AQ_CFG_SERVICE_TIMER_INTERVAL    (1 * HZ)
+#define AQ_CFG_POLLING_TIMER_INTERVAL   ((unsigned int)(2 * HZ))
+
+#define AQ_CFG_SKB_FRAGS_MAX   32U
+
+/* Number of descriptors available in one ring to resume this ring queue
+ */
+#define AQ_CFG_RESTART_DESC_THRES   (AQ_CFG_SKB_FRAGS_MAX * 2)
+
+#define AQ_CFG_NAPI_WEIGHT     64U
+
+#define AQ_CFG_MULTICAST_ADDRESS_MAX     32U
+
+/*#define AQ_CFG_MAC_ADDR_PERMANENT {0x30, 0x0E, 0xE3, 0x12, 0x34, 0x56}*/
+
+#define AQ_NIC_FC_OFF    0U
+#define AQ_NIC_FC_TX     1U
+#define AQ_NIC_FC_RX     2U
+#define AQ_NIC_FC_FULL   3U
+#define AQ_NIC_FC_AUTO   4U
+
+#define AQ_CFG_FC_MODE AQ_NIC_FC_FULL
+
+#define AQ_CFG_SPEED_MSK  0xFFFFU	/* 0xFFFFU==auto_neg */
+
+#define AQ_CFG_IS_AUTONEG_DEF       1U
+#define AQ_CFG_MTU_DEF              1514U
+
+#define AQ_CFG_LOCK_TRYS   100U
+
+#define AQ_CFG_DRV_AUTHOR      "aQuantia"
+#define AQ_CFG_DRV_DESC        "aQuantia Corporation(R) Network Driver"
+#define AQ_CFG_DRV_NAME        "atlantic"
+#define AQ_CFG_DRV_VERSION	__stringify(NIC_MAJOR_DRIVER_VERSION)"."\
+				__stringify(NIC_MINOR_DRIVER_VERSION)"."\
+				__stringify(NIC_BUILD_DRIVER_VERSION)"."\
+				__stringify(NIC_REVISION_DRIVER_VERSION) \
+				AQ_CFG_DRV_VERSION_SUFFIX
+
+#endif /* AQ_CFG_H */
diff --git a/drivers/net/ethernet/aquantia/aq_common.h b/drivers/net/ethernet/aquantia/aq_common.h
new file mode 100644
index 00000000..c1886e1
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_common.h
@@ -0,0 +1,66 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_common.h: Basic includes for all files in project. */
+
+#ifndef AQ_COMMON_H
+#define AQ_COMMON_H
+
+#include <linux/etherdevice.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#include "ver.h"
+#include "aq_cfg.h"
+#include "aq_utils.h"
+#include "aq_compat.h"
+
+#define PCI_VENDOR_ID_AQUANTIA  0x1D6A
+
+#define AQ_DEVICE_ID_0001	0x0001
+#define AQ_DEVICE_ID_D100	0xD100
+#define AQ_DEVICE_ID_D107	0xD107
+#define AQ_DEVICE_ID_D108	0xD108
+#define AQ_DEVICE_ID_D109	0xD109
+
+#define AQ_DEVICE_ID_AQC100	0x00B1
+#define AQ_DEVICE_ID_AQC107	0x07B1
+#define AQ_DEVICE_ID_AQC108	0x08B1
+#define AQ_DEVICE_ID_AQC109	0x09B1
+#define AQ_DEVICE_ID_AQC111	0x11B1
+#define AQ_DEVICE_ID_AQC112	0x12B1
+
+#define AQ_DEVICE_ID_AQC100S	0x80B1
+#define AQ_DEVICE_ID_AQC107S	0x87B1
+#define AQ_DEVICE_ID_AQC108S	0x88B1
+#define AQ_DEVICE_ID_AQC109S	0x89B1
+#define AQ_DEVICE_ID_AQC111S	0x91B1
+#define AQ_DEVICE_ID_AQC112S	0x92B1
+
+#define AQ_DEVICE_ID_AQC111E	0x51B1
+#define AQ_DEVICE_ID_AQC112E	0x52B1
+
+#define HW_ATL_NIC_NAME "aQuantia AQtion 10Gbit Network Adapter"
+
+#define AQ_HWREV_ANY	0
+#define AQ_HWREV_1	1
+#define AQ_HWREV_2	2
+
+#define AQ_NIC_RATE_10G		BIT(0)
+#define AQ_NIC_RATE_5G		BIT(1)
+#define AQ_NIC_RATE_5GSR	BIT(2)
+#define AQ_NIC_RATE_2GS		BIT(3)
+#define AQ_NIC_RATE_1G		BIT(4)
+#define AQ_NIC_RATE_100M	BIT(5)
+
+#define AQ_NIC_RATE_EEE_10G	BIT(6)
+#define AQ_NIC_RATE_EEE_5G	BIT(7)
+#define AQ_NIC_RATE_EEE_2GS	BIT(8)
+#define AQ_NIC_RATE_EEE_1G	BIT(9)
+
+#endif /* AQ_COMMON_H */
diff --git a/drivers/net/ethernet/aquantia/aq_compat.h b/drivers/net/ethernet/aquantia/aq_compat.h
new file mode 100644
index 00000000..ed4c718
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_compat.h
@@ -0,0 +1,116 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_compat.h: Backward compat with previous linux kernel versions */
+
+#ifndef AQ_COMPAT_H
+#define AQ_COMPAT_H
+
+#include <linux/version.h>
+
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b) (((a) << 8) + (b))
+#endif
+
+#ifndef RHEL_RELEASE_CODE
+#define RHEL_RELEASE_CODE 0
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+
+#define from_timer(var, callback_timer, timer_fieldname) \
+	container_of(callback_timer, typeof(*var), timer_fieldname)
+
+static inline void timer_setup(struct timer_list *timer,
+			       void (*callback)(struct timer_list *),
+			       unsigned int flags)
+{
+	setup_timer(timer, (void (*)(unsigned long))callback, (unsigned long)timer);
+}
+
+#endif
+
+#ifndef SPEED_5000
+#define SPEED_5000 5000
+#endif
+
+#ifndef ETH_MIN_MTU
+#define ETH_MIN_MTU	68
+#endif
+
+#ifndef SKB_ALLOC_NAPI
+static inline struct sk_buff *napi_alloc_skb(struct napi_struct *napi, unsigned int length)
+{
+	return netdev_alloc_skb_ip_align(napi->dev, length);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+/* from commit 1dff8083a024650c75a9c961c38082473ceae8cf */
+#define page_to_virt(x)	__va(PFN_PHYS(page_to_pfn(x)))
+#endif	/* 4.7.0 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+
+#if !(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2)))
+/* from commit fe896d1878949ea92ba547587bc3075cc688fb8f */
+static inline void page_ref_inc(struct page *page)
+{
+	atomic_inc(&page->_count);
+}
+
+static inline int page_ref_count(struct page *page)
+{
+	return atomic_read(&page->_count);
+}
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)) && !(RHEL_RELEASE_CODE)
+
+/* from commit 286ab723d4b83d37deb4017008ef1444a95cfb0d */
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+	memcpy(dst, src, 6);
+}
+#endif /* 3.14.0 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0)
+
+/* introduced in commit 56193d1bce2b2759cb4bdcc00cd05544894a0c90
+ * pull the whole head buffer len for now*/
+#define eth_get_headlen(__data, __max_len) (__max_len)
+
+/* ->xmit_more introduced in commit
+ * 0b725a2ca61bedc33a2a63d0451d528b268cf975 for 3.18-rc1 */
+static inline int skb_xmit_more(struct sk_buff *skb)
+{
+	return 0;
+}
+
+#else /* 3.18.0 */
+static inline int skb_xmit_more(struct sk_buff *skb)
+{
+	return skb->xmit_more;
+}
+
+#endif	/* 3.18.0 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+#define IFF_UNICAST_FLT        0
+#define dev_alloc_pages(__order) alloc_pages_node(NUMA_NO_NODE,                         \
+                                                  GFP_ATOMIC | __GFP_COMP | __GFP_COLD, \
+                                                  __order)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+/* introduced in commit 71dfda58aaaf4bf6b1bc59f9d8afa635fa1337d4 */
+#define dev_alloc_pages(__order) __skb_alloc_pages(GFP_ATOMIC | __GFP_COMP, NULL, __order)
+#endif  /* 3.19.0 */
+
+#endif /* AQ_COMMON_H */
diff --git a/drivers/net/ethernet/aquantia/aq_drvinfo.c b/drivers/net/ethernet/aquantia/aq_drvinfo.c
new file mode 100644
index 00000000..1a07f67
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_drvinfo.c
@@ -0,0 +1,92 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_drvinfo.c: Definition of common code for firmware info in sys.*/
+
+#include <linux/init.h>
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+
+#include "aq_drvinfo.h"
+
+
+static ssize_t show_temp(struct device *ndev, struct device_attribute *attr,
+			    char *buf)
+{
+	int err;
+
+	struct aq_nic_s *aq_nic = netdev_priv(to_net_dev(ndev));
+
+	int temp = 0;
+
+	if (!aq_nic->aq_fw_ops->get_temp)
+		return -ENXIO;
+
+	err = aq_nic->aq_fw_ops->get_temp(aq_nic->aq_hw, &temp);
+
+	if (err == 0)
+		return sprintf(buf, "%d.%d\n", temp / 100, temp % 100);
+	return -ENXIO;
+}
+
+
+static ssize_t show_cable_len(struct device *ndev,
+				struct device_attribute *attr, char *buf)
+{
+	int err;
+
+	struct aq_nic_s *aq_nic = netdev_priv(to_net_dev(ndev));
+
+	int cable_len = 0;
+
+	if (!aq_nic->aq_fw_ops->get_cable_len)
+		return -ENXIO;
+
+	err = aq_nic->aq_fw_ops->get_cable_len(aq_nic->aq_hw, &cable_len);
+
+	if (err == 0)
+		return sprintf(buf, "%d\n", cable_len);
+	return -ENXIO;
+}
+
+
+static struct device_attribute aq_dev_attrs[] = {
+	__ATTR(temperature, 0444, show_temp, NULL),
+	__ATTR(cable_length, 0444, show_cable_len, NULL),
+};
+
+int aq_sysfs_init(struct net_device *ndev)
+{
+	int i;
+	int err = 0;
+
+	for (i = 0; i < ARRAY_SIZE(aq_dev_attrs); i++) {
+		err = device_create_file(&ndev->dev, &aq_dev_attrs[i]);
+		if (err < 0) {
+			while (i > 0)
+				device_remove_file(&ndev->dev,
+						&aq_dev_attrs[--i]);
+			break;
+		}
+	}
+	return err;
+}
+
+void aq_sysfs_exit(struct net_device *ndev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(aq_dev_attrs); i++)
+		device_remove_file(&ndev->dev, &aq_dev_attrs[i]);
+}
+
diff --git a/drivers/net/ethernet/aquantia/aq_drvinfo.h b/drivers/net/ethernet/aquantia/aq_drvinfo.h
new file mode 100644
index 00000000..2199ac4
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_drvinfo.h
@@ -0,0 +1,25 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_drvinfo.h: Declaration of common code for firmware info in sys.*/
+
+#ifndef AQ_DRVINFO_H
+#define AQ_DRVINFO_H
+
+#include "aq_nic.h"
+#include "aq_hw.h"
+#include "hw_atl/hw_atl_utils.h"
+
+
+int aq_sysfs_init(struct net_device *ndev);
+void aq_sysfs_exit(struct net_device *ndev);
+
+
+#endif /* AQ_DRVINFO_H */
+
diff --git a/drivers/net/ethernet/aquantia/aq_ethtool.c b/drivers/net/ethernet/aquantia/aq_ethtool.c
new file mode 100644
index 00000000..419dbe6
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_ethtool.c
@@ -0,0 +1,596 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_ethtool.c: Definition of ethertool related functions. */
+
+#include "aq_ethtool.h"
+#include "aq_nic.h"
+#include "aq_vec.h"
+
+static void aq_ethtool_get_regs(struct net_device *ndev,
+				struct ethtool_regs *regs, void *p)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	u32 regs_count = aq_nic_get_regs_count(aq_nic);
+
+	memset(p, 0, regs_count * sizeof(u32));
+	aq_nic_get_regs(aq_nic, regs, p);
+}
+
+static int aq_ethtool_get_regs_len(struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	u32 regs_count = aq_nic_get_regs_count(aq_nic);
+
+	return regs_count * sizeof(u32);
+}
+
+static u32 aq_ethtool_get_link(struct net_device *ndev)
+{
+	return ethtool_op_get_link(ndev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+static int aq_ethtool_get_link_ksettings(struct net_device *ndev,
+					 struct ethtool_link_ksettings *cmd)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	aq_nic_get_link_ksettings(aq_nic, cmd);
+	cmd->base.speed = netif_carrier_ok(ndev) ?
+				aq_nic_get_link_speed(aq_nic) : 0U;
+
+	return 0;
+}
+
+static int
+aq_ethtool_set_link_ksettings(struct net_device *ndev,
+			      const struct ethtool_link_ksettings *cmd)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	return aq_nic_set_link_ksettings(aq_nic, cmd);
+}
+#else
+static int aq_ethtool_get_settings(struct net_device *ndev,
+				   struct ethtool_cmd *cmd)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+
+	aq_nic_get_link_settings(aq_nic, cmd);
+	ethtool_cmd_speed_set(cmd, netif_carrier_ok(ndev) ?
+				aq_nic_get_link_speed(aq_nic) : 0U);
+
+	return 0;
+}
+
+static int aq_ethtool_set_settings(struct net_device *ndev,
+				   struct ethtool_cmd *cmd)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = 0U;
+
+	err = aq_nic_set_link_settings(aq_nic, cmd);
+
+	return err;
+}
+#endif
+
+static const char aq_ethtool_stat_names[][ETH_GSTRING_LEN] = {
+	"InPackets",
+	"InUCast",
+	"InMCast",
+	"InBCast",
+	"InErrors",
+	"OutPackets",
+	"OutUCast",
+	"OutMCast",
+	"OutBCast",
+	"InUCastOctets",
+	"OutUCastOctets",
+	"InMCastOctets",
+	"OutMCastOctets",
+	"InBCastOctets",
+	"OutBCastOctets",
+	"InOctets",
+	"OutOctets",
+	"InPacketsDma",
+	"OutPacketsDma",
+	"InOctetsDma",
+	"OutOctetsDma",
+	"InDroppedDma",
+};
+
+static const char aq_ethtool_queue_stat_names[][ETH_GSTRING_LEN] = {
+	"Queue[%d] InPackets",
+	"Queue[%d] OutPackets",
+	"Queue[%d] Restarts",
+	"Queue[%d] InJumboPackets",
+	"Queue[%d] InLroPackets",
+	"Queue[%d] InErrors",
+};
+
+static void aq_ethtool_stats(struct net_device *ndev,
+			     struct ethtool_stats *stats, u64 *data)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	memset(data, 0, (ARRAY_SIZE(aq_ethtool_stat_names) +
+				ARRAY_SIZE(aq_ethtool_queue_stat_names) *
+				cfg->vecs) * sizeof(u64));
+	aq_nic_get_stats(aq_nic, data);
+}
+
+static void aq_ethtool_get_drvinfo(struct net_device *ndev,
+				   struct ethtool_drvinfo *drvinfo)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
+	u32 firmware_version = aq_nic_get_fw_version(aq_nic);
+	u32 regs_count = aq_nic_get_regs_count(aq_nic);
+
+	strlcat(drvinfo->driver, AQ_CFG_DRV_NAME, sizeof(drvinfo->driver));
+	strlcat(drvinfo->version, AQ_CFG_DRV_VERSION, sizeof(drvinfo->version));
+
+	snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),
+		 "%u.%u.%u", firmware_version >> 24,
+		 (firmware_version >> 16) & 0xFFU, firmware_version & 0xFFFFU);
+
+	strlcpy(drvinfo->bus_info, pdev ? pci_name(pdev) : "",
+		sizeof(drvinfo->bus_info));
+	drvinfo->n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +
+		cfg->vecs * ARRAY_SIZE(aq_ethtool_queue_stat_names);
+	drvinfo->testinfo_len = 0;
+	drvinfo->regdump_len = regs_count;
+	drvinfo->eedump_len = 0;
+}
+
+static void aq_ethtool_get_strings(struct net_device *ndev,
+				   u32 stringset, u8 *data)
+{
+	int i, si;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	u8 *p = data;
+
+	if (stringset == ETH_SS_STATS) {
+		memcpy(p, *aq_ethtool_stat_names,
+		       sizeof(aq_ethtool_stat_names));
+		p = p + sizeof(aq_ethtool_stat_names);
+		for (i = 0; i < cfg->vecs; i++) {
+			for (si = 0;
+				si < ARRAY_SIZE(aq_ethtool_queue_stat_names);
+				si++) {
+				snprintf(p, ETH_GSTRING_LEN,
+					 aq_ethtool_queue_stat_names[si], i);
+				p += ETH_GSTRING_LEN;
+			}
+		}
+	}
+}
+
+static int aq_ethtool_get_sset_count(struct net_device *ndev, int stringset)
+{
+	int ret = 0;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		ret = ARRAY_SIZE(aq_ethtool_stat_names) +
+			cfg->vecs * ARRAY_SIZE(aq_ethtool_queue_stat_names);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+static u32 aq_ethtool_get_rss_indir_size(struct net_device *ndev)
+{
+	return AQ_CFG_RSS_INDIRECTION_TABLE_MAX;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+static u32 aq_ethtool_get_rss_key_size(struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	return sizeof(cfg->aq_rss.hash_secret_key);
+}
+
+#if defined(ETH_RSS_HASH_TOP)
+static int aq_ethtool_get_rss(struct net_device *ndev, u32 *indir, u8 *key,
+			      u8 *hfunc)
+#else
+static int aq_ethtool_get_rss(struct net_device *ndev, u32 *indir, u8 *key)
+#endif
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	unsigned int i = 0U;
+
+#if defined(ETH_RSS_HASH_TOP)
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP; /* Toeplitz */
+#endif
+	if (indir) {
+		for (i = 0; i < AQ_CFG_RSS_INDIRECTION_TABLE_MAX; i++)
+			indir[i] = cfg->aq_rss.indirection_table[i];
+	}
+	if (key)
+		memcpy(key, cfg->aq_rss.hash_secret_key,
+		       sizeof(cfg->aq_rss.hash_secret_key));
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+static int aq_ethtool_get_rxnfc(struct net_device *ndev,
+				struct ethtool_rxnfc *cmd,
+				u32 *rule_locs)
+#else
+static int aq_ethtool_get_rxnfc(struct net_device *ndev,
+				struct ethtool_rxnfc *cmd,
+				void *rule_locs)
+#endif
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	int err = 0;
+
+	switch (cmd->cmd) {
+	case ETHTOOL_GRXRINGS:
+		cmd->data = cfg->vecs;
+		break;
+
+	default:
+		err = -EOPNOTSUPP;
+		break;
+	}
+
+	return err;
+}
+
+static int aq_ethtool_get_coalesce(struct net_device *ndev,
+				   struct ethtool_coalesce *coal)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	if (cfg->itr == AQ_CFG_INTERRUPT_MODERATION_ON ||
+	    cfg->itr == AQ_CFG_INTERRUPT_MODERATION_AUTO) {
+		coal->rx_coalesce_usecs = cfg->rx_itr;
+		coal->tx_coalesce_usecs = cfg->tx_itr;
+		coal->rx_max_coalesced_frames = 0;
+		coal->tx_max_coalesced_frames = 0;
+	} else {
+		coal->rx_coalesce_usecs = 0;
+		coal->tx_coalesce_usecs = 0;
+		coal->rx_max_coalesced_frames = 1;
+		coal->tx_max_coalesced_frames = 1;
+	}
+	return 0;
+}
+
+static int aq_ethtool_set_coalesce(struct net_device *ndev,
+				   struct ethtool_coalesce *coal)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	/* This is not yet supported
+	 */
+	if (coal->use_adaptive_rx_coalesce || coal->use_adaptive_tx_coalesce)
+		return -EOPNOTSUPP;
+
+	/* Atlantic only supports timing based coalescing
+	 */
+	if (coal->rx_max_coalesced_frames > 1 ||
+	    coal->rx_coalesce_usecs_irq ||
+	    coal->rx_max_coalesced_frames_irq)
+		return -EOPNOTSUPP;
+
+	if (coal->tx_max_coalesced_frames > 1 ||
+	    coal->tx_coalesce_usecs_irq ||
+	    coal->tx_max_coalesced_frames_irq)
+		return -EOPNOTSUPP;
+
+	/* We do not support frame counting. Check this
+	 */
+	if (!(coal->rx_max_coalesced_frames == !coal->rx_coalesce_usecs))
+		return -EOPNOTSUPP;
+	if (!(coal->tx_max_coalesced_frames == !coal->tx_coalesce_usecs))
+		return -EOPNOTSUPP;
+
+	if (coal->rx_coalesce_usecs > AQ_CFG_INTERRUPT_MODERATION_USEC_MAX ||
+	    coal->tx_coalesce_usecs > AQ_CFG_INTERRUPT_MODERATION_USEC_MAX)
+		return -EINVAL;
+
+	cfg->itr = AQ_CFG_INTERRUPT_MODERATION_ON;
+
+	cfg->rx_itr = coal->rx_coalesce_usecs;
+	cfg->tx_itr = coal->tx_coalesce_usecs;
+
+	return aq_nic_update_interrupt_moderation_settings(aq_nic);
+}
+
+
+static void aq_ethtool_get_wol(struct net_device *ndev,
+			       struct ethtool_wolinfo *wol)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = 0;
+
+	if (cfg->wol)
+		wol->wolopts |= WAKE_MAGIC;
+}
+
+static int aq_ethtool_set_wol(struct net_device *ndev,
+			      struct ethtool_wolinfo *wol)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
+	int err = 0;
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		cfg->wol |= AQ_NIC_WOL_ENABLED;
+	} else {
+		cfg->wol &= ~AQ_NIC_WOL_ENABLED;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	err = device_set_wakeup_enable(&pdev->dev, wol->wolopts);
+#else
+	device_set_wakeup_enable(&pdev->dev, wol->wolopts);
+#endif
+
+	return err;
+}
+
+static enum hw_atl_fw2x_rate eee_mask_to_ethtool_mask(u32 speed)
+{
+	u32 rate = 0;
+
+	if (speed & AQ_NIC_RATE_EEE_10G)
+		rate |= SUPPORTED_10000baseT_Full;
+
+	/* This is not supported
+	 * if (speed & AQ_NIC_RATE_EEE_5G)
+	 *	rate |= SUPPORTED_5000baseX_Full;
+	 */
+
+	if (speed & AQ_NIC_RATE_EEE_2GS)
+		rate |= SUPPORTED_2500baseX_Full;
+
+
+	if (speed & AQ_NIC_RATE_EEE_1G)
+		rate |= SUPPORTED_1000baseT_Full;
+
+	return rate;
+}
+
+static int aq_ethtool_get_eee(struct net_device *ndev, struct ethtool_eee *eee)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = 0;
+
+	u32 rate, supported_rates;
+
+	if (!aq_nic->aq_fw_ops->get_eee_rate)
+		return -EOPNOTSUPP;
+
+	err = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,
+						&supported_rates);
+	if (err < 0)
+		return err;
+
+	eee->supported = eee_mask_to_ethtool_mask(supported_rates);
+
+	if (aq_nic->aq_nic_cfg.eee_enabled)
+		eee->advertised = eee->supported;
+
+	eee->lp_advertised = eee_mask_to_ethtool_mask(rate);
+
+	eee->eee_enabled = !!eee->advertised;
+
+	eee->tx_lpi_enabled = eee->eee_enabled;
+	if (eee->advertised & eee->lp_advertised)
+		eee->eee_active = true;
+
+	return 0;
+}
+
+static int aq_ethtool_set_eee(struct net_device *ndev, struct ethtool_eee *eee)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+	u32 rate, supported_rates;
+	int err = 0;
+
+	if (!aq_nic->aq_fw_ops->get_eee_rate)
+		return -EOPNOTSUPP;
+
+	err = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,
+							&supported_rates);
+	if (err < 0)
+		return err;
+
+	if (eee->eee_enabled) {
+		rate = supported_rates;
+		cfg->eee_enabled = rate;
+	} else {
+		rate = 0;
+		cfg->eee_enabled = 0;
+	}
+
+	if (aq_nic->aq_fw_ops->set_eee_rate)
+		return aq_nic->aq_fw_ops->set_eee_rate(aq_nic->aq_hw, rate);
+
+	return -EOPNOTSUPP;
+}
+
+static int aq_ethtool_nway_reset(struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	if (unlikely(!aq_nic->aq_fw_ops->renegotiate))
+		return -EOPNOTSUPP;
+
+	if (netif_running(ndev))
+		return aq_nic->aq_fw_ops->renegotiate(aq_nic->aq_hw);
+
+	return 0;
+}
+
+static void aq_ethtool_get_pauseparam(struct net_device *ndev,
+				      struct ethtool_pauseparam *pause)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	pause->autoneg = 0;
+
+	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_RX)
+		pause->rx_pause = 1;
+	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_TX)
+		pause->tx_pause = 1;
+}
+
+static int aq_ethtool_set_pauseparam(struct net_device *ndev,
+				     struct ethtool_pauseparam *pause)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = 0;
+
+	if (!aq_nic->aq_fw_ops->set_flow_control)
+		return -EOPNOTSUPP;
+
+	if (pause->autoneg == AUTONEG_ENABLE)
+		return -EOPNOTSUPP;
+
+	if (pause->rx_pause)
+		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_RX;
+	else
+		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_RX;
+
+	if (pause->tx_pause)
+		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_TX;
+	else
+		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_TX;
+
+
+	err = aq_nic->aq_fw_ops->set_flow_control(aq_nic->aq_hw);
+
+	return err;
+}
+
+static void aq_get_ringparam(struct net_device *ndev,
+                             struct ethtool_ringparam *ring)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+
+	ring->rx_pending = aq_nic_cfg->rxds;
+	ring->tx_pending = aq_nic_cfg->txds;
+
+	ring->rx_max_pending = aq_nic_cfg->aq_hw_caps->rxds_max;
+	ring->tx_max_pending = aq_nic_cfg->aq_hw_caps->txds_max;
+}
+
+static int aq_set_ringparam(struct net_device *ndev,
+                            struct ethtool_ringparam *ring)
+{
+	int err = 0;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+	const struct aq_hw_caps_s *hw_caps = aq_nic_cfg->aq_hw_caps;
+
+	if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending)) {
+		err = -EOPNOTSUPP;
+		goto err_exit;
+	}
+
+	spin_lock(&aq_nic->aq_spinlock);
+
+	if (netif_running(ndev))
+		dev_close(ndev);
+
+	aq_nic_free_vectors(aq_nic);
+
+	aq_nic_cfg->rxds = max(ring->rx_pending, hw_caps->rxds_min);
+	aq_nic_cfg->rxds = min(aq_nic_cfg->rxds, hw_caps->rxds_max);
+	aq_nic_cfg->rxds = ALIGN(aq_nic_cfg->rxds, AQ_HW_RXD_MULTIPLE);
+
+	aq_nic_cfg->txds = max(ring->tx_pending, hw_caps->txds_min);
+	aq_nic_cfg->txds = min(aq_nic_cfg->txds, hw_caps->txds_max);
+	aq_nic_cfg->txds = ALIGN(aq_nic_cfg->txds, AQ_HW_TXD_MULTIPLE);
+
+	for (aq_nic->aq_vecs = 0; aq_nic->aq_vecs < aq_nic_cfg->vecs;
+	     aq_nic->aq_vecs++) {
+		aq_nic->aq_vec[aq_nic->aq_vecs] =
+		    aq_vec_alloc(aq_nic, aq_nic->aq_vecs, aq_nic_cfg);
+		if (unlikely(!aq_nic->aq_vec[aq_nic->aq_vecs])) {
+			err = -ENOMEM;
+			goto err_unlock;
+		}
+	}
+	if (!netif_running(ndev))
+		err = dev_open(ndev);
+
+err_unlock:
+	spin_unlock(&aq_nic->aq_spinlock);
+err_exit:
+	return err;
+}
+
+const struct ethtool_ops aq_ethtool_ops = {
+	.get_link            = aq_ethtool_get_link,
+	.get_regs_len        = aq_ethtool_get_regs_len,
+	.get_regs            = aq_ethtool_get_regs,
+	.get_drvinfo         = aq_ethtool_get_drvinfo,
+	.get_strings         = aq_ethtool_get_strings,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	.get_rxfh_indir_size = aq_ethtool_get_rss_indir_size,
+#endif
+	.get_wol             = aq_ethtool_get_wol,
+	.set_wol             = aq_ethtool_set_wol,
+	.nway_reset          = aq_ethtool_nway_reset,
+	.get_ringparam       = aq_get_ringparam,
+	.set_ringparam       = aq_set_ringparam,
+	.get_eee             = aq_ethtool_get_eee,
+	.set_eee             = aq_ethtool_set_eee,
+	.get_pauseparam      = aq_ethtool_get_pauseparam,
+	.set_pauseparam      = aq_ethtool_set_pauseparam,
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+	.get_rxfh_key_size   = aq_ethtool_get_rss_key_size,
+	.get_rxfh            = aq_ethtool_get_rss,
+#endif
+	.get_rxnfc           = aq_ethtool_get_rxnfc,
+	.get_sset_count      = aq_ethtool_get_sset_count,
+	.get_ethtool_stats   = aq_ethtool_stats,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+	.get_link_ksettings  = aq_ethtool_get_link_ksettings,
+	.set_link_ksettings  = aq_ethtool_set_link_ksettings,
+#else
+	.get_settings        = aq_ethtool_get_settings,
+	.set_settings        = aq_ethtool_set_settings,
+#endif
+	.get_coalesce	     = aq_ethtool_get_coalesce,
+	.set_coalesce	     = aq_ethtool_set_coalesce,
+};
diff --git a/drivers/net/ethernet/aquantia/aq_ethtool.h b/drivers/net/ethernet/aquantia/aq_ethtool.h
new file mode 100644
index 00000000..21c126e
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_ethtool.h
@@ -0,0 +1,19 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_ethtool.h: Declaration of ethertool related functions. */
+
+#ifndef AQ_ETHTOOL_H
+#define AQ_ETHTOOL_H
+
+#include "aq_common.h"
+
+extern const struct ethtool_ops aq_ethtool_ops;
+
+#endif /* AQ_ETHTOOL_H */
diff --git a/drivers/net/ethernet/aquantia/aq_hw.h b/drivers/net/ethernet/aquantia/aq_hw.h
new file mode 100644
index 00000000..83634bb
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_hw.h
@@ -0,0 +1,243 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_hw.h: Declaration of abstract interface for NIC hardware specific
+ * functions.
+ */
+
+#ifndef AQ_HW_H
+#define AQ_HW_H
+
+#include "aq_common.h"
+#include "aq_rss.h"
+#include "hw_atl/hw_atl_utils.h"
+
+/* NIC H/W capabilities */
+struct aq_hw_caps_s {
+	u64 hw_features;
+	u64 link_speed_msk;
+	unsigned int hw_priv_flags;
+	u32 media_type;
+	u32 rxds_max;
+	u32 txds_max;
+	u32 rxds_min;
+	u32 txds_min;
+	u32 txhwb_alignment;
+	u32 irq_mask;
+	u32 vecs;
+	u32 mtu;
+	u32 mac_regs_count;
+	u32 hw_alive_check_addr;
+	u8 msix_irqs;
+	u8 tcs;
+	u8 rxd_alignment;
+	u8 rxd_size;
+	u8 txd_alignment;
+	u8 txd_size;
+	u8 tx_rings;
+	u8 rx_rings;
+	bool flow_control;
+	bool is_64_dma;
+};
+
+struct aq_hw_link_status_s {
+	unsigned int mbps;
+};
+
+struct aq_stats_s {
+	u64 uprc;
+	u64 mprc;
+	u64 bprc;
+	u64 erpt;
+	u64 uptc;
+	u64 mptc;
+	u64 bptc;
+	u64 erpr;
+	u64 mbtc;
+	u64 bbtc;
+	u64 mbrc;
+	u64 bbrc;
+	u64 ubrc;
+	u64 ubtc;
+	u64 dpc;
+	u64 dma_pkt_rc;
+	u64 dma_pkt_tc;
+	u64 dma_oct_rc;
+	u64 dma_oct_tc;
+};
+
+#define AQ_HW_IRQ_INVALID 0U
+#define AQ_HW_IRQ_LEGACY  1U
+#define AQ_HW_IRQ_MSI     2U
+#define AQ_HW_IRQ_MSIX    3U
+
+#define AQ_HW_POWER_STATE_D0   0U
+#define AQ_HW_POWER_STATE_D3   3U
+
+#define AQ_HW_FLAG_STARTED     0x00000004U
+#define AQ_HW_FLAG_STOPPING    0x00000008U
+#define AQ_HW_FLAG_RESETTING   0x00000010U
+#define AQ_HW_FLAG_CLOSING     0x00000020U
+#define AQ_HW_LINK_DOWN        0x04000000U
+#define AQ_HW_FLAG_ERR_UNPLUG  0x40000000U
+#define AQ_HW_FLAG_ERR_HW      0x80000000U
+
+#define AQ_HW_FLAG_ERRORS      (AQ_HW_FLAG_ERR_HW | AQ_HW_FLAG_ERR_UNPLUG)
+
+#define AQ_NIC_FLAGS_IS_NOT_READY (AQ_NIC_FLAG_STOPPING | \
+			AQ_NIC_FLAG_RESETTING | AQ_NIC_FLAG_CLOSING | \
+			AQ_NIC_FLAG_ERR_UNPLUG | AQ_NIC_FLAG_ERR_HW)
+
+#define AQ_NIC_FLAGS_IS_NOT_TX_READY (AQ_NIC_FLAGS_IS_NOT_READY | \
+					AQ_NIC_LINK_DOWN)
+
+#define AQ_HW_MEDIA_TYPE_TP    1U
+#define AQ_HW_MEDIA_TYPE_FIBRE 2U
+
+#define AQ_HW_TXD_MULTIPLE 8U
+#define AQ_HW_RXD_MULTIPLE 8U
+
+struct aq_hw_s {
+	atomic_t flags;
+	u8 rbl_enabled:1;
+	struct aq_nic_cfg_s *aq_nic_cfg;
+	const struct aq_fw_ops *aq_fw_ops;
+	void __iomem *mmio;
+	struct aq_hw_link_status_s aq_link_status;
+	struct hw_aq_atl_utils_mbox mbox;
+	struct hw_atl_stats_s last_stats;
+	struct aq_stats_s curr_stats;
+
+	u64 speed;
+	u32 itr_tx;
+	u32 itr_rx;
+	unsigned int chip_features;
+	u32 fw_ver_actual;
+	atomic_t dpc;
+	u32 mbox_addr;
+	u32 rpc_addr;
+	u32 rpc_tid;
+	struct hw_aq_atl_utils_fw_rpc rpc;
+};
+
+struct aq_ring_s;
+struct aq_ring_param_s;
+struct sk_buff;
+
+struct aq_hw_ops {
+
+	int (*hw_ring_tx_xmit)(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+			       unsigned int frags);
+
+	int (*hw_ring_rx_receive)(struct aq_hw_s *self,
+				  struct aq_ring_s *aq_ring);
+
+	int (*hw_ring_rx_fill)(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+			       unsigned int sw_tail_old);
+
+	int (*hw_ring_tx_head_update)(struct aq_hw_s *self,
+				      struct aq_ring_s *aq_ring);
+
+	int (*hw_set_mac_address)(struct aq_hw_s *self, u8 *mac_addr);
+
+	int (*hw_reset)(struct aq_hw_s *self);
+
+	int (*hw_init)(struct aq_hw_s *self, u8 *mac_addr);
+
+	int (*hw_start)(struct aq_hw_s *self);
+
+	int (*hw_stop)(struct aq_hw_s *self);
+
+	int (*hw_ring_tx_init)(struct aq_hw_s *self, struct aq_ring_s *aq_ring,
+			       struct aq_ring_param_s *aq_ring_param);
+
+	int (*hw_ring_tx_start)(struct aq_hw_s *self,
+				struct aq_ring_s *aq_ring);
+
+	int (*hw_ring_tx_stop)(struct aq_hw_s *self,
+			       struct aq_ring_s *aq_ring);
+
+	int (*hw_ring_rx_init)(struct aq_hw_s *self,
+			       struct aq_ring_s *aq_ring,
+			       struct aq_ring_param_s *aq_ring_param);
+
+	int (*hw_ring_rx_start)(struct aq_hw_s *self,
+				struct aq_ring_s *aq_ring);
+
+	int (*hw_ring_rx_stop)(struct aq_hw_s *self,
+			       struct aq_ring_s *aq_ring);
+
+	int (*hw_irq_enable)(struct aq_hw_s *self, u64 mask);
+
+	int (*hw_irq_disable)(struct aq_hw_s *self, u64 mask);
+
+	int (*hw_irq_read)(struct aq_hw_s *self, u64 *mask);
+
+	int (*hw_packet_filter_set)(struct aq_hw_s *self,
+				    unsigned int packet_filter);
+
+	int (*hw_multicast_list_set)(struct aq_hw_s *self,
+				     u8 ar_mac[AQ_CFG_MULTICAST_ADDRESS_MAX]
+				     [ETH_ALEN],
+				     u32 count);
+
+	int (*hw_interrupt_moderation_set)(struct aq_hw_s *self);
+
+	int (*hw_rss_set)(struct aq_hw_s *self,
+			  struct aq_rss_parameters *rss_params);
+
+	int (*hw_rss_hash_set)(struct aq_hw_s *self,
+			       struct aq_rss_parameters *rss_params);
+
+	int (*hw_get_regs)(struct aq_hw_s *self,
+			   const struct aq_hw_caps_s *aq_hw_caps,
+			   u32 *regs_buff);
+
+	struct aq_stats_s *(*hw_get_hw_stats)(struct aq_hw_s *self);
+
+	int (*hw_get_fw_version)(struct aq_hw_s *self, u32 *fw_version);
+
+};
+
+struct aq_fw_ops {
+	int (*init)(struct aq_hw_s *self);
+
+	int (*deinit)(struct aq_hw_s *self);
+
+	int (*reset)(struct aq_hw_s *self);
+
+	int (*renegotiate)(struct aq_hw_s *self);
+
+	int (*get_mac_permanent)(struct aq_hw_s *self, u8 *mac);
+
+	int (*set_link_speed)(struct aq_hw_s *self, u32 speed);
+
+	int (*set_state)(struct aq_hw_s *self,
+			enum hal_atl_utils_fw_state_e state);
+
+	int (*update_link_status)(struct aq_hw_s *self);
+
+	int (*update_stats)(struct aq_hw_s *self);
+
+	int (*set_power)(struct aq_hw_s *self, unsigned int power_state,
+			u8 *mac);
+
+	int (*get_temp)(struct aq_hw_s *self, int *temp);
+
+	int (*get_cable_len)(struct aq_hw_s *self, int *cable_len);
+
+	int (*set_eee_rate)(struct aq_hw_s *self, u32 speed);
+
+	int (*get_eee_rate)(struct aq_hw_s *self, u32 *rate,
+			u32 *supported_rates);
+
+	int (*set_flow_control)(struct aq_hw_s *self);
+};
+
+#endif /* AQ_HW_H */
diff --git a/drivers/net/ethernet/aquantia/aq_hw_utils.c b/drivers/net/ethernet/aquantia/aq_hw_utils.c
new file mode 100644
index 00000000..d526c4f
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_hw_utils.c
@@ -0,0 +1,71 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_hw_utils.c: Definitions of helper functions used across
+ * hardware layer.
+ */
+
+#include "aq_hw_utils.h"
+#include "aq_hw.h"
+#include "aq_nic.h"
+
+void aq_hw_write_reg_bit(struct aq_hw_s *aq_hw, u32 addr, u32 msk,
+			 u32 shift, u32 val)
+{
+	if (msk ^ ~0) {
+		u32 reg_old, reg_new;
+
+		reg_old = aq_hw_read_reg(aq_hw, addr);
+		reg_new = (reg_old & (~msk)) | (val << shift);
+
+		if (reg_old != reg_new)
+			aq_hw_write_reg(aq_hw, addr, reg_new);
+	} else {
+		aq_hw_write_reg(aq_hw, addr, val);
+	}
+}
+
+u32 aq_hw_read_reg_bit(struct aq_hw_s *aq_hw, u32 addr, u32 msk, u32 shift)
+{
+	return ((aq_hw_read_reg(aq_hw, addr) & msk) >> shift);
+}
+
+u32 aq_hw_read_reg(struct aq_hw_s *hw, u32 reg)
+{
+	u32 value = readl(hw->mmio + reg);
+
+	if ((~0U) == value &&
+	    (~0U) == readl(hw->mmio +
+			   hw->aq_nic_cfg->aq_hw_caps->hw_alive_check_addr))
+		aq_utils_obj_set(&hw->flags, AQ_HW_FLAG_ERR_UNPLUG);
+
+	return value;
+}
+
+void aq_hw_write_reg(struct aq_hw_s *hw, u32 reg, u32 value)
+{
+	writel(value, hw->mmio + reg);
+}
+
+int aq_hw_err_from_flags(struct aq_hw_s *hw)
+{
+	int err = 0;
+
+	if (aq_utils_obj_test(&hw->flags, AQ_HW_FLAG_ERR_UNPLUG)) {
+		err = -ENXIO;
+		goto err_exit;
+	}
+	if (aq_utils_obj_test(&hw->flags, AQ_HW_FLAG_ERR_HW)) {
+		err = -EIO;
+		goto err_exit;
+	}
+
+err_exit:
+	return err;
+}
diff --git a/drivers/net/ethernet/aquantia/aq_hw_utils.h b/drivers/net/ethernet/aquantia/aq_hw_utils.h
new file mode 100644
index 00000000..dc88a12
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_hw_utils.h
@@ -0,0 +1,50 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_hw_utils.h: Declaration of helper functions used across hardware
+ * layer.
+ */
+
+#ifndef AQ_HW_UTILS_H
+#define AQ_HW_UTILS_H
+
+#include "aq_common.h"
+
+#ifndef HIDWORD
+#define LODWORD(_qw)    ((u32)(_qw))
+#define HIDWORD(_qw)    ((u32)(((_qw) >> 32) & 0xffffffff))
+#endif
+
+#define AQ_HW_SLEEP(_US_) mdelay(_US_)
+
+#define AQ_HW_WAIT_FOR(_B_, _US_, _N_) \
+do { \
+	unsigned int AQ_HW_WAIT_FOR_i; \
+	for (AQ_HW_WAIT_FOR_i = _N_; (!(_B_)) && (AQ_HW_WAIT_FOR_i);\
+	--AQ_HW_WAIT_FOR_i) {\
+		udelay(_US_); \
+	} \
+	if (!AQ_HW_WAIT_FOR_i) {\
+		err = -ETIME; \
+	} \
+} while (0)
+
+#define aq_pr_err(...) pr_err(AQ_CFG_DRV_NAME ": " __VA_ARGS__)
+#define aq_pr_trace(...) pr_info(AQ_CFG_DRV_NAME ": " __VA_ARGS__)
+
+struct aq_hw_s;
+
+void aq_hw_write_reg_bit(struct aq_hw_s *aq_hw, u32 addr, u32 msk,
+			 u32 shift, u32 val);
+u32 aq_hw_read_reg_bit(struct aq_hw_s *aq_hw, u32 addr, u32 msk, u32 shift);
+u32 aq_hw_read_reg(struct aq_hw_s *hw, u32 reg);
+void aq_hw_write_reg(struct aq_hw_s *hw, u32 reg, u32 value);
+int aq_hw_err_from_flags(struct aq_hw_s *hw);
+
+#endif /* AQ_HW_UTILS_H */
diff --git a/drivers/net/ethernet/aquantia/aq_main.c b/drivers/net/ethernet/aquantia/aq_main.c
new file mode 100644
index 00000000..8ad57e0
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_main.c
@@ -0,0 +1,190 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_main.c: Main file for aQuantia Linux driver. */
+
+#include "aq_main.h"
+#include "aq_nic.h"
+#include "aq_pci_func.h"
+#include "aq_ethtool.h"
+#include "aq_drvinfo.h"
+
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kobject.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+#include <uapi/linux/stat.h>
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(AQ_CFG_DRV_VERSION);
+MODULE_AUTHOR(AQ_CFG_DRV_AUTHOR);
+MODULE_DESCRIPTION(AQ_CFG_DRV_DESC);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+int aq_phy_deferred_linkdown = 1;
+module_param_named(deferred_linkdown, aq_phy_deferred_linkdown, int, 0600);
+MODULE_PARM_DESC(deferred_linkdown, "Max linkdown count for lanact event");
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+
+static const struct net_device_ops aq_ndev_ops;
+
+struct net_device *aq_ndev_alloc(void)
+{
+	struct net_device *ndev = NULL;
+	struct aq_nic_s *aq_nic = NULL;
+
+	ndev = alloc_etherdev_mq(sizeof(struct aq_nic_s), AQ_CFG_VECS_MAX);
+	if (!ndev)
+		return NULL;
+
+	aq_nic = netdev_priv(ndev);
+	aq_nic->ndev = ndev;
+	ndev->netdev_ops = &aq_ndev_ops;
+	ndev->ethtool_ops = &aq_ethtool_ops;
+
+	return ndev;
+}
+
+static int aq_ndev_open(struct net_device *ndev)
+{
+	int err = 0;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	aq_sysfs_init(ndev);
+
+	err = aq_nic_init(aq_nic);
+	if (err < 0)
+		goto err_exit;
+	err = aq_nic_start(aq_nic);
+	if (err < 0)
+		goto err_exit;
+
+err_exit:
+	if (err < 0)
+		aq_nic_deinit(aq_nic);
+	return err;
+}
+
+static int aq_ndev_close(struct net_device *ndev)
+{
+	int err = 0;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	aq_sysfs_exit(ndev);
+
+
+	err = aq_nic_stop(aq_nic);
+	if (err < 0)
+		goto err_exit;
+	aq_nic_deinit(aq_nic);
+
+err_exit:
+	return err;
+}
+
+static int aq_ndev_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+
+	return aq_nic_xmit(aq_nic, skb);
+}
+
+static int aq_ndev_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = aq_nic_set_mtu(aq_nic, new_mtu + ETH_HLEN);
+
+	if (err < 0)
+		goto err_exit;
+	ndev->mtu = new_mtu;
+
+err_exit:
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+static int aq_ndev_set_features(struct net_device *ndev,
+				netdev_features_t features)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct aq_nic_cfg_s *aq_cfg = aq_nic_get_cfg(aq_nic);
+	bool is_lro = false;
+
+	if (aq_cfg->hw_features & NETIF_F_LRO) {
+		is_lro = features & NETIF_F_LRO;
+
+		if (aq_cfg->is_lro != is_lro) {
+			aq_cfg->is_lro = is_lro;
+
+			if (netif_running(ndev)) {
+				aq_ndev_close(ndev);
+				aq_ndev_open(ndev);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int aq_ndev_set_mac_address(struct net_device *ndev, void *addr)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = 0;
+
+	err = eth_mac_addr(ndev, addr);
+	if (err < 0)
+		goto err_exit;
+	err = aq_nic_set_mac(aq_nic, ndev);
+	if (err < 0)
+		goto err_exit;
+
+err_exit:
+	return err;
+}
+
+static void aq_ndev_set_multicast_settings(struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	int err = 0;
+
+	err = aq_nic_set_packet_filter(aq_nic, ndev->flags);
+	if (err < 0)
+		return;
+
+	if (netdev_mc_count(ndev)) {
+		err = aq_nic_set_multicast_list(aq_nic, ndev);
+		if (err < 0)
+			return;
+	}
+}
+
+static const struct net_device_ops aq_ndev_ops = {
+	.ndo_open = aq_ndev_open,
+	.ndo_stop = aq_ndev_close,
+	.ndo_start_xmit = aq_ndev_start_xmit,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list = aq_ndev_set_multicast_settings,
+#else
+	.ndo_set_rx_mode = aq_ndev_set_multicast_settings,
+#endif
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5))
+	.extended.ndo_change_mtu = aq_ndev_change_mtu,
+#else
+	.ndo_change_mtu = aq_ndev_change_mtu,
+#endif
+	.ndo_set_mac_address = aq_ndev_set_mac_address,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	.ndo_set_features = aq_ndev_set_features
+#endif
+};
diff --git a/drivers/net/ethernet/aquantia/aq_main.h b/drivers/net/ethernet/aquantia/aq_main.h
new file mode 100644
index 00000000..ce92152
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_main.h
@@ -0,0 +1,19 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_main.h: Main file for aQuantia Linux driver. */
+
+#ifndef AQ_MAIN_H
+#define AQ_MAIN_H
+
+#include "aq_common.h"
+
+struct net_device *aq_ndev_alloc(void);
+
+#endif /* AQ_MAIN_H */
diff --git a/drivers/net/ethernet/aquantia/aq_nic.c b/drivers/net/ethernet/aquantia/aq_nic.c
new file mode 100644
index 00000000..088db46
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_nic.c
@@ -0,0 +1,1162 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_nic.c: Definition of common code for NIC. */
+
+#include "aq_nic.h"
+#include "aq_ring.h"
+#include "aq_vec.h"
+#include "aq_hw.h"
+#include "aq_pci_func.h"
+
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/timer.h>
+#include <linux/cpu.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+#include <net/ipv6.h>
+
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include "buffalo/kernevnt.h"
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+
+static unsigned int aq_itr = AQ_CFG_INTERRUPT_MODERATION_AUTO;
+module_param_named(aq_itr, aq_itr, uint, 0644);
+MODULE_PARM_DESC(aq_itr, "Interrupt throttling mode");
+
+static unsigned int aq_itr_tx;
+module_param_named(aq_itr_tx, aq_itr_tx, uint, 0644);
+MODULE_PARM_DESC(aq_itr_tx, "TX interrupt throttle rate");
+
+static unsigned int aq_itr_rx;
+module_param_named(aq_itr_rx, aq_itr_rx, uint, 0644);
+MODULE_PARM_DESC(aq_itr_rx, "RX interrupt throttle rate");
+
+static unsigned int aq_rxpageorder = 0;
+module_param_named(aq_rxpageorder, aq_rxpageorder, uint, 0644);
+MODULE_PARM_DESC(aq_rxpageorder, "RX page order override");
+
+unsigned aq_rx_refill_thres = 32;
+module_param_named(aq_rx_refill_thres, aq_rx_refill_thres, uint, 0644);
+MODULE_PARM_DESC(aq_rx_refill_thres, "RX refill threshold");
+
+static void aq_nic_update_ndev_stats(struct aq_nic_s *self);
+
+static void aq_nic_rss_init(struct aq_nic_s *self, unsigned int num_rss_queues)
+{
+	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+	struct aq_rss_parameters *rss_params = &cfg->aq_rss;
+	int i = 0;
+
+	static u8 rss_key[40] = {
+		0x1e, 0xad, 0x71, 0x87, 0x65, 0xfc, 0x26, 0x7d,
+		0x0d, 0x45, 0x67, 0x74, 0xcd, 0x06, 0x1a, 0x18,
+		0xb6, 0xc1, 0xf0, 0xc7, 0xbb, 0x18, 0xbe, 0xf8,
+		0x19, 0x13, 0x4b, 0xa9, 0xd0, 0x3e, 0xfe, 0x70,
+		0x25, 0x03, 0xab, 0x50, 0x6a, 0x8b, 0x82, 0x0c
+	};
+
+	rss_params->hash_secret_key_size = sizeof(rss_key);
+	memcpy(rss_params->hash_secret_key, rss_key, sizeof(rss_key));
+	rss_params->indirection_table_size = AQ_CFG_RSS_INDIRECTION_TABLE_MAX;
+
+	for (i = rss_params->indirection_table_size; i--;)
+		rss_params->indirection_table[i] = i & (num_rss_queues - 1);
+}
+
+/* Checks hw_caps and 'corrects' aq_nic_cfg in runtime */
+void aq_nic_cfg_start(struct aq_nic_s *self)
+{
+	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
+
+	cfg->tcs = AQ_CFG_TCS_DEF;
+
+	cfg->is_polling = AQ_CFG_IS_POLLING_DEF;
+
+	cfg->itr = aq_itr;
+	cfg->tx_itr = aq_itr_tx;
+	cfg->rx_itr = aq_itr_rx;
+
+	cfg->rxpageorder = aq_rxpageorder;
+	cfg->is_rss = AQ_CFG_IS_RSS_DEF;
+	cfg->num_rss_queues = AQ_CFG_NUM_RSS_QUEUES_DEF;
+	cfg->aq_rss.base_cpu_number = AQ_CFG_RSS_BASE_CPU_NUM_DEF;
+	cfg->flow_control = AQ_CFG_FC_MODE;
+
+	cfg->mtu = AQ_CFG_MTU_DEF;
+	cfg->link_speed_msk = AQ_CFG_SPEED_MSK;
+	cfg->is_autoneg = AQ_CFG_IS_AUTONEG_DEF;
+
+	cfg->is_lro = AQ_CFG_IS_LRO_DEF;
+
+	cfg->vlan_id = 0U;
+
+	aq_nic_rss_init(self, cfg->num_rss_queues);
+
+	/*descriptors */
+	cfg->rxds = min(cfg->aq_hw_caps->rxds_max, AQ_CFG_RXDS_DEF);
+	cfg->txds = min(cfg->aq_hw_caps->txds_max, AQ_CFG_TXDS_DEF);
+
+	/*rss rings */
+	cfg->vecs = min(cfg->aq_hw_caps->vecs, AQ_CFG_VECS_DEF);
+	cfg->vecs = min(cfg->vecs, num_online_cpus());
+	cfg->vecs = min(cfg->vecs, self->irqvecs);
+	/* cfg->vecs should be power of 2 for RSS */
+	if (cfg->vecs >= 8U)
+		cfg->vecs = 8U;
+	else if (cfg->vecs >= 4U)
+		cfg->vecs = 4U;
+	else if (cfg->vecs >= 2U)
+		cfg->vecs = 2U;
+	else
+		cfg->vecs = 1U;
+
+	cfg->num_rss_queues = min(cfg->vecs, AQ_CFG_NUM_RSS_QUEUES_DEF);
+
+	cfg->irq_type = aq_pci_func_get_irq_type(self);
+
+	if ((cfg->irq_type == AQ_HW_IRQ_LEGACY) ||
+	    (cfg->aq_hw_caps->vecs == 1U) ||
+	    (cfg->vecs == 1U)) {
+		cfg->is_rss = 0U;
+		cfg->vecs = 1U;
+	}
+
+	cfg->link_speed_msk &= cfg->aq_hw_caps->link_speed_msk;
+	cfg->hw_features = cfg->aq_hw_caps->hw_features;
+}
+
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+extern int aq_phy_deferred_linkdown;
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+static int aq_nic_update_link_status(struct aq_nic_s *self)
+{
+	int err = self->aq_fw_ops->update_link_status(self->aq_hw);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	int new_state = 0;
+	unsigned int max_linkdown = max(aq_phy_deferred_linkdown, 1);
+	struct timespec ts;
+	unsigned long now;
+
+	ktime_get_ts(&ts);
+	now = (unsigned long)ts.tv_sec;
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+
+	if (err)
+		return err;
+
+	if (self->link_status.mbps != self->aq_hw->aq_link_status.mbps) {
+		pr_info("%s: link change old %d new %d\n",
+			AQ_CFG_DRV_NAME, self->link_status.mbps,
+			self->aq_hw->aq_link_status.mbps);
+		aq_nic_update_interrupt_moderation_settings(self);
+	}
+
+	self->link_status = self->aq_hw->aq_link_status;
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        /* prepare for called just after initialization */
+	if (self->state_cache.down_tv == ~0UL || max_linkdown <= 1) {
+		self->state_cache.down_tv = now - max_linkdown;
+	} else if (netif_carrier_ok(self->ndev)) {
+		self->state_cache.down_tv = now;
+	}
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+
+	if (!netif_carrier_ok(self->ndev) && self->link_status.mbps) {
+		aq_utils_obj_set(&self->flags,
+				 AQ_NIC_FLAG_STARTED);
+		aq_utils_obj_clear(&self->flags,
+				   AQ_NIC_LINK_DOWN);
+		netif_carrier_on(self->ndev);
+		netif_tx_wake_all_queues(self->ndev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		/* issue event when link-down count was expired */
+		new_state += (self->state_cache.link != 1);
+		new_state += (self->state_cache.speed != self->link_status.mbps);
+		self->state_cache.link = 1;
+		self->state_cache.down_tv = 0;
+		self->state_cache.speed = self->link_status.mbps;
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+	}
+	if (netif_carrier_ok(self->ndev) && !self->link_status.mbps) {
+		netif_carrier_off(self->ndev);
+		netif_tx_disable(self->ndev);
+		aq_utils_obj_set(&self->flags, AQ_NIC_LINK_DOWN);
+	}
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	if (!self->link_status.mbps) {
+		/* issue event only when link-down count was overflow */
+		if (now >= (self->state_cache.down_tv + max_linkdown)) {
+			new_state += (self->state_cache.link != 0);
+			self->state_cache.link = 0;
+		}
+	}
+	if (new_state) {
+		kernevnt_LanAct_params(self->ndev->name, self->link_status.mbps, 1);
+	}
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+	return 0;
+}
+
+static void aq_nic_service_timer_cb(struct timer_list *t)
+{
+	struct aq_nic_s *self = from_timer(self, t, service_timer);
+	int ctimer = AQ_CFG_SERVICE_TIMER_INTERVAL;
+	int err = 0;
+
+	spin_lock(&self->aq_spinlock);
+
+	if (aq_utils_obj_test(&self->flags, AQ_NIC_FLAGS_IS_NOT_READY))
+		goto err_exit;
+
+	err = aq_nic_update_link_status(self);
+	if (err)
+		goto err_exit;
+
+	if (self->aq_fw_ops->update_stats)
+		self->aq_fw_ops->update_stats(self->aq_hw);
+
+	aq_nic_update_ndev_stats(self);
+
+	/* If no link - use faster timer rate to detect link up asap */
+	if (!netif_carrier_ok(self->ndev))
+		ctimer = max(ctimer / 2, 1);
+
+err_exit:
+	spin_unlock(&self->aq_spinlock);
+	mod_timer(&self->service_timer, jiffies + ctimer);
+}
+
+static void aq_nic_polling_timer_cb(struct timer_list *t)
+{
+	struct aq_nic_s *self = from_timer(self, t, polling_timer);
+	struct aq_vec_s *aq_vec = NULL;
+	unsigned int i = 0U;
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
+		aq_vec_isr(i, (void *)aq_vec);
+
+	mod_timer(&self->polling_timer, jiffies +
+		AQ_CFG_POLLING_TIMER_INTERVAL);
+}
+
+int aq_nic_ndev_register(struct aq_nic_s *self)
+{
+	int err = 0;
+
+	if (!self->ndev) {
+		err = -EINVAL;
+		goto err_exit;
+	}
+
+	err = hw_atl_utils_initfw(self->aq_hw, &self->aq_fw_ops);
+	if (err)
+		goto err_exit;
+
+	err = self->aq_fw_ops->get_mac_permanent(self->aq_hw,
+			    self->ndev->dev_addr);
+	if (err)
+		goto err_exit;
+
+#if defined(AQ_CFG_MAC_ADDR_PERMANENT)
+	{
+		static u8 mac_addr_permanent[] = AQ_CFG_MAC_ADDR_PERMANENT;
+
+		ether_addr_copy(self->ndev->dev_addr, mac_addr_permanent);
+	}
+#endif
+
+	for (self->aq_vecs = 0; self->aq_vecs < aq_nic_get_cfg(self)->vecs;
+	     self->aq_vecs++) {
+		self->aq_vec[self->aq_vecs] =
+		    aq_vec_alloc(self, self->aq_vecs, aq_nic_get_cfg(self));
+		if (!self->aq_vec[self->aq_vecs]) {
+			err = -ENOMEM;
+			goto err_exit;
+		}
+	}
+
+	netif_carrier_off(self->ndev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	kernevnt_LanAct_params(self->ndev->name, 0, 1);
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+
+	netif_tx_disable(self->ndev);
+
+	err = register_netdev(self->ndev);
+	if (err)
+		goto err_exit;
+
+err_exit:
+	return err;
+}
+
+void aq_nic_ndev_init(struct aq_nic_s *self)
+{
+	const struct aq_hw_caps_s *aq_hw_caps = self->aq_nic_cfg.aq_hw_caps;
+	struct aq_nic_cfg_s *aq_nic_cfg = &self->aq_nic_cfg;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	self->ndev->hw_features |= aq_hw_caps->hw_features;
+#endif
+	self->ndev->features = aq_hw_caps->hw_features;
+	self->ndev->vlan_features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_SG | NETIF_F_LRO;
+	self->ndev->priv_flags = aq_hw_caps->hw_priv_flags;
+	self->ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+
+	self->ndev->mtu = aq_nic_cfg->mtu - ETH_HLEN;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	self->ndev->max_mtu = aq_hw_caps->mtu - ETH_FCS_LEN - ETH_HLEN;
+#elif (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5))
+	self->ndev->extended->min_mtu = ETH_MIN_MTU;
+	self->ndev->extended->max_mtu = aq_hw_caps->mtu - ETH_FCS_LEN - ETH_HLEN;
+#endif
+}
+
+void aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,
+			struct aq_ring_s *ring)
+{
+	self->aq_ring_tx[idx] = ring;
+}
+
+struct net_device *aq_nic_get_ndev(struct aq_nic_s *self)
+{
+	return self->ndev;
+}
+
+int aq_nic_init(struct aq_nic_s *self)
+{
+	struct aq_vec_s *aq_vec = NULL;
+	int err = 0;
+	unsigned int i = 0U;
+
+	self->power_state = AQ_HW_POWER_STATE_D0;
+	err = self->aq_hw_ops->hw_reset(self->aq_hw);
+	if (err < 0)
+		goto err_exit;
+
+	err = self->aq_hw_ops->hw_init(self->aq_hw,
+				       aq_nic_get_ndev(self)->dev_addr);
+	if (err < 0)
+		goto err_exit;
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
+		aq_vec_init(aq_vec, self->aq_hw_ops, self->aq_hw);
+
+	spin_lock_init(&self->aq_spinlock);
+
+	netif_carrier_off(self->ndev);
+
+err_exit:
+	return err;
+}
+
+int aq_nic_start(struct aq_nic_s *self)
+{
+	struct aq_vec_s *aq_vec = NULL;
+	int err = 0;
+	unsigned int i = 0U;
+
+	err = self->aq_hw_ops->hw_multicast_list_set(self->aq_hw,
+						    self->mc_list.ar,
+						    self->mc_list.count);
+	if (err < 0)
+		goto err_exit;
+
+	err = self->aq_hw_ops->hw_packet_filter_set(self->aq_hw,
+						   self->packet_filter);
+	if (err < 0)
+		goto err_exit;
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i]) {
+		err = aq_vec_start(aq_vec);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	err = self->aq_hw_ops->hw_start(self->aq_hw);
+	if (err < 0)
+		goto err_exit;
+
+	err = aq_nic_update_interrupt_moderation_settings(self);
+	if (err)
+		goto err_exit;
+	timer_setup(&self->service_timer, aq_nic_service_timer_cb, 0);
+	mod_timer(&self->service_timer, jiffies +
+			AQ_CFG_SERVICE_TIMER_INTERVAL);
+
+	if (self->aq_nic_cfg.is_polling) {
+		timer_setup(&self->polling_timer, aq_nic_polling_timer_cb, 0);
+		mod_timer(&self->polling_timer, jiffies +
+			  AQ_CFG_POLLING_TIMER_INTERVAL);
+	} else {
+		for (i = 0U, aq_vec = self->aq_vec[0];
+			self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i]) {
+			err = aq_pci_func_alloc_irq(self, i,
+						    self->ndev->name, aq_vec,
+						    aq_vec_get_affinity_mask(aq_vec));
+			if (err < 0)
+				goto err_exit;
+		}
+
+		err = self->aq_hw_ops->hw_irq_enable(self->aq_hw,
+				    AQ_CFG_IRQ_MASK);
+		if (err < 0)
+			goto err_exit;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	err = netif_set_real_num_tx_queues(self->ndev, self->aq_vecs);
+	if (err < 0)
+		goto err_exit;
+
+	err = netif_set_real_num_rx_queues(self->ndev, self->aq_vecs);
+	if (err < 0)
+		goto err_exit;
+#endif
+	netif_tx_start_all_queues(self->ndev);
+
+err_exit:
+	return err;
+}
+
+static unsigned int aq_nic_map_skb(struct aq_nic_s *self,
+				   struct sk_buff *skb,
+				   struct aq_ring_s *ring)
+{
+	unsigned int ret = 0U;
+	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+	unsigned int frag_count = 0U;
+	unsigned int dx = ring->sw_tail;
+	struct aq_ring_buff_s *first = NULL;
+	struct aq_ring_buff_s *dx_buff = &ring->buff_ring[dx];
+
+	if (unlikely(skb_is_gso(skb))) {
+		dx_buff->flags = 0U;
+		dx_buff->len_pkt = skb->len;
+		dx_buff->len_l2 = ETH_HLEN;
+		dx_buff->len_l3 = ip_hdrlen(skb);
+		dx_buff->len_l4 = tcp_hdrlen(skb);
+		dx_buff->mss = skb_shinfo(skb)->gso_size;
+		dx_buff->is_txc = 1U;
+		dx_buff->eop_index = 0xffffU;
+
+		dx_buff->is_ipv6 =
+			(ip_hdr(skb)->version == 6) ? 1U : 0U;
+
+		dx = aq_ring_next_dx(ring, dx);
+		dx_buff = &ring->buff_ring[dx];
+		++ret;
+	}
+
+	dx_buff->flags = 0U;
+	dx_buff->len = skb_headlen(skb);
+	dx_buff->pa = dma_map_single(aq_nic_get_dev(self),
+				     skb->data,
+				     dx_buff->len,
+				     DMA_TO_DEVICE);
+
+	if (unlikely(dma_mapping_error(aq_nic_get_dev(self), dx_buff->pa)))
+		goto exit;
+
+	first = dx_buff;
+	dx_buff->len_pkt = skb->len;
+	dx_buff->is_sop = 1U;
+	dx_buff->is_mapped = 1U;
+	++ret;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		dx_buff->is_ip_cso = (htons(ETH_P_IP) == skb->protocol) ?
+			1U : 0U;
+
+		if (ip_hdr(skb)->version == 4) {
+			dx_buff->is_tcp_cso =
+				(ip_hdr(skb)->protocol == IPPROTO_TCP) ?
+					1U : 0U;
+			dx_buff->is_udp_cso =
+				(ip_hdr(skb)->protocol == IPPROTO_UDP) ?
+					1U : 0U;
+		} else if (ip_hdr(skb)->version == 6) {
+			dx_buff->is_tcp_cso =
+				(ipv6_hdr(skb)->nexthdr == NEXTHDR_TCP) ?
+					1U : 0U;
+			dx_buff->is_udp_cso =
+				(ipv6_hdr(skb)->nexthdr == NEXTHDR_UDP) ?
+					1U : 0U;
+		}
+	}
+
+	for (; nr_frags--; ++frag_count) {
+		unsigned int frag_len = 0U;
+		unsigned int buff_offset = 0U;
+		unsigned int buff_size = 0U;
+		dma_addr_t frag_pa;
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[frag_count];
+
+		frag_len = skb_frag_size(frag);
+
+		while (frag_len) {
+			if (frag_len > AQ_CFG_TX_FRAME_MAX)
+				buff_size = AQ_CFG_TX_FRAME_MAX;
+			else
+				buff_size = frag_len;
+
+			frag_pa = skb_frag_dma_map(aq_nic_get_dev(self),
+						   frag,
+						   buff_offset,
+						   buff_size,
+						   DMA_TO_DEVICE);
+
+			if (unlikely(dma_mapping_error(aq_nic_get_dev(self),
+						       frag_pa)))
+				goto mapping_error;
+
+			dx = aq_ring_next_dx(ring, dx);
+			dx_buff = &ring->buff_ring[dx];
+
+			dx_buff->flags = 0U;
+			dx_buff->len = buff_size;
+			dx_buff->pa = frag_pa;
+			dx_buff->is_mapped = 1U;
+			dx_buff->eop_index = 0xffffU;
+
+			frag_len -= buff_size;
+			buff_offset += buff_size;
+
+			++ret;
+		}
+	}
+
+	first->eop_index = dx;
+	dx_buff->is_eop = 1U;
+	dx_buff->skb = skb;
+	goto exit;
+
+mapping_error:
+	for (dx = ring->sw_tail;
+	     ret > 0;
+	     --ret, dx = aq_ring_next_dx(ring, dx)) {
+		dx_buff = &ring->buff_ring[dx];
+
+		if (!dx_buff->is_txc && dx_buff->pa) {
+			if (unlikely(dx_buff->is_sop)) {
+				dma_unmap_single(aq_nic_get_dev(self),
+						 dx_buff->pa,
+						 dx_buff->len,
+						 DMA_TO_DEVICE);
+			} else {
+				dma_unmap_page(aq_nic_get_dev(self),
+					       dx_buff->pa,
+					       dx_buff->len,
+					       DMA_TO_DEVICE);
+			}
+		}
+	}
+
+exit:
+	return ret;
+}
+
+int aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int frags = 0U;
+	unsigned int vec = skb->queue_mapping % self->aq_nic_cfg.vecs;
+	unsigned int tc = 0U;
+	int err = NETDEV_TX_OK;
+
+	frags = skb_shinfo(skb)->nr_frags + 1;
+
+	ring = self->aq_ring_tx[AQ_NIC_TCVEC2RING(self, tc, vec)];
+
+	if (frags > AQ_CFG_SKB_FRAGS_MAX) {
+		dev_kfree_skb_any(skb);
+		goto err_exit;
+	}
+
+	aq_ring_update_queue_state(ring);
+
+	/* Above status update may stop the queue. Check this. */
+	if (__netif_subqueue_stopped(self->ndev, ring->idx)) {
+		err = NETDEV_TX_BUSY;
+		goto err_exit;
+	}
+
+	frags = aq_nic_map_skb(self, skb, ring);
+
+	if (likely(frags)) {
+		err = self->aq_hw_ops->hw_ring_tx_xmit(self->aq_hw,
+						       ring, frags);
+		if (err >= 0) {
+			++ring->stats.tx.packets;
+			ring->stats.tx.bytes += skb->len;
+		}
+	} else {
+		err = NETDEV_TX_BUSY;
+	}
+
+err_exit:
+	return err;
+}
+
+int aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self)
+{
+	return self->aq_hw_ops->hw_interrupt_moderation_set(self->aq_hw);
+}
+
+int aq_nic_set_packet_filter(struct aq_nic_s *self, unsigned int flags)
+{
+	int err = 0;
+
+	err = self->aq_hw_ops->hw_packet_filter_set(self->aq_hw, flags);
+	if (err < 0)
+		goto err_exit;
+
+	self->packet_filter = flags;
+
+err_exit:
+	return err;
+}
+
+int aq_nic_set_multicast_list(struct aq_nic_s *self, struct net_device *ndev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+	struct netdev_hw_addr *ha = NULL;
+#else
+	struct dev_addr_list *ha = NULL;
+#endif
+	unsigned int i = 0U;
+
+	self->mc_list.count = 0U;
+	netdev_for_each_mc_addr(ha, ndev) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+		ether_addr_copy(self->mc_list.ar[i++], ha->addr);
+#else
+		ether_addr_copy(self->mc_list.ar[i++], ha->da_addr);
+#endif
+		++self->mc_list.count;
+
+		if (i >= AQ_CFG_MULTICAST_ADDRESS_MAX)
+			break;
+	}
+
+	if (i >= AQ_CFG_MULTICAST_ADDRESS_MAX) {
+		/* Number of filters is too big: atlantic does not support this.
+		 * Force all multi filter to support this.
+		 * With this we disable all UC filters and setup "all pass"
+		 * multicast mask
+		 */
+		self->packet_filter |= IFF_ALLMULTI;
+		self->aq_nic_cfg.mc_list_count = 0;
+		return self->aq_hw_ops->hw_packet_filter_set(self->aq_hw,
+							     self->packet_filter);
+	} else {
+		return self->aq_hw_ops->hw_multicast_list_set(self->aq_hw,
+						    self->mc_list.ar,
+						    self->mc_list.count);
+	}
+}
+
+int aq_nic_set_mtu(struct aq_nic_s *self, int new_mtu)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	if (new_mtu < ETH_MIN_MTU+ETH_HLEN ||
+	    new_mtu > self->aq_nic_cfg.aq_hw_caps->mtu - ETH_FCS_LEN)
+		return -EINVAL;
+#endif
+	self->aq_nic_cfg.mtu = new_mtu;
+
+	return 0;
+}
+
+int aq_nic_set_mac(struct aq_nic_s *self, struct net_device *ndev)
+{
+	return self->aq_hw_ops->hw_set_mac_address(self->aq_hw, ndev->dev_addr);
+}
+
+unsigned int aq_nic_get_link_speed(struct aq_nic_s *self)
+{
+	return self->link_status.mbps;
+}
+
+int aq_nic_get_regs(struct aq_nic_s *self, struct ethtool_regs *regs, void *p)
+{
+	u32 *regs_buff = p;
+	int err = 0;
+
+	regs->version = 1;
+
+	err = self->aq_hw_ops->hw_get_regs(self->aq_hw,
+					   self->aq_nic_cfg.aq_hw_caps,
+					   regs_buff);
+	if (err < 0)
+		goto err_exit;
+
+err_exit:
+	return err;
+}
+
+int aq_nic_get_regs_count(struct aq_nic_s *self)
+{
+	return self->aq_nic_cfg.aq_hw_caps->mac_regs_count;
+}
+
+void aq_nic_get_stats(struct aq_nic_s *self, u64 *data)
+{
+	unsigned int i = 0U;
+	unsigned int count = 0U;
+	struct aq_vec_s *aq_vec = NULL;
+	struct aq_stats_s *stats = self->aq_hw_ops->hw_get_hw_stats(self->aq_hw);
+
+	if (!stats)
+		goto err_exit;
+
+	data[i] = stats->uprc + stats->mprc + stats->bprc;
+	data[++i] = stats->uprc;
+	data[++i] = stats->mprc;
+	data[++i] = stats->bprc;
+	data[++i] = stats->erpt;
+	data[++i] = stats->uptc + stats->mptc + stats->bptc;
+	data[++i] = stats->uptc;
+	data[++i] = stats->mptc;
+	data[++i] = stats->bptc;
+	data[++i] = stats->ubrc;
+	data[++i] = stats->ubtc;
+	data[++i] = stats->mbrc;
+	data[++i] = stats->mbtc;
+	data[++i] = stats->bbrc;
+	data[++i] = stats->bbtc;
+	data[++i] = stats->ubrc + stats->mbrc + stats->bbrc;
+	data[++i] = stats->ubtc + stats->mbtc + stats->bbtc;
+	data[++i] = stats->dma_pkt_rc;
+	data[++i] = stats->dma_pkt_tc;
+	data[++i] = stats->dma_oct_rc;
+	data[++i] = stats->dma_oct_tc;
+	data[++i] = stats->dpc;
+
+	i++;
+
+	data += i;
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		aq_vec && self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i]) {
+		data += count;
+		aq_vec_get_sw_stats(aq_vec, data, &count);
+	}
+
+err_exit:;
+}
+
+static void aq_nic_update_ndev_stats(struct aq_nic_s *self)
+{
+	struct net_device *ndev = self->ndev;
+	struct aq_stats_s *stats = self->aq_hw_ops->hw_get_hw_stats(self->aq_hw);
+
+	ndev->stats.rx_packets = stats->uprc + stats->mprc + stats->bprc;
+	ndev->stats.rx_bytes = stats->ubrc + stats->mbrc + stats->bbrc;
+	ndev->stats.rx_errors = stats->erpr;
+	ndev->stats.tx_packets = stats->uptc + stats->mptc + stats->bptc;
+	ndev->stats.tx_bytes = stats->ubtc + stats->mbtc + stats->bbtc;
+	ndev->stats.tx_errors = stats->erpt;
+	ndev->stats.multicast = stats->mprc;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+void aq_nic_get_link_ksettings(struct aq_nic_s *self,
+			       struct ethtool_link_ksettings *cmd)
+{
+	if (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		cmd->base.port = PORT_FIBRE;
+	else
+		cmd->base.port = PORT_TP;
+	/* This driver supports only 10G capable adapters, so DUPLEX_FULL */
+	cmd->base.duplex = DUPLEX_FULL;
+	cmd->base.autoneg = self->aq_nic_cfg.is_autoneg;
+
+	ethtool_link_ksettings_zero_link_mode(cmd, supported);
+
+	if (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_10G)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     10000baseT_Full);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+	if (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_5G)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     5000baseT_Full);
+
+	if (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_2GS)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     2500baseT_Full);
+#endif
+	if (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_1G)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     1000baseT_Full);
+
+	if (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_100M)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     100baseT_Full);
+
+	if (self->aq_nic_cfg.aq_hw_caps->flow_control)
+		ethtool_link_ksettings_add_link_mode(cmd, supported,
+						     Pause);
+
+	ethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);
+
+	if (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		ethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);
+	else
+		ethtool_link_ksettings_add_link_mode(cmd, supported, TP);
+
+	ethtool_link_ksettings_zero_link_mode(cmd, advertising);
+
+	if (self->aq_nic_cfg.is_autoneg)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);
+
+	if (self->aq_nic_cfg.link_speed_msk  & AQ_NIC_RATE_10G)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     10000baseT_Full);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)
+	if (self->aq_nic_cfg.link_speed_msk  & AQ_NIC_RATE_5G)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     5000baseT_Full);
+
+	if (self->aq_nic_cfg.link_speed_msk  & AQ_NIC_RATE_2GS)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     2500baseT_Full);
+#endif
+	if (self->aq_nic_cfg.link_speed_msk  & AQ_NIC_RATE_1G)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     1000baseT_Full);
+
+	if (self->aq_nic_cfg.link_speed_msk  & AQ_NIC_RATE_100M)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     100baseT_Full);
+
+	if (self->aq_nic_cfg.flow_control & AQ_NIC_FC_RX)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     Pause);
+
+	if (self->aq_nic_cfg.flow_control & AQ_NIC_FC_TX)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising,
+						     Asym_Pause);
+
+	if (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		ethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);
+	else
+		ethtool_link_ksettings_add_link_mode(cmd, advertising, TP);
+}
+
+int aq_nic_set_link_ksettings(struct aq_nic_s *self,
+			      const struct ethtool_link_ksettings *cmd)
+{
+	u32 speed = 0U;
+	u32 rate = 0U;
+	int err = 0;
+
+	if (cmd->base.autoneg == AUTONEG_ENABLE) {
+		rate = self->aq_nic_cfg.aq_hw_caps->link_speed_msk;
+		self->aq_nic_cfg.is_autoneg = true;
+	} else {
+		speed = cmd->base.speed;
+
+		switch (speed) {
+		case SPEED_100:
+			rate = AQ_NIC_RATE_100M;
+			break;
+
+		case SPEED_1000:
+			rate = AQ_NIC_RATE_1G;
+			break;
+
+		case SPEED_2500:
+			rate = AQ_NIC_RATE_2GS;
+			break;
+
+		case SPEED_5000:
+			rate = AQ_NIC_RATE_5G;
+			break;
+
+		case SPEED_10000:
+			rate = AQ_NIC_RATE_10G;
+			break;
+
+		default:
+			err = -1;
+			goto err_exit;
+		break;
+		}
+		if (!(self->aq_nic_cfg.aq_hw_caps->link_speed_msk & rate)) {
+			err = -1;
+			goto err_exit;
+		}
+
+		self->aq_nic_cfg.is_autoneg = false;
+	}
+
+	err = self->aq_fw_ops->set_link_speed(self->aq_hw, rate);
+	if (err < 0)
+		goto err_exit;
+
+	self->aq_nic_cfg.link_speed_msk = rate;
+
+err_exit:
+	return err;
+}
+#else
+void aq_nic_get_link_settings(struct aq_nic_s *self, struct ethtool_cmd *cmd)
+{
+	const struct aq_hw_caps_s *hw_caps = self->aq_nic_cfg.aq_hw_caps;
+
+	if (hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		cmd->port = PORT_FIBRE;
+	else
+		cmd->port = PORT_TP;
+	cmd->transceiver = XCVR_EXTERNAL;
+	/* This driver supports only 10G capable adapters, so DUPLEX_FULL */
+	cmd->duplex = DUPLEX_FULL;
+	cmd->autoneg = self->aq_nic_cfg.is_autoneg;
+
+
+	cmd->supported |= (hw_caps->link_speed_msk & AQ_NIC_RATE_10G) ?
+				ADVERTISED_10000baseT_Full : 0U;
+	cmd->supported |= (hw_caps->link_speed_msk & AQ_NIC_RATE_1G) ?
+				ADVERTISED_1000baseT_Full : 0U;
+	cmd->supported |= (hw_caps->link_speed_msk & AQ_NIC_RATE_100M) ?
+				ADVERTISED_100baseT_Full : 0U;
+	cmd->supported |= hw_caps->flow_control ? SUPPORTED_Pause : 0;
+	cmd->supported |= SUPPORTED_Autoneg;
+
+	if (hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		cmd->supported |= SUPPORTED_FIBRE;
+	else
+		cmd->supported |= SUPPORTED_TP;
+
+	cmd->advertising = (self->aq_nic_cfg.is_autoneg) ?
+							ADVERTISED_Autoneg : 0U;
+	cmd->advertising |=
+			(self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_10G) ?
+			ADVERTISED_10000baseT_Full : 0U;
+	cmd->advertising |=
+			(self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_1G) ?
+			ADVERTISED_1000baseT_Full : 0U;
+
+	cmd->advertising |=
+			(self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_100M) ?
+			ADVERTISED_100baseT_Full : 0U;
+	cmd->advertising |= (self->aq_nic_cfg.flow_control) ?
+				ADVERTISED_Pause : 0U;
+
+	if (hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)
+		cmd->advertising |= ADVERTISED_FIBRE;
+	else
+		cmd->advertising |= ADVERTISED_TP;
+}
+
+int aq_nic_set_link_settings(struct aq_nic_s *self, struct ethtool_cmd *cmd)
+{
+	u32 speed = 0U;
+	u32 rate = 0U;
+	int err = 0;
+
+	if (cmd->autoneg == AUTONEG_ENABLE) {
+		rate = self->aq_nic_cfg.aq_hw_caps->link_speed_msk;
+		self->aq_nic_cfg.is_autoneg = true;
+	} else {
+		speed = ethtool_cmd_speed(cmd);
+
+		switch (speed) {
+		case SPEED_100:
+			rate = AQ_NIC_RATE_100M;
+			break;
+
+		case SPEED_1000:
+			rate = AQ_NIC_RATE_1G;
+			break;
+
+		case SPEED_2500:
+			rate = AQ_NIC_RATE_2GS;
+			break;
+
+		case SPEED_5000:
+			rate = AQ_NIC_RATE_5G;
+			break;
+
+		case SPEED_10000:
+			rate = AQ_NIC_RATE_10G;
+			break;
+
+		default:
+			err = -1;
+			goto err_exit;
+		break;
+		}
+
+		if (!(self->aq_nic_cfg.aq_hw_caps->link_speed_msk & rate)) {
+			err = -1;
+			goto err_exit;
+		}
+
+		self->aq_nic_cfg.is_autoneg = false;
+	}
+
+	err = self->aq_fw_ops->set_link_speed(self->aq_hw, rate);
+	if (err < 0)
+		goto err_exit;
+
+	self->aq_nic_cfg.link_speed_msk = rate;
+
+err_exit:
+	return err;
+}
+
+#endif
+
+struct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self)
+{
+	return &self->aq_nic_cfg;
+}
+
+u32 aq_nic_get_fw_version(struct aq_nic_s *self)
+{
+	u32 fw_version = 0U;
+
+	self->aq_hw_ops->hw_get_fw_version(self->aq_hw, &fw_version);
+
+	return fw_version;
+}
+
+int aq_nic_stop(struct aq_nic_s *self)
+{
+	struct aq_vec_s *aq_vec = NULL;
+	unsigned int i = 0U;
+
+	netif_tx_disable(self->ndev);
+	netif_carrier_off(self->ndev);
+
+	del_timer_sync(&self->service_timer);
+
+	self->aq_hw_ops->hw_irq_disable(self->aq_hw, AQ_CFG_IRQ_MASK);
+
+	if (self->aq_nic_cfg.is_polling)
+		del_timer_sync(&self->polling_timer);
+	else
+		aq_pci_func_free_irqs(self);
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
+		aq_vec_stop(aq_vec);
+
+	return self->aq_hw_ops->hw_stop(self->aq_hw);
+}
+
+void aq_nic_deinit(struct aq_nic_s *self)
+{
+	struct aq_vec_s *aq_vec = NULL;
+	unsigned int i = 0U;
+
+	if (!self)
+		goto err_exit;
+
+	for (i = 0U, aq_vec = self->aq_vec[0];
+		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
+		aq_vec_deinit(aq_vec);
+
+	(void)self->aq_fw_ops->deinit(self->aq_hw);
+
+	if (self->power_state != AQ_HW_POWER_STATE_D0 ||
+	    self->aq_hw->aq_nic_cfg->wol) {
+		(void)self->aq_fw_ops->set_power(self->aq_hw,
+			self->power_state, self->ndev->dev_addr);
+	}
+
+err_exit:;
+}
+
+void aq_nic_free_vectors(struct aq_nic_s *self)
+{
+	unsigned int i = 0U;
+
+	if (!self)
+		goto err_exit;
+
+	for (i = ARRAY_SIZE(self->aq_vec); i--;) {
+		if (self->aq_vec[i]) {
+			aq_vec_free(self->aq_vec[i]);
+			self->aq_vec[i] = NULL;
+		}
+	}
+
+err_exit:;
+}
+
+int aq_nic_change_pm_state(struct aq_nic_s *self, pm_message_t *pm_msg)
+{
+	int err = 0;
+
+	if (!netif_running(self->ndev)) {
+		err = 0;
+		goto out;
+	}
+	rtnl_lock();
+	if (pm_msg->event & PM_EVENT_SLEEP || pm_msg->event & PM_EVENT_FREEZE) {
+		self->power_state = AQ_HW_POWER_STATE_D3;
+		netif_device_detach(self->ndev);
+		netif_tx_stop_all_queues(self->ndev);
+
+		err = aq_nic_stop(self);
+		if (err < 0)
+			goto err_exit;
+
+		aq_nic_deinit(self);
+	} else {
+		err = aq_nic_init(self);
+		if (err < 0)
+			goto err_exit;
+
+		err = aq_nic_start(self);
+		if (err < 0)
+			goto err_exit;
+
+		netif_device_attach(self->ndev);
+		netif_tx_start_all_queues(self->ndev);
+	}
+
+err_exit:
+	rtnl_unlock();
+out:
+	return err;
+}
+
+void aq_nic_shutdown(struct aq_nic_s *self)
+{
+	int err = 0;
+
+	if (!self->ndev)
+		return;
+
+	rtnl_lock();
+
+	netif_device_detach(self->ndev);
+
+	if (netif_running(self->ndev)) {
+		err = aq_nic_stop(self);
+		if (err < 0)
+			goto err_exit;
+	}
+	aq_nic_deinit(self);
+
+err_exit:
+	rtnl_unlock();
+}
diff --git a/drivers/net/ethernet/aquantia/aq_nic.h b/drivers/net/ethernet/aquantia/aq_nic.h
new file mode 100644
index 00000000..0e19d12
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_nic.h
@@ -0,0 +1,152 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_nic.h: Declaration of common code for NIC. */
+
+#ifndef AQ_NIC_H
+#define AQ_NIC_H
+
+#include "aq_common.h"
+#include "aq_rss.h"
+#include "aq_hw.h"
+
+struct aq_ring_s;
+struct aq_hw_ops;
+struct aq_fw_s;
+struct aq_vec_s;
+
+struct aq_nic_cfg_s {
+	const struct aq_hw_caps_s *aq_hw_caps;
+	u64 hw_features;
+	u32 rxds;		/* rx ring size, descriptors # */
+	u32 txds;		/* tx ring size, descriptors # */
+	u32 vecs;		/* vecs==allocated irqs */
+	u32 irq_type;
+	u32 itr;
+	u16 rx_itr;
+	u16 tx_itr;
+	u32 rxpageorder;
+	u32 num_rss_queues;
+	u32 mtu;
+	u32 flow_control;
+	u32 link_speed_msk;
+	u32 vlan_id;
+	u32 wol;
+	u16 is_mc_list_enabled;
+	u16 mc_list_count;
+	bool is_autoneg;
+	bool is_polling;
+	bool is_rss;
+	bool is_lro;
+	u8  tcs;
+	struct aq_rss_parameters aq_rss;
+	u32 eee_enabled;
+};
+
+#define AQ_NIC_FLAG_STARTED     0x00000004U
+#define AQ_NIC_FLAG_STOPPING    0x00000008U
+#define AQ_NIC_FLAG_RESETTING   0x00000010U
+#define AQ_NIC_FLAG_CLOSING     0x00000020U
+#define AQ_NIC_LINK_DOWN        0x04000000U
+#define AQ_NIC_FLAG_ERR_UNPLUG  0x40000000U
+#define AQ_NIC_FLAG_ERR_HW      0x80000000U
+
+
+#define AQ_NIC_WOL_ENABLED           BIT(0)
+
+
+#define AQ_NIC_TCVEC2RING(_NIC_, _TC_, _VEC_) \
+	((_TC_) * AQ_CFG_TCS_MAX + (_VEC_))
+
+
+struct aq_nic_s {
+	atomic_t flags;
+	struct aq_vec_s *aq_vec[AQ_CFG_VECS_MAX];
+	struct aq_ring_s *aq_ring_tx[AQ_CFG_VECS_MAX * AQ_CFG_TCS_MAX];
+	struct aq_hw_s *aq_hw;
+	struct net_device *ndev;
+	unsigned int aq_vecs;
+	unsigned int packet_filter;
+	unsigned int power_state;
+	u8 port;
+	const struct aq_hw_ops *aq_hw_ops;
+	const struct aq_fw_ops *aq_fw_ops;
+	struct aq_nic_cfg_s aq_nic_cfg;
+	struct timer_list service_timer;
+	struct timer_list polling_timer;
+	struct aq_hw_link_status_s link_status;
+	struct {
+		u32 count;
+		u8 ar[AQ_CFG_MULTICAST_ADDRESS_MAX][ETH_ALEN];
+	} mc_list;
+
+	struct pci_dev *pdev;
+	unsigned int msix_entry_mask;
+	u32 irqvecs;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	unsigned int irq_type;
+	struct msix_entry msix_entry[AQ_CFG_PCI_FUNC_MSIX_IRQS];
+#endif
+	spinlock_t aq_spinlock;
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	struct {
+		int speed;
+		unsigned int link;
+		unsigned long down_tv;
+	} state_cache;
+#endif /* CONFIG_BUFFALO_USE_KERNEVNT */
+};
+
+static inline struct device *aq_nic_get_dev(struct aq_nic_s *self)
+{
+	return self->ndev->dev.parent;
+}
+
+extern unsigned aq_rx_refill_thres;
+
+void aq_nic_ndev_init(struct aq_nic_s *self);
+struct aq_nic_s *aq_nic_alloc_hot(struct net_device *ndev);
+void aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,
+			struct aq_ring_s *ring);
+struct net_device *aq_nic_get_ndev(struct aq_nic_s *self);
+int aq_nic_init(struct aq_nic_s *self);
+void aq_nic_cfg_start(struct aq_nic_s *self);
+int aq_nic_ndev_register(struct aq_nic_s *self);
+void aq_nic_ndev_free(struct aq_nic_s *self);
+int aq_nic_start(struct aq_nic_s *self);
+int aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb);
+int aq_nic_get_regs(struct aq_nic_s *self, struct ethtool_regs *regs, void *p);
+int aq_nic_get_regs_count(struct aq_nic_s *self);
+void aq_nic_get_stats(struct aq_nic_s *self, u64 *data);
+int aq_nic_stop(struct aq_nic_s *self);
+void aq_nic_deinit(struct aq_nic_s *self);
+void aq_nic_free_hot_resources(struct aq_nic_s *self);
+void aq_nic_free_vectors(struct aq_nic_s *self);
+int aq_nic_set_mtu(struct aq_nic_s *self, int new_mtu);
+int aq_nic_set_mac(struct aq_nic_s *self, struct net_device *ndev);
+int aq_nic_set_packet_filter(struct aq_nic_s *self, unsigned int flags);
+int aq_nic_set_multicast_list(struct aq_nic_s *self, struct net_device *ndev);
+unsigned int aq_nic_get_link_speed(struct aq_nic_s *self);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+void aq_nic_get_link_ksettings(struct aq_nic_s *self,
+			       struct ethtool_link_ksettings *cmd);
+int aq_nic_set_link_ksettings(struct aq_nic_s *self,
+			      const struct ethtool_link_ksettings *cmd);
+#else
+void aq_nic_get_link_settings(struct aq_nic_s *self, struct ethtool_cmd *cmd);
+int aq_nic_set_link_settings(struct aq_nic_s *self, struct ethtool_cmd *cmd);
+#endif
+struct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self);
+u32 aq_nic_get_fw_version(struct aq_nic_s *self);
+int aq_nic_change_pm_state(struct aq_nic_s *self, pm_message_t *pm_msg);
+int aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self);
+void aq_nic_shutdown(struct aq_nic_s *self);
+
+#endif /* AQ_NIC_H */
diff --git a/drivers/net/ethernet/aquantia/aq_pci_func.c b/drivers/net/ethernet/aquantia/aq_pci_func.c
new file mode 100644
index 00000000..a454dbd
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_pci_func.c
@@ -0,0 +1,445 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_pci_func.c: Definition of PCI functions. */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include "aq_main.h"
+#include "aq_nic.h"
+#include "aq_vec.h"
+#include "aq_hw.h"
+#include "aq_pci_func.h"
+#include "hw_atl/hw_atl_a0.h"
+#include "hw_atl/hw_atl_b0.h"
+
+static const struct pci_device_id aq_pci_tbl[] = {
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_0001), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D100), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D107), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D108), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D109), },
+
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112), },
+
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100S), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107S), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108S), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109S), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111S), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112S), },
+
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111E), },
+	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112E), },
+
+	{}
+};
+
+static const struct aq_board_revision_s hw_atl_boards[] = {
+	{ AQ_DEVICE_ID_0001,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+	{ AQ_DEVICE_ID_D100,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc100, },
+	{ AQ_DEVICE_ID_D107,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+	{ AQ_DEVICE_ID_D108,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc108, },
+	{ AQ_DEVICE_ID_D109,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc109, },
+
+	{ AQ_DEVICE_ID_0001,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+	{ AQ_DEVICE_ID_D100,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc100, },
+	{ AQ_DEVICE_ID_D107,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+	{ AQ_DEVICE_ID_D108,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc108, },
+	{ AQ_DEVICE_ID_D109,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc109, },
+
+	{ AQ_DEVICE_ID_AQC100,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+	{ AQ_DEVICE_ID_AQC107,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+	{ AQ_DEVICE_ID_AQC108,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108, },
+	{ AQ_DEVICE_ID_AQC109,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109, },
+	{ AQ_DEVICE_ID_AQC111,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111, },
+	{ AQ_DEVICE_ID_AQC112,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112, },
+
+	{ AQ_DEVICE_ID_AQC100S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc100s, },
+	{ AQ_DEVICE_ID_AQC107S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107s, },
+	{ AQ_DEVICE_ID_AQC108S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108s, },
+	{ AQ_DEVICE_ID_AQC109S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109s, },
+	{ AQ_DEVICE_ID_AQC111S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111s, },
+	{ AQ_DEVICE_ID_AQC112S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112s, },
+
+	{ AQ_DEVICE_ID_AQC111E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111e, },
+	{ AQ_DEVICE_ID_AQC112E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112e, },
+};
+
+MODULE_DEVICE_TABLE(pci, aq_pci_tbl);
+
+static int aq_pci_probe_get_hw_by_id(struct pci_dev *pdev,
+				     const struct aq_hw_ops **ops,
+				     const struct aq_hw_caps_s **caps)
+{
+	int i = 0;
+
+	if (pdev->vendor != PCI_VENDOR_ID_AQUANTIA)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(hw_atl_boards); i++) {
+		if (hw_atl_boards[i].devid == pdev->device &&
+		    (hw_atl_boards[i].revision == AQ_HWREV_ANY ||
+		     hw_atl_boards[i].revision == pdev->revision)) {
+			*ops = hw_atl_boards[i].ops;
+			*caps = hw_atl_boards[i].caps;
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(hw_atl_boards))
+		return -EINVAL;
+
+	return 0;
+}
+
+int aq_pci_func_init(struct pci_dev *pdev)
+{
+	int err = 0;
+
+	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
+	if (!err) {
+		err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+
+	}
+	if (err) {
+		err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+		if (!err)
+			err = pci_set_consistent_dma_mask(pdev,
+							  DMA_BIT_MASK(32));
+	}
+	if (err != 0) {
+		err = -ENOSR;
+		goto err_exit;
+	}
+
+	err = pci_request_regions(pdev, AQ_CFG_DRV_NAME "_mmio");
+	if (err < 0)
+		goto err_exit;
+
+	pci_set_master(pdev);
+
+	return 0;
+
+err_exit:
+	return err;
+}
+
+int aq_pci_func_alloc_irq(struct aq_nic_s *self, unsigned int i,
+			  char *name, void *aq_vec, cpumask_t *affinity_mask)
+{
+	struct pci_dev *pdev = self->pdev;
+	int err = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	if (pdev->msix_enabled)
+		err = request_irq(self->msix_entry[i].vector, aq_vec_isr, 0,
+				  name, aq_vec);
+	else if (pdev->msi_enabled)
+		err = request_irq(pdev->irq, aq_vec_isr, 0,
+				  name, aq_vec);
+	else
+		err = request_irq(pdev->irq, aq_vec_isr_legacy,
+				  IRQF_SHARED, name, aq_vec);
+
+	if (err >= 0) {
+		self->msix_entry_mask |= (1 << i);
+		self->aq_vec[i] = aq_vec;
+
+		if (pdev->msix_enabled)
+			irq_set_affinity_hint(self->msix_entry[i].vector,
+					      affinity_mask);
+	}
+#else
+	if (pdev->msix_enabled || pdev->msi_enabled)
+		err = request_irq(pci_irq_vector(pdev, i), aq_vec_isr, 0,
+				  name, aq_vec);
+	else
+		err = request_irq(pci_irq_vector(pdev, i), aq_vec_isr_legacy,
+				  IRQF_SHARED, name, aq_vec);
+
+	if (err >= 0) {
+		self->msix_entry_mask |= (1 << i);
+		self->aq_vec[i] = aq_vec;
+
+		if (pdev->msix_enabled)
+			irq_set_affinity_hint(pci_irq_vector(pdev, i),
+					      affinity_mask);
+	}
+#endif
+	return err;
+}
+
+void aq_pci_func_free_irqs(struct aq_nic_s *self)
+{
+	struct pci_dev *pdev = self->pdev;
+	unsigned int i = 0U;
+
+	for (i = 32U; i--;) {
+		if (!((1U << i) & self->msix_entry_mask))
+			continue;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+		switch (aq_pci_func_get_irq_type(self)) {
+		case AQ_HW_IRQ_MSIX:
+			irq_set_affinity_hint(self->msix_entry[i].vector, NULL);
+			free_irq(self->msix_entry[i].vector, self->aq_vec[i]);
+			break;
+
+		case AQ_HW_IRQ_MSI:
+			free_irq(pdev->irq, self->aq_vec[i]);
+			break;
+
+		case AQ_HW_IRQ_LEGACY:
+			free_irq(pdev->irq, self->aq_vec[i]);
+			break;
+
+		default:
+			break;
+		}
+
+#else
+		if (pdev->msix_enabled)
+			irq_set_affinity_hint(pci_irq_vector(pdev, i), NULL);
+		free_irq(pci_irq_vector(pdev, i), self->aq_vec[i]);
+#endif
+		self->msix_entry_mask &= ~(1U << i);
+	}
+}
+
+unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)
+{
+	if (self->pdev->msix_enabled)
+		return AQ_HW_IRQ_MSIX;
+	if (self->pdev->msi_enabled)
+		return AQ_HW_IRQ_MSIX;
+	return AQ_HW_IRQ_LEGACY;
+}
+
+static void aq_pci_free_irq_vectors(struct aq_nic_s *self)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+
+	switch (aq_pci_func_get_irq_type(self)) {
+	case AQ_HW_IRQ_MSI:
+		pci_disable_msi(self->pdev);
+		break;
+
+	case AQ_HW_IRQ_MSIX:
+		pci_disable_msix(self->pdev);
+		break;
+
+	case AQ_HW_IRQ_LEGACY:
+		break;
+
+	default:
+		break;
+	}
+
+#else
+	pci_free_irq_vectors(self->pdev);
+
+#endif
+}
+
+static int aq_pci_probe(struct pci_dev *pdev,
+			const struct pci_device_id *pci_id)
+{
+	struct aq_nic_s *self = NULL;
+	int err = 0;
+	struct net_device *ndev;
+	resource_size_t mmio_pa;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	unsigned int i = 0U;
+#endif
+	u32 bar;
+	u32 numvecs;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	err = aq_pci_func_init(pdev);
+	if (err)
+		goto err_pci_func;
+
+	ndev = aq_ndev_alloc();
+	if (!ndev) {
+		err = -ENOMEM;
+		goto err_ndev;
+	}
+
+	self = netdev_priv(ndev);
+	self->pdev = pdev;
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	pci_set_drvdata(pdev, self);
+
+	err = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,
+					&aq_nic_get_cfg(self)->aq_hw_caps);
+	if (err)
+		goto err_ioremap;
+
+	self->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);
+	if (!self->aq_hw) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+	self->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);
+
+	for (bar = 0; bar < 4; ++bar) {
+		if (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {
+			resource_size_t reg_sz;
+
+			mmio_pa = pci_resource_start(pdev, bar);
+			if (mmio_pa == 0U) {
+				err = -EIO;
+				goto err_free_aq_hw;
+			}
+
+			reg_sz = pci_resource_len(pdev, bar);
+			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
+				err = -EIO;
+				goto err_free_aq_hw;
+			}
+
+			self->aq_hw->mmio = ioremap_nocache(mmio_pa, reg_sz);
+			if (!self->aq_hw->mmio) {
+				err = -EIO;
+				goto err_free_aq_hw;
+			}
+			break;
+		}
+	}
+
+	if (bar == 4) {
+		err = -EIO;
+		goto err_free_aq_hw;
+	}
+
+	numvecs = min((u8)AQ_CFG_VECS_DEF,
+		      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);
+	numvecs = min(numvecs, num_online_cpus());
+	/*enable interrupts */
+#if !AQ_CFG_FORCE_LEGACY_INT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	for (i = 0; i < numvecs; i++)
+		self->msix_entry[i].entry = i;
+
+	err = pci_enable_msix(self->pdev, self->msix_entry, numvecs);
+
+	if (err < 0) {
+		err = pci_enable_msi(self->pdev);
+
+		if (err < 0)
+			goto err_hwinit;
+	}
+#else
+	numvecs = pci_alloc_irq_vectors(self->pdev, 1, numvecs,
+					PCI_IRQ_MSIX | PCI_IRQ_MSI |
+					PCI_IRQ_LEGACY);
+
+	if (numvecs < 0) {
+		err = numvecs;
+		goto err_hwinit;
+	}
+#endif
+#endif
+	self->irqvecs = numvecs;
+
+	/* net device init */
+	aq_nic_cfg_start(self);
+
+	aq_nic_ndev_init(self);
+
+	err = aq_nic_ndev_register(self);
+	if (err < 0)
+		goto err_register;
+
+	return 0;
+
+err_register:
+	aq_nic_free_vectors(self);
+	aq_pci_free_irq_vectors(self);
+err_hwinit:
+	iounmap(self->aq_hw->mmio);
+err_free_aq_hw:
+	kfree(self->aq_hw);
+err_ioremap:
+	free_netdev(ndev);
+err_ndev:
+	pci_release_regions(pdev);
+err_pci_func:
+	pci_disable_device(pdev);
+	return err;
+}
+
+static void aq_pci_remove(struct pci_dev *pdev)
+{
+	struct aq_nic_s *self = pci_get_drvdata(pdev);
+
+	if (self->ndev) {
+		if (self->ndev->reg_state == NETREG_REGISTERED)
+			unregister_netdev(self->ndev);
+		aq_nic_free_vectors(self);
+		aq_pci_free_irq_vectors(self);
+		iounmap(self->aq_hw->mmio);
+		kfree(self->aq_hw);
+		pci_release_regions(pdev);
+		free_netdev(self->ndev);
+	}
+
+	pci_disable_device(pdev);
+}
+
+static void aq_pci_shutdown(struct pci_dev *pdev)
+{
+	struct aq_nic_s *self = pci_get_drvdata(pdev);
+
+	aq_nic_shutdown(self);
+
+	pci_disable_device(pdev);
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		pci_wake_from_d3(pdev, !!self->aq_nic_cfg.wol);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
+}
+
+static int aq_pci_suspend(struct pci_dev *pdev, pm_message_t pm_msg)
+{
+	struct aq_nic_s *self = pci_get_drvdata(pdev);
+
+	return aq_nic_change_pm_state(self, &pm_msg);
+}
+
+static int aq_pci_resume(struct pci_dev *pdev)
+{
+	struct aq_nic_s *self = pci_get_drvdata(pdev);
+	pm_message_t pm_msg = PMSG_RESTORE;
+
+	return aq_nic_change_pm_state(self, &pm_msg);
+}
+
+static struct pci_driver aq_pci_ops = {
+	.name = AQ_CFG_DRV_NAME,
+	.id_table = aq_pci_tbl,
+	.probe = aq_pci_probe,
+	.remove = aq_pci_remove,
+	.suspend = aq_pci_suspend,
+	.resume = aq_pci_resume,
+	.shutdown = aq_pci_shutdown,
+};
+
+module_pci_driver(aq_pci_ops);
diff --git a/drivers/net/ethernet/aquantia/aq_pci_func.h b/drivers/net/ethernet/aquantia/aq_pci_func.h
new file mode 100644
index 00000000..aeee67b
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_pci_func.h
@@ -0,0 +1,32 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_pci_func.h: Declaration of PCI functions. */
+
+#ifndef AQ_PCI_FUNC_H
+#define AQ_PCI_FUNC_H
+
+#include "aq_common.h"
+#include "aq_nic.h"
+
+struct aq_board_revision_s {
+	unsigned short devid;
+	unsigned short revision;
+	const struct aq_hw_ops *ops;
+	const struct aq_hw_caps_s *caps;
+};
+
+int aq_pci_func_init(struct pci_dev *pdev);
+int aq_pci_func_alloc_irq(struct aq_nic_s *self, unsigned int i,
+			  char *name, void *aq_vec,
+			  cpumask_t *affinity_mask);
+void aq_pci_func_free_irqs(struct aq_nic_s *self);
+unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self);
+
+#endif /* AQ_PCI_FUNC_H */
diff --git a/drivers/net/ethernet/aquantia/aq_ring.c b/drivers/net/ethernet/aquantia/aq_ring.c
new file mode 100644
index 00000000..4edacf9
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_ring.c
@@ -0,0 +1,452 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_ring.c: Definition of functions for Rx/Tx rings. */
+
+#include "aq_ring.h"
+#include "aq_nic.h"
+#include "aq_hw.h"
+#include "aq_hw_utils.h"
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
+static inline void aq_free_rxpage(struct aq_rxpage *rxpage, struct device *dev)
+{
+	unsigned len = PAGE_SIZE << rxpage->order;
+
+	dma_unmap_page(dev, rxpage->daddr, len, DMA_FROM_DEVICE);
+
+	/* Drop the ref for being in the ring. */
+	__free_pages(rxpage->page, rxpage->order);
+	rxpage->page = NULL;
+}
+
+static int aq_get_rxpage(struct aq_rxpage *rxpage, unsigned order,
+	struct device *dev)
+{
+	struct page *page;
+	dma_addr_t daddr;
+	int ret = -ENOMEM;
+
+	page = dev_alloc_pages(order);
+	if (unlikely(!page))
+		goto err_exit;
+
+	daddr = dma_map_page(dev, page, 0, PAGE_SIZE << order, DMA_FROM_DEVICE);
+
+	if (unlikely(dma_mapping_error(dev, daddr)))
+		goto free_page;
+
+	rxpage->page = page;
+	rxpage->daddr = daddr;
+	rxpage->order = order;
+	rxpage->pg_off = 0;
+
+	return 0;
+
+free_page:
+	__free_pages(page, order);
+err_exit:
+
+	return ret;
+}
+
+static int aq_get_rxpages(struct aq_ring_s *self, struct aq_ring_buff_s *rxbuf, int order)
+{
+	int ret;
+
+	if (rxbuf->rxdata.page) {
+		/* One means ring is the only user and can reuse */
+		if (page_ref_count(rxbuf->rxdata.page) > 1) {
+			/* Try reuse buffer */
+			rxbuf->rxdata.pg_off += AQ_CFG_RX_FRAME_MAX;
+			if (rxbuf->rxdata.pg_off + AQ_CFG_RX_FRAME_MAX <=
+				(PAGE_SIZE << order)) {
+				self->stats.rx.pg_flips++;
+			} else {
+				/* Buffer exhausted. We have other users and
+				 * should release this page and realloc
+				 */
+				aq_free_rxpage(&rxbuf->rxdata,
+					       aq_nic_get_dev(self->aq_nic));
+				self->stats.rx.pg_losts++;
+			}
+		} else
+			self->stats.rx.pg_reuses++;
+	}
+
+	if (!rxbuf->rxdata.page) {
+		ret = aq_get_rxpage(&rxbuf->rxdata, order,
+				  aq_nic_get_dev(self->aq_nic));
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct aq_ring_s *aq_ring_alloc(struct aq_ring_s *self,
+				       struct aq_nic_s *aq_nic)
+{
+	int err = 0;
+
+	self->buff_ring =
+		kcalloc(self->size, sizeof(struct aq_ring_buff_s), GFP_KERNEL);
+
+	if (!self->buff_ring) {
+		err = -ENOMEM;
+		goto err_exit;
+	}
+	self->dx_ring = dma_alloc_coherent(aq_nic_get_dev(aq_nic),
+						self->size * self->dx_size,
+						&self->dx_ring_pa, GFP_KERNEL);
+	if (!self->dx_ring) {
+		err = -ENOMEM;
+		goto err_exit;
+	}
+
+err_exit:
+	if (err < 0) {
+		aq_ring_free(self);
+		self = NULL;
+	}
+	return self;
+}
+
+struct aq_ring_s *aq_ring_tx_alloc(struct aq_ring_s *self,
+				   struct aq_nic_s *aq_nic,
+				   unsigned int idx,
+				   struct aq_nic_cfg_s *aq_nic_cfg)
+{
+	int err = 0;
+
+	self->aq_nic = aq_nic;
+	self->idx = idx;
+	self->size = aq_nic_cfg->txds;
+	self->dx_size = aq_nic_cfg->aq_hw_caps->txd_size;
+
+	self = aq_ring_alloc(self, aq_nic);
+	if (!self) {
+		err = -ENOMEM;
+		goto err_exit;
+	}
+
+err_exit:
+	if (err < 0) {
+		aq_ring_free(self);
+		self = NULL;
+	}
+	return self;
+}
+
+struct aq_ring_s *aq_ring_rx_alloc(struct aq_ring_s *self,
+				   struct aq_nic_s *aq_nic,
+				   unsigned int idx,
+				   struct aq_nic_cfg_s *aq_nic_cfg)
+{
+	int err = 0;
+
+	self->aq_nic = aq_nic;
+	self->idx = idx;
+	self->size = aq_nic_cfg->rxds;
+	self->dx_size = aq_nic_cfg->aq_hw_caps->rxd_size;
+	self->page_order = fls(AQ_CFG_RX_FRAME_MAX / PAGE_SIZE +
+			(AQ_CFG_RX_FRAME_MAX % PAGE_SIZE ? 1 : 0)) - 1;
+	if (aq_nic_cfg->rxpageorder > self->page_order)
+		self->page_order = aq_nic_cfg->rxpageorder;
+
+	self = aq_ring_alloc(self, aq_nic);
+	if (!self) {
+		err = -ENOMEM;
+		goto err_exit;
+	}
+
+err_exit:
+	if (err < 0) {
+		aq_ring_free(self);
+		self = NULL;
+	}
+	return self;
+}
+
+int aq_ring_init(struct aq_ring_s *self)
+{
+	self->hw_head = 0;
+	self->sw_head = 0;
+	self->sw_tail = 0;
+	return 0;
+}
+
+static inline bool aq_ring_dx_in_range(unsigned int h, unsigned int i,
+				       unsigned int t)
+{
+	return (h < t) ? ((h < i) && (i < t)) : ((h < i) || (i < t));
+}
+
+void aq_ring_update_queue_state(struct aq_ring_s *ring)
+{
+	if (aq_ring_avail_dx(ring) <= AQ_CFG_SKB_FRAGS_MAX)
+		aq_ring_queue_stop(ring);
+	else if (aq_ring_avail_dx(ring) > AQ_CFG_RESTART_DESC_THRES)
+		aq_ring_queue_wake(ring);
+}
+
+void aq_ring_queue_wake(struct aq_ring_s *ring)
+{
+	struct net_device *ndev = aq_nic_get_ndev(ring->aq_nic);
+
+	if (__netif_subqueue_stopped(ndev, ring->idx)) {
+		netif_wake_subqueue(ndev, ring->idx);
+		ring->stats.tx.queue_restarts++;
+	}
+}
+
+void aq_ring_queue_stop(struct aq_ring_s *ring)
+{
+	struct net_device *ndev = aq_nic_get_ndev(ring->aq_nic);
+
+	if (!__netif_subqueue_stopped(ndev, ring->idx))
+		netif_stop_subqueue(ndev, ring->idx);
+}
+
+bool aq_ring_tx_clean(struct aq_ring_s *self)
+{
+	struct device *dev = aq_nic_get_dev(self->aq_nic);
+	unsigned int budget = AQ_CFG_TX_CLEAN_BUDGET;
+
+	for (; self->sw_head != self->hw_head && budget--;
+		self->sw_head = aq_ring_next_dx(self, self->sw_head)) {
+		struct aq_ring_buff_s *buff = &self->buff_ring[self->sw_head];
+
+		if (likely(buff->is_mapped)) {
+			if (unlikely(buff->is_sop)) {
+				if (!buff->is_eop &&
+				    buff->eop_index != 0xffffU &&
+				    (!aq_ring_dx_in_range(self->sw_head,
+						buff->eop_index,
+						self->hw_head)))
+					break;
+
+				dma_unmap_single(dev, buff->pa, buff->len,
+						 DMA_TO_DEVICE);
+			} else {
+				dma_unmap_page(dev, buff->pa, buff->len,
+					       DMA_TO_DEVICE);
+			}
+		}
+
+		if (unlikely(buff->is_eop))
+			dev_kfree_skb_any(buff->skb);
+
+		buff->pa = 0U;
+		buff->eop_index = 0xffffU;
+	}
+
+	return !!budget;
+}
+
+#define AQ_SKB_ALIGN SKB_DATA_ALIGN(sizeof(struct skb_shared_info))
+int aq_ring_rx_clean(struct aq_ring_s *self,
+		     struct napi_struct *napi,
+		     int *work_done,
+		     int budget)
+{
+	struct net_device *ndev = aq_nic_get_ndev(self->aq_nic);
+	bool is_rsc_completed = true;
+	int err = 0;
+
+	for (; (self->sw_head != self->hw_head) && budget;
+		self->sw_head = aq_ring_next_dx(self, self->sw_head),
+		--budget, ++(*work_done)) {
+		struct aq_ring_buff_s *buff = &self->buff_ring[self->sw_head];
+		struct aq_ring_buff_s *buff_ = NULL;
+		struct sk_buff *skb = NULL;
+		unsigned int next_ = 0U;
+		unsigned int i = 0U;
+		u16 hdr_len;
+
+		if (buff->is_error) {
+			continue;
+		}
+
+		if (buff->is_cleaned)
+			continue;
+
+		rmb();
+
+		if (!buff->is_eop) {
+			for (next_ = buff->next,
+			     buff_ = &self->buff_ring[next_]; true;
+			     next_ = buff_->next,
+			     buff_ = &self->buff_ring[next_]) {
+				is_rsc_completed =
+					aq_ring_dx_in_range(self->sw_head,
+							    next_,
+							    self->hw_head);
+
+				if (unlikely(!is_rsc_completed)) {
+					is_rsc_completed = false;
+					break;
+				}
+
+				if (buff_->is_eop)
+					break;
+			}
+
+			if (!is_rsc_completed) {
+				err = 0;
+				goto err_exit;
+			}
+		}
+
+		dma_sync_single_range_for_cpu(aq_nic_get_dev(self->aq_nic),
+					      buff->rxdata.daddr,
+					      buff->rxdata.pg_off,
+					      buff->len, DMA_FROM_DEVICE);
+
+		skb = napi_alloc_skb(napi, AQ_CFG_RX_HDR_SIZE);
+		if (unlikely(!skb)) {
+			err = -ENOMEM;
+			goto err_exit;
+		}
+
+		hdr_len = min_t(u16, buff->len, AQ_CFG_RX_HDR_SIZE);
+		skb_put(skb, hdr_len);
+		memcpy(skb->data, aq_buf_vaddr(&buff->rxdata), hdr_len);
+
+		if (buff->len - hdr_len > 0) {
+			skb_add_rx_frag(skb, 0, buff->rxdata.page,
+					buff->rxdata.pg_off + hdr_len,
+					buff->len - hdr_len,
+					AQ_CFG_RX_FRAME_MAX);
+			page_ref_inc(buff->rxdata.page);
+		}
+
+		if (!buff->is_eop) {
+			for (i = 1U, next_ = buff->next,
+			     buff_ = &self->buff_ring[next_]; true;
+			     next_ = buff_->next,
+			     buff_ = &self->buff_ring[next_], ++i) {
+				dma_sync_single_range_for_cpu(
+						aq_nic_get_dev(self->aq_nic),
+						buff_->rxdata.daddr,
+						buff_->rxdata.pg_off,
+						buff_->len, DMA_FROM_DEVICE);
+				skb_add_rx_frag(skb, i,
+						buff_->rxdata.page,
+						buff_->rxdata.pg_off,
+						buff_->len,
+						AQ_CFG_RX_FRAME_MAX);
+				page_ref_inc(buff_->rxdata.page);
+				buff_->is_cleaned = 1;
+
+				if (buff_->is_eop)
+					break;
+			}
+		}
+
+		skb->protocol = eth_type_trans(skb, ndev);
+
+		if (unlikely(buff->is_cso_err)) {
+			++self->stats.rx.errors;
+			skb->ip_summed = CHECKSUM_NONE;
+		} else {
+			if (buff->is_ip_cso) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+				__skb_incr_checksum_unnecessary(skb);
+				if (buff->is_udp_cso || buff->is_tcp_cso)
+					__skb_incr_checksum_unnecessary(skb);
+#else
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+#endif
+			} else {
+				skb->ip_summed = CHECKSUM_NONE;
+			}
+		}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) || (RHEL_RELEASE_CODE > 0)
+		skb_set_hash(skb, buff->rss_hash,
+			     buff->is_hash_l4 ? PKT_HASH_TYPE_L4 :
+			     PKT_HASH_TYPE_NONE);
+#else
+		skb->rxhash = buff->rss_hash;
+#endif
+
+		skb_record_rx_queue(skb, self->idx);
+
+		++self->stats.rx.packets;
+		self->stats.rx.bytes += skb->len;
+
+		napi_gro_receive(napi, skb);
+
+	}
+
+err_exit:
+	return err;
+}
+
+int aq_ring_rx_fill(struct aq_ring_s *self)
+{
+	unsigned int page_order = self->page_order;
+	struct aq_ring_buff_s *buff = NULL;
+	int err = 0;
+	int i = 0;
+
+	if (aq_ring_avail_dx(self) < min_t(unsigned, aq_rx_refill_thres, self->size/2))
+		return err;
+
+	for (i = aq_ring_avail_dx(self); i--;
+		self->sw_tail = aq_ring_next_dx(self, self->sw_tail)) {
+		buff = &self->buff_ring[self->sw_tail];
+
+		buff->flags = 0U;
+		buff->len = AQ_CFG_RX_FRAME_MAX;
+
+		err = aq_get_rxpages(self, buff, page_order);
+		if (err)
+			goto err_exit;
+
+		buff->pa = aq_buf_daddr(&buff->rxdata);
+		buff = NULL;
+	}
+
+err_exit:
+	return err;
+}
+
+void aq_ring_rx_deinit(struct aq_ring_s *self)
+{
+	if (!self)
+		goto err_exit;
+
+	for (; self->sw_head != self->sw_tail;
+		self->sw_head = aq_ring_next_dx(self, self->sw_head)) {
+		struct aq_ring_buff_s *buff = &self->buff_ring[self->sw_head];
+
+		aq_free_rxpage(&buff->rxdata, aq_nic_get_dev(self->aq_nic));
+
+	}
+
+err_exit:;
+}
+
+void aq_ring_free(struct aq_ring_s *self)
+{
+	if (!self)
+		goto err_exit;
+
+	kfree(self->buff_ring);
+
+	if (self->dx_ring)
+		dma_free_coherent(aq_nic_get_dev(self->aq_nic),
+				  self->size * self->dx_size, self->dx_ring,
+				  self->dx_ring_pa);
+
+err_exit:;
+}
diff --git a/drivers/net/ethernet/aquantia/aq_ring.h b/drivers/net/ethernet/aquantia/aq_ring.h
new file mode 100644
index 00000000..1b5bd65
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_ring.h
@@ -0,0 +1,177 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_ring.h: Declaration of functions for Rx/Tx rings. */
+
+#ifndef AQ_RING_H
+#define AQ_RING_H
+
+#include "aq_common.h"
+
+struct page;
+struct aq_nic_cfg_s;
+
+struct aq_rxpage {
+	struct page *page;
+	dma_addr_t daddr;
+	unsigned order;
+	unsigned pg_off;
+};
+
+/*           TxC       SOP        DX         EOP
+ *         +----------+----------+----------+-----------
+ *   8bytes|len l3,l4 | pa       | pa       | pa
+ *         +----------+----------+----------+-----------
+ * 4/8bytes|len pkt   |len pkt   |          | skb
+ *         +----------+----------+----------+-----------
+ * 4/8bytes|is_txc    |len,flags |len       |len,is_eop
+ *         +----------+----------+----------+-----------
+ *
+ *  This aq_ring_buff_s doesn't have endianness dependency.
+ *  It is __packed for cache line optimizations.
+ */
+struct __packed aq_ring_buff_s {
+	union {
+		/* RX/TX */
+		dma_addr_t pa;
+		/* RX */
+		struct {
+			u32 rss_hash;
+			u16 next;
+			u8 is_hash_l4;
+			u8 rsvd1;
+			struct aq_rxpage rxdata;
+		};
+		/* EOP */
+		struct {
+			dma_addr_t pa_eop;
+			struct sk_buff *skb;
+		};
+		/* TxC */
+		struct {
+			u32 mss;
+			u8 len_l2;
+			u8 len_l3;
+			u8 len_l4;
+			u8 is_ipv6:1;
+			u8 rsvd2:7;
+			u32 len_pkt;
+		};
+	};
+	union {
+		struct {
+			u16 len;
+			u32 is_ip_cso:1;
+			u32 is_udp_cso:1;
+			u32 is_tcp_cso:1;
+			u32 is_cso_err:1;
+			u32 is_sop:1;
+			u32 is_eop:1;
+			u32 is_txc:1;
+			u32 is_mapped:1;
+			u32 is_cleaned:1;
+			u32 is_error:1;
+			u32 rsvd3:6;
+			u16 eop_index;
+			u16 rsvd4;
+		};
+		u64 flags;
+	};
+};
+
+struct aq_ring_stats_rx_s {
+	u64 errors;
+	u64 packets;
+	u64 bytes;
+	u64 lro_packets;
+	u64 jumbo_packets;
+	u64 pg_losts;
+	u64 pg_flips;
+	u64 pg_reuses;
+};
+
+struct aq_ring_stats_tx_s {
+	u64 errors;
+	u64 packets;
+	u64 bytes;
+	u64 queue_restarts;
+};
+
+union aq_ring_stats_s {
+	struct aq_ring_stats_rx_s rx;
+	struct aq_ring_stats_tx_s tx;
+};
+
+struct aq_ring_s {
+	struct aq_ring_buff_s *buff_ring;
+	u8 *dx_ring;		/* descriptors ring, dma shared mem */
+	struct aq_nic_s *aq_nic;
+	unsigned int idx;	/* for HW layer registers operations */
+	unsigned int hw_head;
+	unsigned int sw_head;
+	unsigned int sw_tail;
+	unsigned int size;	/* descriptors number */
+	unsigned int dx_size;	/* TX or RX descriptor size,  */
+				/* stored here for fater math */
+	unsigned int page_order;
+	union aq_ring_stats_s stats;
+	dma_addr_t dx_ring_pa;
+};
+
+struct aq_ring_param_s {
+	unsigned int vec_idx;
+	unsigned int cpu;
+	cpumask_t affinity_mask;
+};
+
+static inline void *aq_buf_vaddr(struct aq_rxpage *rxpage)
+{
+	return page_to_virt(rxpage->page) + rxpage->pg_off;
+}
+
+static inline dma_addr_t aq_buf_daddr(struct aq_rxpage *rxpage)
+{
+	return rxpage->daddr + rxpage->pg_off;
+}
+
+static inline unsigned int aq_ring_next_dx(struct aq_ring_s *self,
+					   unsigned int dx)
+{
+	return (++dx >= self->size) ? 0U : dx;
+}
+
+static inline unsigned int aq_ring_avail_dx(struct aq_ring_s *self)
+{
+	return (((self->sw_tail >= self->sw_head)) ?
+		(self->size - 1) - self->sw_tail + self->sw_head :
+		self->sw_head - self->sw_tail - 1);
+}
+
+struct aq_ring_s *aq_ring_tx_alloc(struct aq_ring_s *self,
+				   struct aq_nic_s *aq_nic,
+				   unsigned int idx,
+				   struct aq_nic_cfg_s *aq_nic_cfg);
+struct aq_ring_s *aq_ring_rx_alloc(struct aq_ring_s *self,
+				   struct aq_nic_s *aq_nic,
+				   unsigned int idx,
+				   struct aq_nic_cfg_s *aq_nic_cfg);
+int aq_ring_init(struct aq_ring_s *self);
+void aq_ring_rx_deinit(struct aq_ring_s *self);
+void aq_ring_free(struct aq_ring_s *self);
+void aq_ring_update_queue_state(struct aq_ring_s *ring);
+void aq_ring_queue_wake(struct aq_ring_s *ring);
+void aq_ring_queue_stop(struct aq_ring_s *ring);
+bool aq_ring_tx_clean(struct aq_ring_s *self);
+int aq_ring_rx_clean(struct aq_ring_s *self,
+		     struct napi_struct *napi,
+		     int *work_done,
+		     int budget);
+int aq_ring_rx_fill(struct aq_ring_s *self);
+
+#endif /* AQ_RING_H */
diff --git a/drivers/net/ethernet/aquantia/aq_rss.h b/drivers/net/ethernet/aquantia/aq_rss.h
new file mode 100644
index 00000000..1db6eb2
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_rss.h
@@ -0,0 +1,26 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_rss.h: Receive Side Scaling definitions. */
+
+#ifndef AQ_RSS_H
+#define AQ_RSS_H
+
+#include "aq_common.h"
+#include "aq_cfg.h"
+
+struct aq_rss_parameters {
+	u16 base_cpu_number;
+	u16 indirection_table_size;
+	u16 hash_secret_key_size;
+	u32 hash_secret_key[AQ_CFG_RSS_HASHKEY_SIZE / sizeof(u32)];
+	u8 indirection_table[AQ_CFG_RSS_INDIRECTION_TABLE_MAX];
+};
+
+#endif /* AQ_RSS_H */
diff --git a/drivers/net/ethernet/aquantia/aq_utils.h b/drivers/net/ethernet/aquantia/aq_utils.h
new file mode 100644
index 00000000..786ea81
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_utils.h
@@ -0,0 +1,42 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_utils.h: Useful macro and structures used in all layers of driver. */
+
+#ifndef AQ_UTILS_H
+#define AQ_UTILS_H
+
+#include "aq_common.h"
+
+static inline void aq_utils_obj_set(atomic_t *flags, u32 mask)
+{
+	unsigned long flags_old, flags_new;
+
+	do {
+		flags_old = atomic_read(flags);
+		flags_new = flags_old | (mask);
+	} while (atomic_cmpxchg(flags, flags_old, flags_new) != flags_old);
+}
+
+static inline void aq_utils_obj_clear(atomic_t *flags, u32 mask)
+{
+	unsigned long flags_old, flags_new;
+
+	do {
+		flags_old = atomic_read(flags);
+		flags_new = flags_old & ~(mask);
+	} while (atomic_cmpxchg(flags, flags_old, flags_new) != flags_old);
+}
+
+static inline bool aq_utils_obj_test(atomic_t *flags, u32 mask)
+{
+	return atomic_read(flags) & mask;
+}
+
+#endif /* AQ_UTILS_H */
diff --git a/drivers/net/ethernet/aquantia/aq_vec.c b/drivers/net/ethernet/aquantia/aq_vec.c
new file mode 100644
index 00000000..916d486
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_vec.c
@@ -0,0 +1,394 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_vec.c: Definition of common structure for vector of Rx and Tx rings.
+ * Definition of functions for Rx and Tx rings. Friendly module for aq_nic.
+ */
+
+#include "aq_vec.h"
+#include "aq_nic.h"
+#include "aq_ring.h"
+#include "aq_hw.h"
+
+#include <linux/netdevice.h>
+
+struct aq_vec_s {
+	const struct aq_hw_ops *aq_hw_ops;
+	struct aq_hw_s *aq_hw;
+	struct aq_nic_s *aq_nic;
+	unsigned int tx_rings;
+	unsigned int rx_rings;
+	struct aq_ring_param_s aq_ring_param;
+	struct napi_struct napi;
+	struct aq_ring_s ring[AQ_CFG_TCS_MAX][2];
+};
+
+#define AQ_VEC_TX_ID 0
+#define AQ_VEC_RX_ID 1
+
+static int aq_vec_poll(struct napi_struct *napi, int budget)
+{
+	struct aq_vec_s *self = container_of(napi, struct aq_vec_s, napi);
+	unsigned int sw_tail_old = 0U;
+	struct aq_ring_s *ring = NULL;
+	bool was_tx_cleaned = true;
+	unsigned int i = 0U;
+	int work_done = 0;
+	int err = 0;
+
+	if (!self) {
+		err = -EINVAL;
+	} else {
+		for (i = 0U, ring = self->ring[0];
+			self->tx_rings > i; ++i, ring = self->ring[i]) {
+			if (self->aq_hw_ops->hw_ring_tx_head_update) {
+				err = self->aq_hw_ops->hw_ring_tx_head_update(
+							self->aq_hw,
+							&ring[AQ_VEC_TX_ID]);
+				if (err < 0)
+					goto err_exit;
+			}
+
+			if (ring[AQ_VEC_TX_ID].sw_head !=
+			    ring[AQ_VEC_TX_ID].hw_head) {
+				was_tx_cleaned = aq_ring_tx_clean(&ring[AQ_VEC_TX_ID]);
+				aq_ring_update_queue_state(&ring[AQ_VEC_TX_ID]);
+			}
+
+			err = self->aq_hw_ops->hw_ring_rx_receive(self->aq_hw,
+					    &ring[AQ_VEC_RX_ID]);
+			if (err < 0)
+				goto err_exit;
+
+			if (ring[AQ_VEC_RX_ID].sw_head !=
+				ring[AQ_VEC_RX_ID].hw_head) {
+				err = aq_ring_rx_clean(&ring[AQ_VEC_RX_ID],
+						       napi,
+						       &work_done,
+						       budget - work_done);
+				if (err < 0)
+					goto err_exit;
+
+				sw_tail_old = ring[AQ_VEC_RX_ID].sw_tail;
+
+				err = aq_ring_rx_fill(&ring[AQ_VEC_RX_ID]);
+				if (err < 0)
+					goto err_exit;
+
+				err = self->aq_hw_ops->hw_ring_rx_fill(
+					self->aq_hw,
+					&ring[AQ_VEC_RX_ID], sw_tail_old);
+				if (err < 0)
+					goto err_exit;
+			}
+		}
+
+		if (!was_tx_cleaned)
+			work_done = budget;
+
+		if (work_done < budget) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+			napi_complete_done(napi, work_done);
+#else
+			napi_complete(napi);
+#endif
+			self->aq_hw_ops->hw_irq_enable(self->aq_hw,
+					1U << self->aq_ring_param.vec_idx);
+		}
+	}
+err_exit:
+	return work_done;
+}
+
+struct aq_vec_s *aq_vec_alloc(struct aq_nic_s *aq_nic, unsigned int idx,
+			      struct aq_nic_cfg_s *aq_nic_cfg)
+{
+	struct aq_vec_s *self = NULL;
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+	int err = 0;
+
+	self = kzalloc(sizeof(*self), GFP_KERNEL);
+	if (!self) {
+		err = -ENOMEM;
+		goto err_exit;
+	}
+
+	self->aq_nic = aq_nic;
+	self->aq_ring_param.vec_idx = idx;
+	self->aq_ring_param.cpu =
+		idx + aq_nic_cfg->aq_rss.base_cpu_number;
+
+	cpumask_set_cpu(self->aq_ring_param.cpu,
+			&self->aq_ring_param.affinity_mask);
+
+	self->tx_rings = 0;
+	self->rx_rings = 0;
+
+	netif_napi_add(aq_nic_get_ndev(aq_nic), &self->napi,
+		       aq_vec_poll, AQ_CFG_NAPI_WEIGHT);
+
+	for (i = 0; i < aq_nic_cfg->tcs; ++i) {
+		unsigned int idx_ring = AQ_NIC_TCVEC2RING(self->nic,
+						self->tx_rings,
+						self->aq_ring_param.vec_idx);
+
+		ring = aq_ring_tx_alloc(&self->ring[i][AQ_VEC_TX_ID], aq_nic,
+					idx_ring, aq_nic_cfg);
+		if (!ring) {
+			err = -ENOMEM;
+			goto err_exit;
+		}
+
+		++self->tx_rings;
+
+		aq_nic_set_tx_ring(aq_nic, idx_ring, ring);
+
+		ring = aq_ring_rx_alloc(&self->ring[i][AQ_VEC_RX_ID], aq_nic,
+					idx_ring, aq_nic_cfg);
+		if (!ring) {
+			err = -ENOMEM;
+			goto err_exit;
+		}
+
+		++self->rx_rings;
+	}
+
+err_exit:
+	if (err < 0) {
+		aq_vec_free(self);
+		self = NULL;
+	}
+	return self;
+}
+
+int aq_vec_init(struct aq_vec_s *self, const struct aq_hw_ops *aq_hw_ops,
+		struct aq_hw_s *aq_hw)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+	int err = 0;
+
+	self->aq_hw_ops = aq_hw_ops;
+	self->aq_hw = aq_hw;
+
+	for (i = 0U, ring = self->ring[0];
+		self->tx_rings > i; ++i, ring = self->ring[i]) {
+		err = aq_ring_init(&ring[AQ_VEC_TX_ID]);
+		if (err < 0)
+			goto err_exit;
+
+		err = self->aq_hw_ops->hw_ring_tx_init(self->aq_hw,
+						       &ring[AQ_VEC_TX_ID],
+						       &self->aq_ring_param);
+		if (err < 0)
+			goto err_exit;
+
+		err = aq_ring_init(&ring[AQ_VEC_RX_ID]);
+		if (err < 0)
+			goto err_exit;
+
+		err = self->aq_hw_ops->hw_ring_rx_init(self->aq_hw,
+						       &ring[AQ_VEC_RX_ID],
+						       &self->aq_ring_param);
+		if (err < 0)
+			goto err_exit;
+
+		err = aq_ring_rx_fill(&ring[AQ_VEC_RX_ID]);
+		if (err < 0)
+			goto err_exit;
+
+		err = self->aq_hw_ops->hw_ring_rx_fill(self->aq_hw,
+						       &ring[AQ_VEC_RX_ID], 0U);
+		if (err < 0)
+			goto err_exit;
+	}
+
+err_exit:
+	return err;
+}
+
+int aq_vec_start(struct aq_vec_s *self)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+	int err = 0;
+
+	for (i = 0U, ring = self->ring[0];
+		self->tx_rings > i; ++i, ring = self->ring[i]) {
+		err = self->aq_hw_ops->hw_ring_tx_start(self->aq_hw,
+							&ring[AQ_VEC_TX_ID]);
+		if (err < 0)
+			goto err_exit;
+
+		err = self->aq_hw_ops->hw_ring_rx_start(self->aq_hw,
+							&ring[AQ_VEC_RX_ID]);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	napi_enable(&self->napi);
+
+err_exit:
+	return err;
+}
+
+void aq_vec_stop(struct aq_vec_s *self)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+
+	for (i = 0U, ring = self->ring[0];
+		self->tx_rings > i; ++i, ring = self->ring[i]) {
+		self->aq_hw_ops->hw_ring_tx_stop(self->aq_hw,
+						 &ring[AQ_VEC_TX_ID]);
+
+		self->aq_hw_ops->hw_ring_rx_stop(self->aq_hw,
+						 &ring[AQ_VEC_RX_ID]);
+	}
+
+	napi_disable(&self->napi);
+}
+
+void aq_vec_deinit(struct aq_vec_s *self)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+
+	if (!self)
+		goto err_exit;
+
+	for (i = 0U, ring = self->ring[0];
+		self->tx_rings > i; ++i, ring = self->ring[i]) {
+		aq_ring_tx_clean(&ring[AQ_VEC_TX_ID]);
+		aq_ring_rx_deinit(&ring[AQ_VEC_RX_ID]);
+	}
+err_exit:;
+}
+
+void aq_vec_free(struct aq_vec_s *self)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int i = 0U;
+
+	if (!self)
+		goto err_exit;
+
+	for (i = 0U, ring = self->ring[0];
+		self->tx_rings > i; ++i, ring = self->ring[i]) {
+		aq_ring_free(&ring[AQ_VEC_TX_ID]);
+		aq_ring_free(&ring[AQ_VEC_RX_ID]);
+	}
+
+	netif_napi_del(&self->napi);
+
+	kfree(self);
+
+err_exit:;
+}
+
+irqreturn_t aq_vec_isr(int irq, void *private)
+{
+	struct aq_vec_s *self = private;
+	int err = 0;
+
+	if (!self) {
+		err = -EINVAL;
+		goto err_exit;
+	}
+	napi_schedule(&self->napi);
+
+err_exit:
+	return err >= 0 ? IRQ_HANDLED : IRQ_NONE;
+}
+
+irqreturn_t aq_vec_isr_legacy(int irq, void *private)
+{
+	struct aq_vec_s *self = private;
+	u64 irq_mask = 0U;
+	irqreturn_t err = 0;
+
+	if (!self) {
+		err = -EINVAL;
+		goto err_exit;
+	}
+	err = self->aq_hw_ops->hw_irq_read(self->aq_hw, &irq_mask);
+	if (err < 0)
+		goto err_exit;
+
+	if (irq_mask) {
+		self->aq_hw_ops->hw_irq_disable(self->aq_hw,
+			      1U << self->aq_ring_param.vec_idx);
+		napi_schedule(&self->napi);
+	} else {
+		self->aq_hw_ops->hw_irq_enable(self->aq_hw, 1U);
+		err = IRQ_NONE;
+	}
+
+err_exit:
+	return err >= 0 ? IRQ_HANDLED : IRQ_NONE;
+}
+
+cpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self)
+{
+	return &self->aq_ring_param.affinity_mask;
+}
+
+void aq_vec_add_stats(struct aq_vec_s *self,
+		      struct aq_ring_stats_rx_s *stats_rx,
+		      struct aq_ring_stats_tx_s *stats_tx)
+{
+	struct aq_ring_s *ring = NULL;
+	unsigned int r = 0U;
+
+	for (r = 0U, ring = self->ring[0];
+		self->tx_rings > r; ++r, ring = self->ring[r]) {
+		struct aq_ring_stats_tx_s *tx = &ring[AQ_VEC_TX_ID].stats.tx;
+		struct aq_ring_stats_rx_s *rx = &ring[AQ_VEC_RX_ID].stats.rx;
+
+		stats_rx->packets += rx->packets;
+		stats_rx->bytes += rx->bytes;
+		stats_rx->errors += rx->errors;
+		stats_rx->jumbo_packets += rx->jumbo_packets;
+		stats_rx->lro_packets += rx->lro_packets;
+		stats_rx->pg_losts += rx->pg_losts;
+		stats_rx->pg_flips += rx->pg_flips;
+		stats_rx->pg_reuses += rx->pg_reuses;
+
+		stats_tx->packets += tx->packets;
+		stats_tx->bytes += tx->bytes;
+		stats_tx->errors += tx->errors;
+		stats_tx->queue_restarts += tx->queue_restarts;
+	}
+}
+
+int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data, unsigned int *p_count)
+{
+	unsigned int count = 0U;
+	struct aq_ring_stats_rx_s stats_rx;
+	struct aq_ring_stats_tx_s stats_tx;
+
+	memset(&stats_rx, 0U, sizeof(struct aq_ring_stats_rx_s));
+	memset(&stats_tx, 0U, sizeof(struct aq_ring_stats_tx_s));
+	aq_vec_add_stats(self, &stats_rx, &stats_tx);
+
+	/* This data should mimic aq_ethtool_queue_stat_names structure
+	 */
+	data[count] += stats_rx.packets;
+	data[++count] += stats_tx.packets;
+	data[++count] += stats_tx.queue_restarts;
+	data[++count] += stats_rx.jumbo_packets;
+	data[++count] += stats_rx.lro_packets;
+	data[++count] += stats_rx.errors;
+
+	if (p_count)
+		*p_count = ++count;
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/aquantia/aq_vec.h b/drivers/net/ethernet/aquantia/aq_vec.h
new file mode 100644
index 00000000..8bdf60b
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/aq_vec.h
@@ -0,0 +1,44 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File aq_vec.h: Definition of common structures for vector of Rx and Tx rings.
+ * Declaration of functions for Rx and Tx rings.
+ */
+
+#ifndef AQ_VEC_H
+#define AQ_VEC_H
+
+#include "aq_common.h"
+#include <linux/irqreturn.h>
+
+struct aq_hw_s;
+struct aq_hw_ops;
+struct aq_nic_s;
+struct aq_nic_cfg_s;
+struct aq_ring_stats_rx_s;
+struct aq_ring_stats_tx_s;
+
+irqreturn_t aq_vec_isr(int irq, void *private);
+irqreturn_t aq_vec_isr_legacy(int irq, void *private);
+struct aq_vec_s *aq_vec_alloc(struct aq_nic_s *aq_nic, unsigned int idx,
+			      struct aq_nic_cfg_s *aq_nic_cfg);
+int aq_vec_init(struct aq_vec_s *self, const struct aq_hw_ops *aq_hw_ops,
+		struct aq_hw_s *aq_hw);
+void aq_vec_deinit(struct aq_vec_s *self);
+void aq_vec_free(struct aq_vec_s *self);
+int aq_vec_start(struct aq_vec_s *self);
+void aq_vec_stop(struct aq_vec_s *self);
+cpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self);
+int aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data,
+			unsigned int *p_count);
+void aq_vec_add_stats(struct aq_vec_s *self,
+		      struct aq_ring_stats_rx_s *stats_rx,
+		      struct aq_ring_stats_tx_s *stats_tx);
+
+#endif /* AQ_VEC_H */
diff --git a/drivers/net/ethernet/aquantia/build-deb.sh b/drivers/net/ethernet/aquantia/build-deb.sh
new file mode 100755
index 00000000..9ddc676
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/build-deb.sh
@@ -0,0 +1,64 @@
+#!/bin/sh
+set -x
+version=`git describe --tags --abbrev=4  | sed 's/\(.*\)-.*/\1/' | sed 's/-/./' | sed 's/v//'`
+
+if [ -e $version ]; then
+        version=`date +%s`
+fi
+
+DRV_ROOT=$PWD
+DEB_ROOT=$PWD/../build
+DEB_DEBIAN=$DEB_ROOT/DEBIAN
+DEB_CONTROL=$DEB_DEBIAN/control
+SRC=/var/build_aq_drv/${version}/Linux
+DEB_SRC=$DEB_ROOT/$SRC
+DEB_OUT=$DRV_ROOT
+TARGET=atlantic
+
+rm -rf $DEB_ROOT
+
+mkdir -p $DEB_DEBIAN || exit 1
+mkdir -p $DEB_SRC || exit 1
+
+cp -r $DRV_ROOT/* $DEB_SRC
+
+echo "Package: Atlantic
+Maintainer: Anatoly Vildemanov <avildem@aquantia.com>
+Build-Depends: debhelper (>= 8.0.0)
+Version: $version
+Section: utils
+Architecture: all
+Description: This package contains aQuantia AQtion Ethernet Linux driver" > $DEB_CONTROL || exit 1
+
+echo "#!/bin/bash
+KERNEL=/lib/modules/\$(uname -r)/aquantia/$TARGET.ko
+mv \$KERNEL \$KERNEL.bac || true
+depmod -a \$(uname -r)
+rmmod $TARGET.ko || true
+" > $DEB_DEBIAN/preinst || exit 1
+
+echo "#!/bin/bash
+cd $SRC
+AQ_KERNEL=/lib/modules/\$(uname -r)/aquantia/
+KERNEL=\$AQ_KERNEL/$TARGET.ko
+make all
+chmod 644 $TARGET.ko
+mkdir -p \$AQ_KERNEL
+cp $TARGET.ko \$AQ_KERNEL
+depmod -a \$(uname -r)
+insmod $TARGET.ko
+" > $DEB_DEBIAN/postinst || exit 1
+
+echo "#!/bin/bash
+rmmod $TARGET.ko || true
+KERNEL=/lib/modules/\$(uname -r)/aquantia/$TARGET.ko
+rm -rf $KERNEL
+depmod -a \$(uname -r)
+
+" > $DEB_DEBIAN/postrm || exit 1
+
+chmod 755 $DEB_DEBIAN/preinst $DEB_DEBIAN/postinst $DEB_DEBIAN/postrm
+
+deb_name='atlantic_'$version'.deb'
+
+fakeroot dpkg-deb --build  $DEB_ROOT $deb_name
\ No newline at end of file
diff --git a/drivers/net/ethernet/aquantia/dkms.sh b/drivers/net/ethernet/aquantia/dkms.sh
new file mode 100755
index 00000000..a4ebba4
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/dkms.sh
@@ -0,0 +1,146 @@
+#!/bin/sh
+
+# error code
+ERR_OK=0
+ERR_SCRIPT=1
+ERR_DRIVER_NOT_ADD=200
+ERR_DRIVER_ALREADY_ADD=$(expr ${ERR_DRIVER_NOT_ADD} + 1)
+
+get_version_driver ()
+{
+	local FILENAME="ver.h"
+
+	local MAJOR=`   awk -n '/NIC_MAJOR_DRIVER_VERSION/    {print $3}' ${FILENAME}`
+	local MINOR=`   awk -n '/NIC_MINOR_DRIVER_VERSION/    {print $3}' ${FILENAME}`
+	local BUILD=`   awk -n '/NIC_BUILD_DRIVER_VERSION/    {print $3}' ${FILENAME}`
+	local REVISION=`awk -n '/NIC_REVISION_DRIVER_VERSION/ {print $3}' ${FILENAME}`
+
+	echo "${MAJOR}.${MINOR}.${BUILD}.${REVISION}"
+}
+
+remove_driver ()
+{
+	case ${@} in
+		${ERR_DRIVER_ALREADY_ADD} ) ;;
+		${ERR_DRIVER_NOT_ADD}     ) rm -rf ${MODULE_SRC} ;;
+		*                         ) dkms remove ${MODULE_NAME}/${MODULE_VERSION} --all || exit ${ERR_SCRIPT}
+		                            rm -rf ${MODULE_SRC} ;;
+	esac
+
+	exit ${@}
+}
+
+install_driver ()
+{
+	mkdir -p ${MODULE_SRC}
+	cp -r * ${MODULE_SRC}
+
+cat <<EOF >/usr/src/${PACKAGE_NAME}/dkms.conf
+	PACKAGE_NAME="${MODULE_NAME}"
+	BUILT_MODULE_NAME[0]="${MODULE_NAME}"
+	PACKAGE_VERSION="${MODULE_VERSION}"
+	DEST_MODULE_LOCATION[0]="/kernel/drivers/net/ethernet/aquantia"
+	AUTOINSTALL="yes"
+EOF
+
+	dkms add ${MODULE_NAME}/${MODULE_VERSION}
+	local ERR=${?}
+	if [ ${ERR} != 0 ] ; then
+		if [ "${ERR}" = "3" ] ; then
+			remove_driver ${ERR_DRIVER_ALREADY_ADD} > /dev/null
+		else
+			remove_driver ${ERR_DRIVER_NOT_ADD}     > /dev/null
+		fi
+	fi
+
+	dkms build   ${MODULE_NAME}/${MODULE_VERSION} || remove_driver ${?} > /dev/null
+	dkms install ${MODULE_NAME}/${MODULE_VERSION} || remove_driver ${?} > /dev/null
+}
+
+uninstall_driver ()
+{
+	remove_driver ${ERR_OK}
+}
+
+get_uninstalled_packages ()
+{
+	local UNINSTALLED=""
+
+	for PACKAGE in ${PACKAGES}
+	do
+		${CMD} ${PACKAGE} > /dev/null
+		if [ "${?}" != "0" ] ; then
+			UNINSTALLED="${UNINSTALLED} ${PACKAGE}"
+		fi
+	done
+
+	echo "${UNINSTALLED}"
+}
+
+get_distro_os ()
+{
+	local OS=`uname`
+	if [ "${OS}" = "Linux" ] ; then
+		if [ -f /etc/redhat-release ] ; then
+			DISTRO_NAME='redhat'
+		elif [ -f /etc/debian_version ] ; then
+			DISTRO_NAME='debian'
+		elif [ -f /etc/SuSE-release ] ; then
+			DISTRO_NAME='suse'
+		elif [ -f /etc/mandrake-release ] ; then
+			DISTRO_NAME='mandrake'
+		fi
+	else
+		DISTRO_NAME="undefined"
+	fi
+
+	echo ${DISTRO_NAME}
+}
+
+main ()
+{
+	YUM="yum"
+	APT_GET="apt-get"
+	DKMS="dkms"
+	GAWK="gawk"
+	CMD=""
+	DISTRO=$(get_distro_os)
+	if [ "${DISTRO}" = "debian" ] ; then
+		PACKET_MNG="${APT_GET}"
+		LINUX_HEADERS="linux-headers-`uname -r`"
+		TOOLS="build-essential"
+		CMD="dpkg-query -l"
+	elif [ "${DISTRO}" = "redhat" ] ; then
+		PACKET_MNG="${YUM}"
+		LINUX_HEADERS="kernel-devel-`uname -r`"
+		TOOLS="gcc gcc-c++ make"
+		CMD="${YUM} list installed"
+	else
+		echo "Sorry, your operating system ${DISTRO} is not supported."
+		exit ${ERR_SCRIPT}
+	fi
+
+	# necessary packages
+	PACKAGES="${LINUX_HEADERS} ${DKMS} ${GAWK} ${TOOLS}"
+	UNINSTALLED_PACKAGES=$(get_uninstalled_packages)
+
+	if [ ! -z "${UNINSTALLED_PACKAGES}" ] ; then
+		echo "Please install the necessary packages${UNINSTALLED_PACKAGES}."
+		echo "Example: sudo ${PACKET_MNG} install${UNINSTALLED_PACKAGES}."
+		exit ${ERR_SCRIPT}
+	fi
+
+	MODULE_NAME="atlantic"
+	MODULE_VERSION=$(get_version_driver)
+	PACKAGE_NAME="${MODULE_NAME}-${MODULE_VERSION}"
+	MODULE_SRC="/usr/src/${PACKAGE_NAME}"
+
+	case ${1} in
+		install   ) install_driver ;;
+		uninstall ) uninstall_driver ;;
+		*         ) echo "Sorry, invalid parameters, please enter: ${0} install or ${0} uninstall."
+		            exit ${ERR_SCRIPT} ;;
+	esac
+}
+
+main ${1}
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.c b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.c
new file mode 100644
index 00000000..b893b4f
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.c
@@ -0,0 +1,900 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_a0.c: Definition of Atlantic hardware specific functions. */
+
+#include "../aq_hw.h"
+#include "../aq_hw_utils.h"
+#include "../aq_ring.h"
+#include "../aq_nic.h"
+#include "hw_atl_a0.h"
+#include "hw_atl_utils.h"
+#include "hw_atl_llh.h"
+#include "hw_atl_a0_internal.h"
+
+#define DEFAULT_A0_BOARD_BASIC_CAPABILITIES \
+	.is_64_dma = true,		  \
+	.msix_irqs = 4U,		  \
+	.irq_mask = ~0U,		  \
+	.vecs = HW_ATL_A0_RSS_MAX,	  \
+	.tcs = HW_ATL_A0_TC_MAX,	  \
+	.rxd_alignment = 1U,		  \
+	.rxd_size = HW_ATL_A0_RXD_SIZE,   \
+	.rxds_max = HW_ATL_A0_MAX_RXD,    \
+	.rxds_min = HW_ATL_A0_MIN_RXD,    \
+	.txd_alignment = 1U,		  \
+	.txd_size = HW_ATL_A0_TXD_SIZE,   \
+	.txds_max = HW_ATL_A0_MAX_TXD,    \
+	.txds_min = HW_ATL_A0_MIN_RXD,    \
+	.txhwb_alignment = 4096U,	  \
+	.tx_rings = HW_ATL_A0_TX_RINGS,   \
+	.rx_rings = HW_ATL_A0_RX_RINGS,   \
+	.hw_features = NETIF_F_HW_CSUM |  \
+			NETIF_F_RXHASH |  \
+			NETIF_F_RXCSUM |  \
+			NETIF_F_SG |	  \
+			NETIF_F_TSO,	  \
+	.hw_priv_flags = IFF_UNICAST_FLT, \
+	.flow_control = true,		  \
+	.mtu = HW_ATL_A0_MTU_JUMBO,       \
+	.mac_regs_count = 88,		  \
+	.hw_alive_check_addr = 0x10U
+
+const struct aq_hw_caps_s hw_atl_a0_caps_aqc100 = {
+	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_FIBRE,
+	.link_speed_msk = AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_a0_caps_aqc107 = {
+	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_10G|
+			  AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_a0_caps_aqc108 = {
+	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_a0_caps_aqc109 = {
+	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+static int hw_atl_a0_hw_reset(struct aq_hw_s *self)
+{
+	int err = 0;
+
+	hw_atl_glb_glb_reg_res_dis_set(self, 1U);
+	hw_atl_pci_pci_reg_res_dis_set(self, 0U);
+	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+
+	HW_ATL_FLUSH();
+	hw_atl_glb_soft_res_set(self, 1);
+
+	/* check 10 times by 1ms */
+	AQ_HW_WAIT_FOR(hw_atl_glb_soft_res_get(self) == 0, 1000U, 10U);
+	if (err < 0)
+		goto err_exit;
+
+	hw_atl_itr_irq_reg_res_dis_set(self, 0U);
+	hw_atl_itr_res_irq_set(self, 1U);
+
+	/* check 10 times by 1ms */
+	AQ_HW_WAIT_FOR(hw_atl_itr_res_irq_get(self) == 0, 1000U, 10U);
+	if (err < 0)
+		goto err_exit;
+
+	self->aq_fw_ops->set_state(self, MPI_RESET);
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_qos_set(struct aq_hw_s *self)
+{
+	u32 tc = 0U;
+	u32 buff_size = 0U;
+	unsigned int i_priority = 0U;
+	bool is_rx_flow_control = false;
+
+	/* TPS Descriptor rate init */
+	hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);
+	hw_atl_tps_tx_pkt_shed_desc_rate_lim_set(self, 0xA);
+
+	/* TPS VM init */
+	hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(self, 0U);
+
+	/* TPS TC credits init */
+	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
+	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, 0U);
+
+	hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, 0U);
+	hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, 0U);
+	hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, 0U);
+	hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, 0U);
+
+	/* Tx buf size */
+	buff_size = HW_ATL_A0_TXBUF_MAX;
+
+	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, buff_size, tc);
+	hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024 / 32U) * 66U) /
+						   100U, tc);
+	hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024 / 32U) * 50U) /
+						   100U, tc);
+
+	/* QoS Rx buf size per TC */
+	tc = 0;
+	is_rx_flow_control = (AQ_NIC_FC_RX & self->aq_nic_cfg->flow_control);
+	buff_size = HW_ATL_A0_RXBUF_MAX;
+
+	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, buff_size, tc);
+	hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024U / 32U) * 66U) /
+						   100U, tc);
+	hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024U / 32U) * 50U) /
+						   100U, tc);
+	hw_atl_rpb_rx_xoff_en_per_tc_set(self, is_rx_flow_control ? 1U : 0U, tc);
+
+	/* QoS 802.1p priority -> TC mapping */
+	for (i_priority = 8U; i_priority--;)
+		hw_atl_rpf_rpb_user_priority_tc_map_set(self, i_priority, 0U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_rss_hash_set(struct aq_hw_s *self,
+				     struct aq_rss_parameters *rss_params)
+{
+	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
+	int err = 0;
+	unsigned int i = 0U;
+	unsigned int addr = 0U;
+
+	for (i = 10, addr = 0U; i--; ++addr) {
+		u32 key_data = cfg->is_rss ?
+			__swab32(rss_params->hash_secret_key[i]) : 0U;
+		hw_atl_rpf_rss_key_wr_data_set(self, key_data);
+		hw_atl_rpf_rss_key_addr_set(self, addr);
+		hw_atl_rpf_rss_key_wr_en_set(self, 1U);
+		AQ_HW_WAIT_FOR(hw_atl_rpf_rss_key_wr_en_get(self) == 0,
+			       1000U, 10U);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_rss_set(struct aq_hw_s *self,
+				struct aq_rss_parameters *rss_params)
+{
+	u8 *indirection_table =	rss_params->indirection_table;
+	u32 i = 0U;
+	u32 num_rss_queues = max(1U, self->aq_nic_cfg->num_rss_queues);
+	int err = 0;
+	u16 bitary[(HW_ATL_A0_RSS_REDIRECTION_MAX *
+					HW_ATL_A0_RSS_REDIRECTION_BITS / 16U)];
+
+	memset(bitary, 0, sizeof(bitary));
+
+	for (i = HW_ATL_A0_RSS_REDIRECTION_MAX; i--; ) {
+		(*(u32 *)(bitary + ((i * 3U) / 16U))) |=
+			((indirection_table[i] % num_rss_queues) <<
+			((i * 3U) & 0xFU));
+	}
+
+	for (i = ARRAY_SIZE(bitary); i--;) {
+		hw_atl_rpf_rss_redir_tbl_wr_data_set(self, bitary[i]);
+		hw_atl_rpf_rss_redir_tbl_addr_set(self, i);
+		hw_atl_rpf_rss_redir_wr_en_set(self, 1U);
+		AQ_HW_WAIT_FOR(hw_atl_rpf_rss_redir_wr_en_get(self) == 0,
+			       1000U, 10U);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_offload_set(struct aq_hw_s *self,
+				    struct aq_nic_cfg_s *aq_nic_cfg)
+{
+	/* TX checksums offloads*/
+	hw_atl_tpo_ipv4header_crc_offload_en_set(self, 1);
+	hw_atl_tpo_tcp_udp_crc_offload_en_set(self, 1);
+
+	/* RX checksums offloads*/
+	hw_atl_rpo_ipv4header_crc_offload_en_set(self, 1);
+	hw_atl_rpo_tcp_udp_crc_offload_en_set(self, 1);
+
+	/* LSO offloads*/
+	hw_atl_tdm_large_send_offload_en_set(self, 0xFFFFFFFFU);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_init_tx_path(struct aq_hw_s *self)
+{
+	hw_atl_thm_lso_tcp_flag_of_first_pkt_set(self, 0x0FF6U);
+	hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(self, 0x0FF6U);
+	hw_atl_thm_lso_tcp_flag_of_last_pkt_set(self, 0x0F7FU);
+
+	/* Tx interrupts */
+	hw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 1U);
+
+	/* misc */
+	aq_hw_write_reg(self, 0x00007040U, IS_CHIP_FEATURE(TPO2) ?
+			0x00010000U : 0x00000000U);
+	hw_atl_tdm_tx_dca_en_set(self, 0U);
+	hw_atl_tdm_tx_dca_mode_set(self, 0U);
+
+	hw_atl_tpb_tx_path_scp_ins_en_set(self, 1U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_init_rx_path(struct aq_hw_s *self)
+{
+	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
+	int i;
+
+	/* Rx TC/RSS number config */
+	hw_atl_rpb_rpf_rx_traf_class_mode_set(self, 1U);
+
+	/* Rx flow control */
+	hw_atl_rpb_rx_flow_ctl_mode_set(self, 1U);
+
+	/* RSS Ring selection */
+	hw_atl_reg_rx_flr_rss_control1set(self, cfg->is_rss ?
+					0xB3333333U : 0x00000000U);
+
+	/* Multicast filters */
+	for (i = HW_ATL_A0_MAC_MAX; i--;) {
+		hw_atl_rpfl2_uc_flr_en_set(self, (i == 0U) ? 1U : 0U, i);
+		hw_atl_rpfl2unicast_flr_act_set(self, 1U, i);
+	}
+
+	hw_atl_reg_rx_flr_mcst_flr_msk_set(self, 0x00000000U);
+	hw_atl_reg_rx_flr_mcst_flr_set(self, 0x00010FFFU, 0U);
+
+	/* Vlan filters */
+	hw_atl_rpf_vlan_outer_etht_set(self, 0x88A8U);
+	hw_atl_rpf_vlan_inner_etht_set(self, 0x8100U);
+	hw_atl_rpf_vlan_prom_mode_en_set(self, 1);
+
+	/* Rx Interrupts */
+	hw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 1U);
+
+	/* misc */
+	hw_atl_rpfl2broadcast_flr_act_set(self, 1U);
+	hw_atl_rpfl2broadcast_count_threshold_set(self, 0xFFFFU & (~0U / 256U));
+
+	hw_atl_rdm_rx_dca_en_set(self, 0U);
+	hw_atl_rdm_rx_dca_mode_set(self, 0U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
+{
+	int err = 0;
+	unsigned int h = 0U;
+	unsigned int l = 0U;
+
+	if (!mac_addr) {
+		err = -EINVAL;
+		goto err_exit;
+	}
+	h = (mac_addr[0] << 8) | (mac_addr[1]);
+	l = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
+		(mac_addr[4] << 8) | mac_addr[5];
+
+	hw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_A0_MAC);
+	hw_atl_rpfl2unicast_dest_addresslsw_set(self, l, HW_ATL_A0_MAC);
+	hw_atl_rpfl2unicast_dest_addressmsw_set(self, h, HW_ATL_A0_MAC);
+	hw_atl_rpfl2_uc_flr_en_set(self, 1U, HW_ATL_A0_MAC);
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_init(struct aq_hw_s *self, u8 *mac_addr)
+{
+	static u32 aq_hw_atl_igcr_table_[4][2] = {
+		{ 0x20000000U, 0x20000000U }, /* AQ_IRQ_INVALID */
+		{ 0x20000080U, 0x20000080U }, /* AQ_IRQ_LEGACY */
+		{ 0x20000021U, 0x20000025U }, /* AQ_IRQ_MSI */
+		{ 0x20000022U, 0x20000026U }  /* AQ_IRQ_MSIX */
+	};
+
+	int err = 0;
+
+	struct aq_nic_cfg_s *aq_nic_cfg = self->aq_nic_cfg;
+
+	hw_atl_a0_hw_init_tx_path(self);
+	hw_atl_a0_hw_init_rx_path(self);
+
+	hw_atl_a0_hw_mac_addr_set(self, mac_addr);
+
+	self->aq_fw_ops->set_link_speed(self, aq_nic_cfg->link_speed_msk);
+	self->aq_fw_ops->set_state(self, MPI_INIT);
+
+	hw_atl_reg_tx_dma_debug_ctl_set(self, 0x800000b8U);
+	hw_atl_reg_tx_dma_debug_ctl_set(self, 0x000000b8U);
+
+	hw_atl_a0_hw_qos_set(self);
+	hw_atl_a0_hw_rss_set(self, &aq_nic_cfg->aq_rss);
+	hw_atl_a0_hw_rss_hash_set(self, &aq_nic_cfg->aq_rss);
+
+	/* Reset link status and read out initial hardware counters */
+	self->aq_link_status.mbps = 0;
+	self->aq_fw_ops->update_stats(self);
+
+	err = aq_hw_err_from_flags(self);
+	if (err < 0)
+		goto err_exit;
+
+	/* Interrupts */
+	hw_atl_reg_irq_glb_ctl_set(self,
+				   aq_hw_atl_igcr_table_[aq_nic_cfg->irq_type]
+					[(aq_nic_cfg->vecs > 1U) ? 1 : 0]);
+
+	hw_atl_itr_irq_auto_masklsw_set(self, aq_nic_cfg->aq_hw_caps->irq_mask);
+
+	/* Interrupts */
+	hw_atl_reg_gen_irq_map_set(self,
+				   ((HW_ATL_A0_ERR_INT << 0x18) | (1U << 0x1F)) |
+				   ((HW_ATL_A0_ERR_INT << 0x10) | (1U << 0x17)) |
+				   ((HW_ATL_A0_ERR_INT << 8) | (1U << 0xF)) |
+				   ((HW_ATL_A0_ERR_INT) | (1U << 0x7)), 0U);
+
+	hw_atl_a0_hw_offload_set(self, aq_nic_cfg);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_ring_tx_start(struct aq_hw_s *self,
+				      struct aq_ring_s *ring)
+{
+	hw_atl_tdm_tx_desc_en_set(self, 1, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_rx_start(struct aq_hw_s *self,
+				      struct aq_ring_s *ring)
+{
+	hw_atl_rdm_rx_desc_en_set(self, 1, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_start(struct aq_hw_s *self)
+{
+	hw_atl_tpb_tx_buff_en_set(self, 1);
+	hw_atl_rpb_rx_buff_en_set(self, 1);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_tx_ring_tail_update(struct aq_hw_s *self,
+					    struct aq_ring_s *ring)
+{
+	hw_atl_reg_tx_dma_desc_tail_ptr_set(self, ring->sw_tail, ring->idx);
+	return 0;
+}
+
+static int hw_atl_a0_hw_ring_tx_xmit(struct aq_hw_s *self,
+				     struct aq_ring_s *ring,
+				     unsigned int frags)
+{
+	struct aq_ring_buff_s *buff = NULL;
+	struct hw_atl_txd_s *txd = NULL;
+	unsigned int buff_pa_len = 0U;
+	unsigned int pkt_len = 0U;
+	unsigned int frag_count = 0U;
+	bool is_gso = false;
+
+	buff = &ring->buff_ring[ring->sw_tail];
+	pkt_len = (buff->is_eop && buff->is_sop) ? buff->len : buff->len_pkt;
+
+	for (frag_count = 0; frag_count < frags; frag_count++) {
+		txd = (struct hw_atl_txd_s *)&ring->dx_ring[ring->sw_tail *
+						HW_ATL_A0_TXD_SIZE];
+		txd->ctl = 0;
+		txd->ctl2 = 0;
+		txd->buf_addr = 0;
+
+		buff = &ring->buff_ring[ring->sw_tail];
+
+		if (buff->is_txc) {
+			txd->ctl |= (buff->len_l3 << 31) |
+				(buff->len_l2 << 24) |
+				HW_ATL_A0_TXD_CTL_CMD_TCP |
+				HW_ATL_A0_TXD_CTL_DESC_TYPE_TXC;
+			txd->ctl2 |= (buff->mss << 16) |
+				(buff->len_l4 << 8) |
+				(buff->len_l3 >> 1);
+
+			pkt_len -= (buff->len_l4 +
+				    buff->len_l3 +
+				    buff->len_l2);
+			is_gso = true;
+		} else {
+			buff_pa_len = buff->len;
+
+			txd->buf_addr = buff->pa;
+			txd->ctl |= (HW_ATL_A0_TXD_CTL_BLEN &
+						((u32)buff_pa_len << 4));
+			txd->ctl |= HW_ATL_A0_TXD_CTL_DESC_TYPE_TXD;
+			/* PAY_LEN */
+			txd->ctl2 |= HW_ATL_A0_TXD_CTL2_LEN & (pkt_len << 14);
+
+			if (is_gso) {
+				txd->ctl |= HW_ATL_A0_TXD_CTL_CMD_LSO;
+				txd->ctl2 |= HW_ATL_A0_TXD_CTL2_CTX_EN;
+			}
+
+			/* Tx checksum offloads */
+			if (buff->is_ip_cso)
+				txd->ctl |= HW_ATL_A0_TXD_CTL_CMD_IPCSO;
+
+			if (buff->is_udp_cso || buff->is_tcp_cso)
+				txd->ctl |= HW_ATL_A0_TXD_CTL_CMD_TUCSO;
+
+			if (unlikely(buff->is_eop)) {
+				txd->ctl |= HW_ATL_A0_TXD_CTL_EOP;
+				txd->ctl |= HW_ATL_A0_TXD_CTL_CMD_WB;
+			}
+		}
+
+		ring->sw_tail = aq_ring_next_dx(ring, ring->sw_tail);
+	}
+
+	hw_atl_a0_hw_tx_ring_tail_update(self, ring);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_rx_init(struct aq_hw_s *self,
+				     struct aq_ring_s *aq_ring,
+				     struct aq_ring_param_s *aq_ring_param)
+{
+	u32 dma_desc_addr_lsw = (u32)aq_ring->dx_ring_pa;
+	u32 dma_desc_addr_msw = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);
+
+	hw_atl_rdm_rx_desc_en_set(self, false, aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);
+
+	hw_atl_reg_rx_dma_desc_base_addresslswset(self, dma_desc_addr_lsw,
+						  aq_ring->idx);
+
+	hw_atl_reg_rx_dma_desc_base_addressmswset(self,
+						  dma_desc_addr_msw,
+						  aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_data_buff_size_set(self,
+					      AQ_CFG_RX_FRAME_MAX / 1024U,
+				       aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_head_buff_size_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);
+	hw_atl_rpo_rx_desc_vlan_stripping_set(self, 0U, aq_ring->idx);
+
+	/* Rx ring set mode */
+
+	/* Mapping interrupt vector */
+	hw_atl_itr_irq_map_rx_set(self, aq_ring_param->vec_idx, aq_ring->idx);
+	hw_atl_itr_irq_map_en_rx_set(self, true, aq_ring->idx);
+
+	hw_atl_rdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);
+	hw_atl_rdm_rx_desc_dca_en_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_head_dca_en_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_pld_dca_en_set(self, 0U, aq_ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_tx_init(struct aq_hw_s *self,
+				     struct aq_ring_s *aq_ring,
+				     struct aq_ring_param_s *aq_ring_param)
+{
+	u32 dma_desc_lsw_addr = (u32)aq_ring->dx_ring_pa;
+	u32 dma_desc_msw_addr = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);
+
+	hw_atl_reg_tx_dma_desc_base_addresslswset(self, dma_desc_lsw_addr,
+						  aq_ring->idx);
+
+	hw_atl_reg_tx_dma_desc_base_addressmswset(self, dma_desc_msw_addr,
+						  aq_ring->idx);
+
+	hw_atl_tdm_tx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);
+
+	hw_atl_a0_hw_tx_ring_tail_update(self, aq_ring);
+
+	/* Set Tx threshold */
+	hw_atl_tdm_tx_desc_wr_wb_threshold_set(self, 0U, aq_ring->idx);
+
+	/* Mapping interrupt vector */
+	hw_atl_itr_irq_map_tx_set(self, aq_ring_param->vec_idx, aq_ring->idx);
+	hw_atl_itr_irq_map_en_tx_set(self, true, aq_ring->idx);
+
+	hw_atl_tdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);
+	hw_atl_tdm_tx_desc_dca_en_set(self, 0U, aq_ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_rx_fill(struct aq_hw_s *self,
+				     struct aq_ring_s *ring,
+				     unsigned int sw_tail_old)
+{
+	for (; sw_tail_old != ring->sw_tail;
+		sw_tail_old = aq_ring_next_dx(ring, sw_tail_old)) {
+		struct hw_atl_rxd_s *rxd =
+			(struct hw_atl_rxd_s *)&ring->dx_ring[sw_tail_old *
+							HW_ATL_A0_RXD_SIZE];
+
+		struct aq_ring_buff_s *buff = &ring->buff_ring[sw_tail_old];
+
+		rxd->buf_addr = buff->pa;
+		rxd->hdr_addr = 0U;
+	}
+
+	hw_atl_reg_rx_dma_desc_tail_ptr_set(self, sw_tail_old, ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_tx_head_update(struct aq_hw_s *self,
+					    struct aq_ring_s *ring)
+{
+	int err = 0;
+	unsigned int hw_head = hw_atl_tdm_tx_desc_head_ptr_get(self, ring->idx);
+
+	if (aq_utils_obj_test(&self->flags, AQ_HW_FLAG_ERR_UNPLUG)) {
+		err = -ENXIO;
+		goto err_exit;
+	}
+	ring->hw_head = hw_head;
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_ring_rx_receive(struct aq_hw_s *self,
+					struct aq_ring_s *ring)
+{
+	for (; ring->hw_head != ring->sw_tail;
+		ring->hw_head = aq_ring_next_dx(ring, ring->hw_head)) {
+		struct aq_ring_buff_s *buff = NULL;
+		struct hw_atl_rxd_wb_s *rxd_wb = (struct hw_atl_rxd_wb_s *)
+			&ring->dx_ring[ring->hw_head * HW_ATL_A0_RXD_SIZE];
+
+		unsigned int is_err = 1U;
+		unsigned int is_rx_check_sum_enabled = 0U;
+		unsigned int pkt_type = 0U;
+
+		if (!(rxd_wb->status & 0x5U)) { /* RxD is not done */
+			if ((1U << 4) &
+			hw_atl_reg_rx_dma_desc_status_get(self, ring->idx)) {
+				hw_atl_rdm_rx_desc_en_set(self, false, ring->idx);
+				hw_atl_rdm_rx_desc_res_set(self, true, ring->idx);
+				hw_atl_rdm_rx_desc_res_set(self, false, ring->idx);
+				hw_atl_rdm_rx_desc_en_set(self, true, ring->idx);
+			}
+
+			if (ring->hw_head ||
+			    (hw_atl_rdm_rx_desc_head_ptr_get(self,
+							     ring->idx) < 2U)) {
+				break;
+			} else if (!(rxd_wb->status & 0x1U)) {
+				struct hw_atl_rxd_wb_s *rxd_wb1 =
+					(struct hw_atl_rxd_wb_s *)
+					(&ring->dx_ring[(1U) *
+						HW_ATL_A0_RXD_SIZE]);
+
+				if ((rxd_wb1->status & 0x1U)) {
+					rxd_wb->pkt_len = 1514U;
+					rxd_wb->status = 3U;
+				} else {
+					break;
+				}
+			}
+		}
+
+		buff = &ring->buff_ring[ring->hw_head];
+
+		if (0x3U != (rxd_wb->status & 0x3U))
+			rxd_wb->status |= 4;
+
+		is_err = (0x0000001CU & rxd_wb->status);
+		is_rx_check_sum_enabled = (rxd_wb->type) & (0x3U << 19);
+		pkt_type = 0xFFU & (rxd_wb->type >> 4);
+
+		if (is_rx_check_sum_enabled) {
+			if (0x0U == (pkt_type & 0x3U))
+				buff->is_ip_cso = (is_err & 0x08U) ? 0 : 1;
+
+			if (0x4U == (pkt_type & 0x1CU))
+				buff->is_udp_cso = (is_err & 0x10U) ? 0 : 1;
+			else if (0x0U == (pkt_type & 0x1CU))
+				buff->is_tcp_cso = (is_err & 0x10U) ? 0 : 1;
+
+			/* Checksum offload workaround for small packets */
+			if (rxd_wb->pkt_len <= 60) {
+				buff->is_ip_cso = 0U;
+				buff->is_cso_err = 0U;
+			}
+		}
+
+		is_err &= ~0x18U;
+		is_err &= ~0x04U;
+
+		if (is_err || rxd_wb->type & 0x1000U) {
+			/* status error or DMA error */
+			buff->is_error = 1U;
+		} else {
+			if (self->aq_nic_cfg->is_rss) {
+				/* last 4 byte */
+				u16 rss_type = rxd_wb->type & 0xFU;
+
+				if (rss_type && rss_type < 0x8U) {
+					buff->is_hash_l4 = (rss_type == 0x4 ||
+							rss_type == 0x5);
+					buff->rss_hash = rxd_wb->rss_hash;
+				}
+			}
+
+			if (HW_ATL_A0_RXD_WB_STAT2_EOP & rxd_wb->status) {
+				buff->len = rxd_wb->pkt_len %
+					AQ_CFG_RX_FRAME_MAX;
+				buff->len = buff->len ?
+					buff->len : AQ_CFG_RX_FRAME_MAX;
+				buff->next = 0U;
+				buff->is_eop = 1U;
+			} else {
+				/* jumbo */
+				buff->next = aq_ring_next_dx(ring,
+							     ring->hw_head);
+				++ring->stats.rx.jumbo_packets;
+			}
+		}
+	}
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_irq_enable(struct aq_hw_s *self, u64 mask)
+{
+	hw_atl_itr_irq_msk_setlsw_set(self, LODWORD(mask) |
+			       (1U << HW_ATL_A0_ERR_INT));
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_irq_disable(struct aq_hw_s *self, u64 mask)
+{
+	hw_atl_itr_irq_msk_clearlsw_set(self, LODWORD(mask));
+	hw_atl_itr_irq_status_clearlsw_set(self, LODWORD(mask));
+
+	if ((1U << 16) & hw_atl_reg_gen_irq_status_get(self))
+		atomic_inc(&self->dpc);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_irq_read(struct aq_hw_s *self, u64 *mask)
+{
+	*mask = hw_atl_itr_irq_statuslsw_get(self);
+	return aq_hw_err_from_flags(self);
+}
+
+#define IS_FILTER_ENABLED(_F_) ((packet_filter & (_F_)) ? 1U : 0U)
+
+static int hw_atl_a0_hw_packet_filter_set(struct aq_hw_s *self,
+					  unsigned int packet_filter)
+{
+	unsigned int i = 0U;
+
+	hw_atl_rpfl2promiscuous_mode_en_set(self,
+					    IS_FILTER_ENABLED(IFF_PROMISC));
+	hw_atl_rpfl2multicast_flr_en_set(self,
+					 IS_FILTER_ENABLED(IFF_MULTICAST), 0);
+	hw_atl_rpfl2broadcast_en_set(self, IS_FILTER_ENABLED(IFF_BROADCAST));
+
+	self->aq_nic_cfg->is_mc_list_enabled =
+			IS_FILTER_ENABLED(IFF_MULTICAST);
+
+	for (i = HW_ATL_A0_MAC_MIN; i < HW_ATL_A0_MAC_MAX; ++i)
+		hw_atl_rpfl2_uc_flr_en_set(self,
+					   (self->aq_nic_cfg->is_mc_list_enabled &&
+					   (i <= self->aq_nic_cfg->mc_list_count)) ?
+					    1U : 0U, i);
+
+	return aq_hw_err_from_flags(self);
+}
+
+#undef IS_FILTER_ENABLED
+
+static int hw_atl_a0_hw_multicast_list_set(struct aq_hw_s *self,
+					   u8 ar_mac
+					   [AQ_CFG_MULTICAST_ADDRESS_MAX]
+					   [ETH_ALEN],
+					   u32 count)
+{
+	int err = 0;
+
+	if (count > (HW_ATL_A0_MAC_MAX - HW_ATL_A0_MAC_MIN)) {
+		err = EBADRQC;
+		goto err_exit;
+	}
+	for (self->aq_nic_cfg->mc_list_count = 0U;
+			self->aq_nic_cfg->mc_list_count < count;
+			++self->aq_nic_cfg->mc_list_count) {
+		u32 i = self->aq_nic_cfg->mc_list_count;
+		u32 h = (ar_mac[i][0] << 8) | (ar_mac[i][1]);
+		u32 l = (ar_mac[i][2] << 24) | (ar_mac[i][3] << 16) |
+					(ar_mac[i][4] << 8) | ar_mac[i][5];
+
+		hw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_A0_MAC_MIN + i);
+
+		hw_atl_rpfl2unicast_dest_addresslsw_set(self,
+							l,
+							HW_ATL_A0_MAC_MIN + i);
+
+		hw_atl_rpfl2unicast_dest_addressmsw_set(self,
+							h,
+							HW_ATL_A0_MAC_MIN + i);
+
+		hw_atl_rpfl2_uc_flr_en_set(self,
+					   (self->aq_nic_cfg->is_mc_list_enabled),
+					   HW_ATL_A0_MAC_MIN + i);
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_a0_hw_interrupt_moderation_set(struct aq_hw_s *self)
+{
+	unsigned int i = 0U;
+	u32 itr_rx;
+
+	if (self->aq_nic_cfg->itr) {
+		if (self->aq_nic_cfg->itr != AQ_CFG_INTERRUPT_MODERATION_AUTO) {
+			u32 itr_ = (self->aq_nic_cfg->itr >> 1);
+
+			itr_ = min(AQ_CFG_IRQ_MASK, itr_);
+
+			itr_rx = 0x80000000U | (itr_ << 0x10);
+		} else  {
+			u32 n = 0xFFFFU & aq_hw_read_reg(self, 0x00002A00U);
+
+			if (n < self->aq_link_status.mbps) {
+				itr_rx = 0U;
+			} else {
+				static unsigned int hw_timers_tbl_[] = {
+					0x01CU, /* 10Gbit */
+					0x039U, /* 5Gbit */
+					0x039U, /* 5Gbit 5GS */
+					0x073U, /* 2.5Gbit */
+					0x120U, /* 1Gbit */
+					0x1FFU, /* 100Mbit */
+				};
+
+				unsigned int speed_index =
+					hw_atl_utils_mbps_2_speed_index(
+						self->aq_link_status.mbps);
+
+				itr_rx = 0x80000000U |
+					(hw_timers_tbl_[speed_index] << 0x10U);
+			}
+
+			aq_hw_write_reg(self, 0x00002A00U, 0x40000000U);
+			aq_hw_write_reg(self, 0x00002A00U, 0x8D000000U);
+		}
+	} else {
+		itr_rx = 0U;
+	}
+
+	for (i = HW_ATL_A0_RINGS_MAX; i--;)
+		hw_atl_reg_irq_thr_set(self, itr_rx, i);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_stop(struct aq_hw_s *self)
+{
+	hw_atl_a0_hw_irq_disable(self, HW_ATL_A0_INT_MASK);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_tx_stop(struct aq_hw_s *self,
+				     struct aq_ring_s *ring)
+{
+	hw_atl_tdm_tx_desc_en_set(self, 0U, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_a0_hw_ring_rx_stop(struct aq_hw_s *self,
+				     struct aq_ring_s *ring)
+{
+	hw_atl_rdm_rx_desc_en_set(self, 0U, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+const struct aq_hw_ops hw_atl_ops_a0 = {
+	.hw_set_mac_address   = hw_atl_a0_hw_mac_addr_set,
+	.hw_init              = hw_atl_a0_hw_init,
+	.hw_reset             = hw_atl_a0_hw_reset,
+	.hw_start             = hw_atl_a0_hw_start,
+	.hw_ring_tx_start     = hw_atl_a0_hw_ring_tx_start,
+	.hw_ring_tx_stop      = hw_atl_a0_hw_ring_tx_stop,
+	.hw_ring_rx_start     = hw_atl_a0_hw_ring_rx_start,
+	.hw_ring_rx_stop      = hw_atl_a0_hw_ring_rx_stop,
+	.hw_stop              = hw_atl_a0_hw_stop,
+
+	.hw_ring_tx_xmit         = hw_atl_a0_hw_ring_tx_xmit,
+	.hw_ring_tx_head_update  = hw_atl_a0_hw_ring_tx_head_update,
+
+	.hw_ring_rx_receive      = hw_atl_a0_hw_ring_rx_receive,
+	.hw_ring_rx_fill         = hw_atl_a0_hw_ring_rx_fill,
+
+	.hw_irq_enable           = hw_atl_a0_hw_irq_enable,
+	.hw_irq_disable          = hw_atl_a0_hw_irq_disable,
+	.hw_irq_read             = hw_atl_a0_hw_irq_read,
+
+	.hw_ring_rx_init             = hw_atl_a0_hw_ring_rx_init,
+	.hw_ring_tx_init             = hw_atl_a0_hw_ring_tx_init,
+	.hw_packet_filter_set        = hw_atl_a0_hw_packet_filter_set,
+	.hw_multicast_list_set       = hw_atl_a0_hw_multicast_list_set,
+	.hw_interrupt_moderation_set = hw_atl_a0_hw_interrupt_moderation_set,
+	.hw_rss_set                  = hw_atl_a0_hw_rss_set,
+	.hw_rss_hash_set             = hw_atl_a0_hw_rss_hash_set,
+	.hw_get_regs                 = hw_atl_utils_hw_get_regs,
+	.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,
+	.hw_get_fw_version           = hw_atl_utils_get_fw_version,
+};
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.h
new file mode 100644
index 00000000..25fe954
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0.h
@@ -0,0 +1,26 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_a0.h: Declaration of abstract interface for Atlantic hardware
+ * specific functions.
+ */
+
+#ifndef HW_ATL_A0_H
+#define HW_ATL_A0_H
+
+#include "../aq_common.h"
+
+extern const struct aq_hw_caps_s hw_atl_a0_caps_aqc100;
+extern const struct aq_hw_caps_s hw_atl_a0_caps_aqc107;
+extern const struct aq_hw_caps_s hw_atl_a0_caps_aqc108;
+extern const struct aq_hw_caps_s hw_atl_a0_caps_aqc109;
+
+extern const struct aq_hw_ops hw_atl_ops_a0;
+
+#endif /* HW_ATL_A0_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0_internal.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0_internal.h
new file mode 100644
index 00000000..a021dc4
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_a0_internal.h
@@ -0,0 +1,93 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_a0_internal.h: Definition of Atlantic A0 chip specific
+ * constants.
+ */
+
+#ifndef HW_ATL_A0_INTERNAL_H
+#define HW_ATL_A0_INTERNAL_H
+
+#include "../aq_common.h"
+
+#define HW_ATL_A0_MTU_JUMBO 9014U
+
+#define HW_ATL_A0_TX_RINGS 4U
+#define HW_ATL_A0_RX_RINGS 4U
+
+#define HW_ATL_A0_RINGS_MAX 32U
+#define HW_ATL_A0_TXD_SIZE  16U
+#define HW_ATL_A0_RXD_SIZE  16U
+
+#define HW_ATL_A0_MAC      0U
+#define HW_ATL_A0_MAC_MIN  1U
+#define HW_ATL_A0_MAC_MAX  33U
+
+/* interrupts */
+#define HW_ATL_A0_ERR_INT 8U
+#define HW_ATL_A0_INT_MASK  0xFFFFFFFFU
+
+#define HW_ATL_A0_TXD_CTL2_LEN        0xFFFFC000U
+#define HW_ATL_A0_TXD_CTL2_CTX_EN     0x00002000U
+#define HW_ATL_A0_TXD_CTL2_CTX_IDX    0x00001000U
+
+#define HW_ATL_A0_TXD_CTL_DESC_TYPE_TXD   0x00000001U
+#define HW_ATL_A0_TXD_CTL_DESC_TYPE_TXC   0x00000002U
+#define HW_ATL_A0_TXD_CTL_BLEN        0x000FFFF0U
+#define HW_ATL_A0_TXD_CTL_DD          0x00100000U
+#define HW_ATL_A0_TXD_CTL_EOP         0x00200000U
+
+#define HW_ATL_A0_TXD_CTL_CMD_X       0x3FC00000U
+
+#define HW_ATL_A0_TXD_CTL_CMD_VLAN    BIT(22)
+#define HW_ATL_A0_TXD_CTL_CMD_FCS     BIT(23)
+#define HW_ATL_A0_TXD_CTL_CMD_IPCSO   BIT(24)
+#define HW_ATL_A0_TXD_CTL_CMD_TUCSO   BIT(25)
+#define HW_ATL_A0_TXD_CTL_CMD_LSO     BIT(26)
+#define HW_ATL_A0_TXD_CTL_CMD_WB      BIT(27)
+#define HW_ATL_A0_TXD_CTL_CMD_VXLAN   BIT(28)
+
+#define HW_ATL_A0_TXD_CTL_CMD_IPV6    BIT(21)
+#define HW_ATL_A0_TXD_CTL_CMD_TCP     BIT(22)
+
+#define HW_ATL_A0_MPI_CONTROL_ADR     0x0368U
+#define HW_ATL_A0_MPI_STATE_ADR       0x036CU
+
+#define HW_ATL_A0_MPI_SPEED_MSK       0xFFFFU
+#define HW_ATL_A0_MPI_SPEED_SHIFT     16U
+
+#define HW_ATL_A0_TXBUF_MAX 160U
+#define HW_ATL_A0_RXBUF_MAX 320U
+
+#define HW_ATL_A0_RSS_REDIRECTION_MAX 64U
+#define HW_ATL_A0_RSS_REDIRECTION_BITS 3U
+
+#define HW_ATL_A0_TC_MAX 1U
+#define HW_ATL_A0_RSS_MAX 8U
+
+#define HW_ATL_A0_FW_SEMA_RAM           0x2U
+
+#define HW_ATL_A0_RXD_DD    0x1U
+#define HW_ATL_A0_RXD_NCEA0 0x1U
+
+#define HW_ATL_A0_RXD_WB_STAT2_EOP     0x0002U
+
+#define HW_ATL_A0_UCP_0X370_REG  0x370U
+
+#define HW_ATL_A0_FW_VER_EXPECTED 0x01050006U
+
+#define HW_ATL_A0_MIN_RXD \
+	(ALIGN(AQ_CFG_SKB_FRAGS_MAX + 1U, AQ_HW_RXD_MULTIPLE))
+#define HW_ATL_A0_MIN_TXD \
+	(ALIGN(AQ_CFG_SKB_FRAGS_MAX + 1U, AQ_HW_TXD_MULTIPLE))
+
+#define HW_ATL_A0_MAX_RXD 8184U
+#define HW_ATL_A0_MAX_TXD 8184U
+
+#endif /* HW_ATL_A0_INTERNAL_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.c b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.c
new file mode 100644
index 00000000..5c5534b
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.c
@@ -0,0 +1,974 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_b0.c: Definition of Atlantic hardware specific functions. */
+
+#include "../aq_hw.h"
+#include "../aq_hw_utils.h"
+#include "../aq_ring.h"
+#include "../aq_nic.h"
+#include "hw_atl_b0.h"
+#include "hw_atl_utils.h"
+#include "hw_atl_llh.h"
+#include "hw_atl_b0_internal.h"
+#include "hw_atl_llh_internal.h"
+
+#define DEFAULT_B0_BOARD_BASIC_CAPABILITIES \
+	.is_64_dma = true,		  \
+	.msix_irqs = 4U,		  \
+	.irq_mask = ~0U,		  \
+	.vecs = HW_ATL_B0_RSS_MAX,	  \
+	.tcs = HW_ATL_B0_TC_MAX,	  \
+	.rxd_alignment = 1U,		  \
+	.rxd_size = HW_ATL_B0_RXD_SIZE,   \
+	.rxds_max = HW_ATL_B0_MAX_RXD,    \
+	.rxds_min = HW_ATL_B0_MIN_RXD,    \
+	.txd_alignment = 1U,		  \
+	.txd_size = HW_ATL_B0_TXD_SIZE,   \
+	.txds_max = HW_ATL_B0_MAX_TXD,    \
+	.txds_min = HW_ATL_B0_MIN_TXD,    \
+	.txhwb_alignment = 4096U,	  \
+	.tx_rings = HW_ATL_B0_TX_RINGS,   \
+	.rx_rings = HW_ATL_B0_RX_RINGS,   \
+	.hw_features = NETIF_F_HW_CSUM |  \
+			NETIF_F_RXCSUM |  \
+			NETIF_F_RXHASH |  \
+			NETIF_F_SG |      \
+			NETIF_F_TSO |     \
+			NETIF_F_LRO,      \
+	.hw_priv_flags = IFF_UNICAST_FLT, \
+	.flow_control = true,		  \
+	.mtu = HW_ATL_B0_MTU_JUMBO,	  \
+	.mac_regs_count = 88,		  \
+	.hw_alive_check_addr = 0x10U
+
+const struct aq_hw_caps_s hw_atl_b0_caps_aqc100 = {
+	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_FIBRE,
+	.link_speed_msk = AQ_NIC_RATE_10G|
+			  AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_b0_caps_aqc107 = {
+	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_10G|
+			  AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_b0_caps_aqc108 = {
+	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_5G|
+			  AQ_NIC_RATE_2GS|
+			  AQ_NIC_RATE_1G|
+			  AQ_NIC_RATE_100M,
+};
+
+const struct aq_hw_caps_s hw_atl_b0_caps_aqc109 = {
+	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
+	.media_type = AQ_HW_MEDIA_TYPE_TP,
+	.link_speed_msk = AQ_NIC_RATE_2GS |
+			  AQ_NIC_RATE_1G  |
+			  AQ_NIC_RATE_100M,
+};
+
+static int hw_atl_b0_hw_reset(struct aq_hw_s *self)
+{
+	int err = 0;
+
+	err = hw_atl_utils_soft_reset(self);
+	if (err)
+		return err;
+
+	self->aq_fw_ops->set_state(self, MPI_RESET);
+
+	err = aq_hw_err_from_flags(self);
+
+	return err;
+}
+
+static int hw_atl_b0_hw_qos_set(struct aq_hw_s *self)
+{
+	u32 tc = 0U;
+	u32 buff_size = 0U;
+	unsigned int i_priority = 0U;
+	bool is_rx_flow_control = false;
+
+	/* TPS Descriptor rate init */
+	hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);
+	hw_atl_tps_tx_pkt_shed_desc_rate_lim_set(self, 0xA);
+
+	/* TPS VM init */
+	hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(self, 0U);
+
+	/* TPS TC credits init */
+	hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);
+	hw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, 0U);
+
+	hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, 0xFFF, 0U);
+	hw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, 0x64, 0U);
+	hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, 0x50, 0U);
+	hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, 0x1E, 0U);
+
+	/* Tx buf size */
+	buff_size = HW_ATL_B0_TXBUF_MAX;
+
+	hw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, buff_size, tc);
+	hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024 / 32U) * 66U) /
+						   100U, tc);
+	hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024 / 32U) * 50U) /
+						   100U, tc);
+
+	/* QoS Rx buf size per TC */
+	tc = 0;
+	is_rx_flow_control = (AQ_NIC_FC_RX & self->aq_nic_cfg->flow_control);
+	buff_size = HW_ATL_B0_RXBUF_MAX;
+
+	hw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, buff_size, tc);
+	hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024U / 32U) * 66U) /
+						   100U, tc);
+	hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self,
+						   (buff_size *
+						   (1024U / 32U) * 50U) /
+						   100U, tc);
+	hw_atl_rpb_rx_xoff_en_per_tc_set(self, is_rx_flow_control ? 1U : 0U, tc);
+
+	/* QoS 802.1p priority -> TC mapping */
+	for (i_priority = 8U; i_priority--;)
+		hw_atl_rpf_rpb_user_priority_tc_map_set(self, i_priority, 0U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,
+				     struct aq_rss_parameters *rss_params)
+{
+	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
+	int err = 0;
+	unsigned int i = 0U;
+	unsigned int addr = 0U;
+
+	for (i = 10, addr = 0U; i--; ++addr) {
+		u32 key_data = cfg->is_rss ?
+			__swab32(rss_params->hash_secret_key[i]) : 0U;
+		hw_atl_rpf_rss_key_wr_data_set(self, key_data);
+		hw_atl_rpf_rss_key_addr_set(self, addr);
+		hw_atl_rpf_rss_key_wr_en_set(self, 1U);
+		AQ_HW_WAIT_FOR(hw_atl_rpf_rss_key_wr_en_get(self) == 0,
+			       1000U, 10U);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_rss_set(struct aq_hw_s *self,
+				struct aq_rss_parameters *rss_params)
+{
+	u8 *indirection_table =	rss_params->indirection_table;
+	u32 i = 0U;
+	u32 num_rss_queues = max(1U, self->aq_nic_cfg->num_rss_queues);
+	int err = 0;
+	u16 bitary[(HW_ATL_B0_RSS_REDIRECTION_MAX *
+					HW_ATL_B0_RSS_REDIRECTION_BITS / 16U)];
+
+	memset(bitary, 0, sizeof(bitary));
+
+	for (i = HW_ATL_B0_RSS_REDIRECTION_MAX; i--;) {
+		(*(u32 *)(bitary + ((i * 3U) / 16U))) |=
+			((indirection_table[i] % num_rss_queues) <<
+			((i * 3U) & 0xFU));
+	}
+
+	for (i = ARRAY_SIZE(bitary); i--;) {
+		hw_atl_rpf_rss_redir_tbl_wr_data_set(self, bitary[i]);
+		hw_atl_rpf_rss_redir_tbl_addr_set(self, i);
+		hw_atl_rpf_rss_redir_wr_en_set(self, 1U);
+		AQ_HW_WAIT_FOR(hw_atl_rpf_rss_redir_wr_en_get(self) == 0,
+			       1000U, 10U);
+		if (err < 0)
+			goto err_exit;
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_offload_set(struct aq_hw_s *self,
+				    struct aq_nic_cfg_s *aq_nic_cfg)
+{
+	unsigned int i;
+
+	/* TX checksums offloads*/
+	hw_atl_tpo_ipv4header_crc_offload_en_set(self, 1);
+	hw_atl_tpo_tcp_udp_crc_offload_en_set(self, 1);
+
+	/* RX checksums offloads*/
+	hw_atl_rpo_ipv4header_crc_offload_en_set(self, 1);
+	hw_atl_rpo_tcp_udp_crc_offload_en_set(self, 1);
+
+	/* LSO offloads*/
+	hw_atl_tdm_large_send_offload_en_set(self, 0xFFFFFFFFU);
+
+/* LRO offloads */
+	{
+		unsigned int val = (8U < HW_ATL_B0_LRO_RXD_MAX) ? 0x3U :
+			((4U < HW_ATL_B0_LRO_RXD_MAX) ? 0x2U :
+			((2U < HW_ATL_B0_LRO_RXD_MAX) ? 0x1U : 0x0));
+
+		for (i = 0; i < HW_ATL_B0_RINGS_MAX; i++)
+			hw_atl_rpo_lro_max_num_of_descriptors_set(self, val, i);
+
+		hw_atl_rpo_lro_time_base_divider_set(self, 0x61AU);
+		hw_atl_rpo_lro_inactive_interval_set(self, 0);
+		hw_atl_rpo_lro_max_coalescing_interval_set(self, 2);
+
+		hw_atl_rpo_lro_qsessions_lim_set(self, 1U);
+
+		hw_atl_rpo_lro_total_desc_lim_set(self, 2U);
+
+		hw_atl_rpo_lro_patch_optimization_en_set(self, 0U);
+
+		hw_atl_rpo_lro_min_pay_of_first_pkt_set(self, 10U);
+
+		hw_atl_rpo_lro_pkt_lim_set(self, 1U);
+
+		hw_atl_rpo_lro_en_set(self,
+				      aq_nic_cfg->is_lro ? 0xFFFFFFFFU : 0U);
+	}
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_init_tx_path(struct aq_hw_s *self)
+{
+	hw_atl_thm_lso_tcp_flag_of_first_pkt_set(self, 0x0FF6U);
+	hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(self, 0x0FF6U);
+	hw_atl_thm_lso_tcp_flag_of_last_pkt_set(self, 0x0F7FU);
+
+	/* Tx interrupts */
+	hw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 1U);
+
+	/* misc */
+	aq_hw_write_reg(self, 0x00007040U, IS_CHIP_FEATURE(TPO2) ?
+			0x00010000U : 0x00000000U);
+	hw_atl_tdm_tx_dca_en_set(self, 0U);
+	hw_atl_tdm_tx_dca_mode_set(self, 0U);
+
+	hw_atl_tpb_tx_path_scp_ins_en_set(self, 1U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_init_rx_path(struct aq_hw_s *self)
+{
+	struct aq_nic_cfg_s *cfg = self->aq_nic_cfg;
+	unsigned int control_reg_val = 0U;
+	int i;
+
+	/* Rx TC/RSS number config */
+	hw_atl_rpb_rpf_rx_traf_class_mode_set(self, 1U);
+
+	/* Rx flow control */
+	hw_atl_rpb_rx_flow_ctl_mode_set(self, 1U);
+
+	/* RSS Ring selection */
+	hw_atl_reg_rx_flr_rss_control1set(self, cfg->is_rss ?
+					0xB3333333U : 0x00000000U);
+
+	/* Multicast filters */
+	for (i = HW_ATL_B0_MAC_MAX; i--;) {
+		hw_atl_rpfl2_uc_flr_en_set(self, (i == 0U) ? 1U : 0U, i);
+		hw_atl_rpfl2unicast_flr_act_set(self, 1U, i);
+	}
+
+	hw_atl_reg_rx_flr_mcst_flr_msk_set(self, 0x00000000U);
+	hw_atl_reg_rx_flr_mcst_flr_set(self, 0x00010FFFU, 0U);
+
+	/* Vlan filters */
+	hw_atl_rpf_vlan_outer_etht_set(self, 0x88A8U);
+	hw_atl_rpf_vlan_inner_etht_set(self, 0x8100U);
+
+	if (cfg->vlan_id) {
+		hw_atl_rpf_vlan_flr_act_set(self, 1U, 0U);
+		hw_atl_rpf_vlan_id_flr_set(self, 0U, 0U);
+		hw_atl_rpf_vlan_flr_en_set(self, 0U, 0U);
+
+		hw_atl_rpf_vlan_accept_untagged_packets_set(self, 1U);
+		hw_atl_rpf_vlan_untagged_act_set(self, 1U);
+
+		hw_atl_rpf_vlan_flr_act_set(self, 1U, 1U);
+		hw_atl_rpf_vlan_id_flr_set(self, cfg->vlan_id, 0U);
+		hw_atl_rpf_vlan_flr_en_set(self, 1U, 1U);
+	} else {
+		hw_atl_rpf_vlan_prom_mode_en_set(self, 1);
+	}
+
+	/* Rx Interrupts */
+	hw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 1U);
+
+	/* misc */
+	control_reg_val = IS_CHIP_FEATURE(RPF2) ? 0x000F0000U : 0x00000000U;
+
+	/* RSS hash type set for IP/TCP */
+	control_reg_val |= 0x1EU;
+
+	aq_hw_write_reg(self, 0x00005040U, control_reg_val);	
+
+	hw_atl_rpfl2broadcast_flr_act_set(self, 1U);
+	hw_atl_rpfl2broadcast_count_threshold_set(self, 0xFFFFU & (~0U / 256U));
+
+	hw_atl_rdm_rx_dca_en_set(self, 0U);
+	hw_atl_rdm_rx_dca_mode_set(self, 0U);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
+{
+	int err = 0;
+	unsigned int h = 0U;
+	unsigned int l = 0U;
+
+	if (!mac_addr) {
+		err = -EINVAL;
+		goto err_exit;
+	}
+	h = (mac_addr[0] << 8) | (mac_addr[1]);
+	l = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
+		(mac_addr[4] << 8) | mac_addr[5];
+
+	hw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_B0_MAC);
+	hw_atl_rpfl2unicast_dest_addresslsw_set(self, l, HW_ATL_B0_MAC);
+	hw_atl_rpfl2unicast_dest_addressmsw_set(self, h, HW_ATL_B0_MAC);
+	hw_atl_rpfl2_uc_flr_en_set(self, 1U, HW_ATL_B0_MAC);
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_init(struct aq_hw_s *self, u8 *mac_addr)
+{
+	static u32 aq_hw_atl_igcr_table_[4][2] = {
+		{ 0x20000000U, 0x20000000U }, /* AQ_IRQ_INVALID */
+		{ 0x20000080U, 0x20000080U }, /* AQ_IRQ_LEGACY */
+		{ 0x20000021U, 0x20000025U }, /* AQ_IRQ_MSI */
+		{ 0x20000022U, 0x20000026U }  /* AQ_IRQ_MSIX */
+	};
+
+	int err = 0;
+	u32 val;
+
+	struct aq_nic_cfg_s *aq_nic_cfg = self->aq_nic_cfg;
+
+	hw_atl_b0_hw_init_tx_path(self);
+	hw_atl_b0_hw_init_rx_path(self);
+
+	hw_atl_b0_hw_mac_addr_set(self, mac_addr);
+
+	self->aq_fw_ops->set_link_speed(self, aq_nic_cfg->link_speed_msk);
+	self->aq_fw_ops->set_state(self, MPI_INIT);
+
+	hw_atl_b0_hw_qos_set(self);
+	hw_atl_b0_hw_rss_set(self, &aq_nic_cfg->aq_rss);
+	hw_atl_b0_hw_rss_hash_set(self, &aq_nic_cfg->aq_rss);
+
+	/* Force limit MRRS on RDM/TDM to 2K */
+	val = aq_hw_read_reg(self, HW_ATL_PCI_REG_CONTROL6_ADR);
+	aq_hw_write_reg(self, HW_ATL_PCI_REG_CONTROL6_ADR,
+			(val & ~0x707) | 0x404);
+
+	/* TX DMA total request limit. B0 hardware is not capable to
+	 * handle more than (8K-MRRS) incoming DMA data.
+	 * Value 24 in 256byte units
+	 */
+	aq_hw_write_reg(self, HW_ATL_TX_DMA_TOTAL_REQ_LIMIT_ADR, 24);
+
+	/* Reset link status and read out initial hardware counters */
+	self->aq_link_status.mbps = 0;
+	self->aq_fw_ops->update_stats(self);
+
+	err = aq_hw_err_from_flags(self);
+	if (err < 0)
+		goto err_exit;
+
+	/* Interrupts */
+	hw_atl_reg_irq_glb_ctl_set(self,
+				   aq_hw_atl_igcr_table_[aq_nic_cfg->irq_type]
+						 [(aq_nic_cfg->vecs > 1U) ?
+						 1 : 0]);
+
+	hw_atl_itr_irq_auto_masklsw_set(self, aq_nic_cfg->aq_hw_caps->irq_mask);
+
+	/* Interrupts */
+	hw_atl_reg_gen_irq_map_set(self,
+				   ((HW_ATL_B0_ERR_INT << 0x18) | (1U << 0x1F)) |
+			    ((HW_ATL_B0_ERR_INT << 0x10) | (1U << 0x17)), 0U);
+
+	hw_atl_b0_hw_offload_set(self, aq_nic_cfg);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_ring_tx_start(struct aq_hw_s *self,
+				      struct aq_ring_s *ring)
+{
+	hw_atl_tdm_tx_desc_en_set(self, 1, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_rx_start(struct aq_hw_s *self,
+				      struct aq_ring_s *ring)
+{
+	hw_atl_rdm_rx_desc_en_set(self, 1, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_start(struct aq_hw_s *self)
+{
+	hw_atl_tpb_tx_buff_en_set(self, 1);
+	hw_atl_rpb_rx_buff_en_set(self, 1);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_tx_ring_tail_update(struct aq_hw_s *self,
+					    struct aq_ring_s *ring)
+{
+	hw_atl_reg_tx_dma_desc_tail_ptr_set(self, ring->sw_tail, ring->idx);
+	return 0;
+}
+
+static int hw_atl_b0_hw_ring_tx_xmit(struct aq_hw_s *self,
+				     struct aq_ring_s *ring,
+				     unsigned int frags)
+{
+	struct aq_ring_buff_s *buff = NULL;
+	struct hw_atl_txd_s *txd = NULL;
+	unsigned int buff_pa_len = 0U;
+	unsigned int pkt_len = 0U;
+	unsigned int frag_count = 0U;
+	bool is_gso = false;
+
+	buff = &ring->buff_ring[ring->sw_tail];
+	pkt_len = (buff->is_eop && buff->is_sop) ? buff->len : buff->len_pkt;
+
+	for (frag_count = 0; frag_count < frags; frag_count++) {
+		txd = (struct hw_atl_txd_s *)&ring->dx_ring[ring->sw_tail *
+						HW_ATL_B0_TXD_SIZE];
+		txd->ctl = 0;
+		txd->ctl2 = 0;
+		txd->buf_addr = 0;
+
+		buff = &ring->buff_ring[ring->sw_tail];
+
+		if (buff->is_txc) {
+			txd->ctl |= (buff->len_l3 << 31) |
+				(buff->len_l2 << 24) |
+				HW_ATL_B0_TXD_CTL_CMD_TCP |
+				HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;
+			txd->ctl2 |= (buff->mss << 16) |
+				(buff->len_l4 << 8) |
+				(buff->len_l3 >> 1);
+
+			pkt_len -= (buff->len_l4 +
+				    buff->len_l3 +
+				    buff->len_l2);
+			is_gso = true;
+
+			if (buff->is_ipv6)
+				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_IPV6;
+		} else {
+			buff_pa_len = buff->len;
+
+			txd->buf_addr = buff->pa;
+			txd->ctl |= (HW_ATL_B0_TXD_CTL_BLEN &
+						((u32)buff_pa_len << 4));
+			txd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXD;
+			/* PAY_LEN */
+			txd->ctl2 |= HW_ATL_B0_TXD_CTL2_LEN & (pkt_len << 14);
+
+			if (is_gso) {
+				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_LSO;
+				txd->ctl2 |= HW_ATL_B0_TXD_CTL2_CTX_EN;
+			}
+
+			/* Tx checksum offloads */
+			if (buff->is_ip_cso)
+				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_IPCSO;
+
+			if (buff->is_udp_cso || buff->is_tcp_cso)
+				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_TUCSO;
+
+			if (unlikely(buff->is_eop)) {
+				txd->ctl |= HW_ATL_B0_TXD_CTL_EOP;
+				txd->ctl |= HW_ATL_B0_TXD_CTL_CMD_WB;
+				is_gso = false;
+			}
+		}
+
+		ring->sw_tail = aq_ring_next_dx(ring, ring->sw_tail);
+	}
+
+	wmb();
+
+	hw_atl_b0_hw_tx_ring_tail_update(self, ring);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_rx_init(struct aq_hw_s *self,
+				     struct aq_ring_s *aq_ring,
+				     struct aq_ring_param_s *aq_ring_param)
+{
+	u32 dma_desc_addr_lsw = (u32)aq_ring->dx_ring_pa;
+	u32 dma_desc_addr_msw = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);
+
+	hw_atl_rdm_rx_desc_en_set(self, false, aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);
+
+	hw_atl_reg_rx_dma_desc_base_addresslswset(self, dma_desc_addr_lsw,
+						  aq_ring->idx);
+
+	hw_atl_reg_rx_dma_desc_base_addressmswset(self,
+						  dma_desc_addr_msw, aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_data_buff_size_set(self,
+					      AQ_CFG_RX_FRAME_MAX / 1024U,
+				       aq_ring->idx);
+
+	hw_atl_rdm_rx_desc_head_buff_size_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);
+	hw_atl_rpo_rx_desc_vlan_stripping_set(self, 0U, aq_ring->idx);
+
+	/* Rx ring set mode */
+
+	/* Mapping interrupt vector */
+	hw_atl_itr_irq_map_rx_set(self, aq_ring_param->vec_idx, aq_ring->idx);
+	hw_atl_itr_irq_map_en_rx_set(self, true, aq_ring->idx);
+
+	hw_atl_rdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);
+	hw_atl_rdm_rx_desc_dca_en_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_head_dca_en_set(self, 0U, aq_ring->idx);
+	hw_atl_rdm_rx_pld_dca_en_set(self, 0U, aq_ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_tx_init(struct aq_hw_s *self,
+				     struct aq_ring_s *aq_ring,
+				     struct aq_ring_param_s *aq_ring_param)
+{
+	u32 dma_desc_lsw_addr = (u32)aq_ring->dx_ring_pa;
+	u32 dma_desc_msw_addr = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);
+
+	hw_atl_reg_tx_dma_desc_base_addresslswset(self, dma_desc_lsw_addr,
+						  aq_ring->idx);
+
+	hw_atl_reg_tx_dma_desc_base_addressmswset(self, dma_desc_msw_addr,
+						  aq_ring->idx);
+
+	hw_atl_tdm_tx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);
+
+	hw_atl_b0_hw_tx_ring_tail_update(self, aq_ring);
+
+	/* Set Tx threshold */
+	hw_atl_tdm_tx_desc_wr_wb_threshold_set(self, 0U, aq_ring->idx);
+
+	/* Mapping interrupt vector */
+	hw_atl_itr_irq_map_tx_set(self, aq_ring_param->vec_idx, aq_ring->idx);
+	hw_atl_itr_irq_map_en_tx_set(self, true, aq_ring->idx);
+
+	hw_atl_tdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);
+	hw_atl_tdm_tx_desc_dca_en_set(self, 0U, aq_ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_rx_fill(struct aq_hw_s *self,
+				     struct aq_ring_s *ring,
+				     unsigned int sw_tail_old)
+{
+	for (; sw_tail_old != ring->sw_tail;
+		sw_tail_old = aq_ring_next_dx(ring, sw_tail_old)) {
+		struct hw_atl_rxd_s *rxd =
+			(struct hw_atl_rxd_s *)&ring->dx_ring[sw_tail_old *
+							HW_ATL_B0_RXD_SIZE];
+
+		struct aq_ring_buff_s *buff = &ring->buff_ring[sw_tail_old];
+
+		rxd->buf_addr = buff->pa;
+		rxd->hdr_addr = 0U;
+	}
+
+	wmb();
+
+	hw_atl_reg_rx_dma_desc_tail_ptr_set(self, sw_tail_old, ring->idx);
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_tx_head_update(struct aq_hw_s *self,
+					    struct aq_ring_s *ring)
+{
+	int err = 0;
+	unsigned int hw_head_ = hw_atl_tdm_tx_desc_head_ptr_get(self, ring->idx);
+
+	if (aq_utils_obj_test(&self->flags, AQ_HW_FLAG_ERR_UNPLUG)) {
+		err = -ENXIO;
+		goto err_exit;
+	}
+	ring->hw_head = hw_head_;
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_ring_rx_receive(struct aq_hw_s *self,
+					struct aq_ring_s *ring)
+{
+	for (; ring->hw_head != ring->sw_tail;
+		ring->hw_head = aq_ring_next_dx(ring, ring->hw_head)) {
+		struct aq_ring_buff_s *buff = NULL;
+		struct hw_atl_rxd_wb_s *rxd_wb = (struct hw_atl_rxd_wb_s *)
+			&ring->dx_ring[ring->hw_head * HW_ATL_B0_RXD_SIZE];
+
+		unsigned int is_err = 1U;
+		unsigned int is_rx_check_sum_enabled = 0U;
+		unsigned int pkt_type = 0U;
+
+		if (!(rxd_wb->status & 0x1U)) { /* RxD is not done */
+			break;
+		}
+
+		buff = &ring->buff_ring[ring->hw_head];
+
+		is_err = (0x0000003CU & rxd_wb->status);
+
+		is_rx_check_sum_enabled = (rxd_wb->type) & (0x3U << 19);
+		is_err &= ~0x20U; /* exclude validity bit */
+
+		pkt_type = 0xFFU & (rxd_wb->type >> 4);
+
+		if (is_rx_check_sum_enabled) {
+			if (0x0U == (pkt_type & 0x3U))
+				buff->is_ip_cso = (is_err & 0x08U) ? 0U : 1U;
+
+			if (0x4U == (pkt_type & 0x1CU))
+				buff->is_udp_cso = buff->is_cso_err ? 0U : 1U;
+			else if (0x0U == (pkt_type & 0x1CU))
+				buff->is_tcp_cso = buff->is_cso_err ? 0U : 1U;
+
+			/* Checksum offload workaround for small packets */
+			if (rxd_wb->pkt_len <= 60) {
+				buff->is_ip_cso = 0U;
+				buff->is_cso_err = 0U;
+			}
+		}
+
+		is_err &= ~0x18U;
+
+		if (is_err || rxd_wb->type & 0x1000U) {
+			/* status error or DMA error */
+			buff->is_error = 1U;
+		} else {
+			if (self->aq_nic_cfg->is_rss) {
+				/* last 4 byte */
+				u16 rss_type = rxd_wb->type & 0xFU;
+
+				if (rss_type && rss_type < 0x8U) {
+					buff->is_hash_l4 = (rss_type == 0x4 ||
+					rss_type == 0x5);
+					buff->rss_hash = rxd_wb->rss_hash;
+				}
+			}
+
+			if (HW_ATL_B0_RXD_WB_STAT2_EOP & rxd_wb->status) {
+				buff->len = rxd_wb->pkt_len %
+					AQ_CFG_RX_FRAME_MAX;
+				buff->len = buff->len ?
+					buff->len : AQ_CFG_RX_FRAME_MAX;
+				buff->next = 0U;
+				buff->is_eop = 1U;
+			} else {
+				buff->len = rxd_wb->pkt_len > AQ_CFG_RX_FRAME_MAX ?
+					AQ_CFG_RX_FRAME_MAX : rxd_wb->pkt_len;
+
+				if (HW_ATL_B0_RXD_WB_STAT2_RSCCNT &
+					rxd_wb->status) {
+					/* LRO */
+					buff->next = rxd_wb->next_desc_ptr;
+					++ring->stats.rx.lro_packets;
+				} else {
+					/* jumbo */
+					buff->next =
+						aq_ring_next_dx(ring,
+								ring->hw_head);
+					++ring->stats.rx.jumbo_packets;
+				}
+			}
+		}
+	}
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask)
+{
+	hw_atl_itr_irq_msk_setlsw_set(self, LODWORD(mask));
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_irq_disable(struct aq_hw_s *self, u64 mask)
+{
+	hw_atl_itr_irq_msk_clearlsw_set(self, LODWORD(mask));
+	hw_atl_itr_irq_status_clearlsw_set(self, LODWORD(mask));
+
+	atomic_inc(&self->dpc);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask)
+{
+	*mask = hw_atl_itr_irq_statuslsw_get(self);
+	return aq_hw_err_from_flags(self);
+}
+
+#define IS_FILTER_ENABLED(_F_) ((packet_filter & (_F_)) ? 1U : 0U)
+
+static int hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,
+					  unsigned int packet_filter)
+{
+	unsigned int i = 0U;
+
+	hw_atl_rpfl2promiscuous_mode_en_set(self, IS_FILTER_ENABLED(IFF_PROMISC));
+	hw_atl_rpfl2multicast_flr_en_set(self,
+					 IS_FILTER_ENABLED(IFF_MULTICAST), 0);
+
+	hw_atl_rpfl2_accept_all_mc_packets_set(self,
+					       IS_FILTER_ENABLED(IFF_ALLMULTI));
+
+	hw_atl_rpfl2broadcast_en_set(self, IS_FILTER_ENABLED(IFF_BROADCAST));
+
+	self->aq_nic_cfg->is_mc_list_enabled = IS_FILTER_ENABLED(IFF_MULTICAST);
+
+	for (i = HW_ATL_B0_MAC_MIN; i < HW_ATL_B0_MAC_MAX; ++i)
+		hw_atl_rpfl2_uc_flr_en_set(self,
+					   (self->aq_nic_cfg->is_mc_list_enabled &&
+				    (i <= self->aq_nic_cfg->mc_list_count)) ?
+				    1U : 0U, i);
+
+	return aq_hw_err_from_flags(self);
+}
+
+#undef IS_FILTER_ENABLED
+
+static int hw_atl_b0_hw_multicast_list_set(struct aq_hw_s *self,
+					   u8 ar_mac
+					   [AQ_CFG_MULTICAST_ADDRESS_MAX]
+					   [ETH_ALEN],
+					   u32 count)
+{
+	int err = 0;
+
+	if (count > (HW_ATL_B0_MAC_MAX - HW_ATL_B0_MAC_MIN)) {
+		err = -EBADRQC;
+		goto err_exit;
+	}
+	for (self->aq_nic_cfg->mc_list_count = 0U;
+			self->aq_nic_cfg->mc_list_count < count;
+			++self->aq_nic_cfg->mc_list_count) {
+		u32 i = self->aq_nic_cfg->mc_list_count;
+		u32 h = (ar_mac[i][0] << 8) | (ar_mac[i][1]);
+		u32 l = (ar_mac[i][2] << 24) | (ar_mac[i][3] << 16) |
+					(ar_mac[i][4] << 8) | ar_mac[i][5];
+
+		hw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_B0_MAC_MIN + i);
+
+		hw_atl_rpfl2unicast_dest_addresslsw_set(self,
+							l, HW_ATL_B0_MAC_MIN + i);
+
+		hw_atl_rpfl2unicast_dest_addressmsw_set(self,
+							h, HW_ATL_B0_MAC_MIN + i);
+
+		hw_atl_rpfl2_uc_flr_en_set(self,
+					   (self->aq_nic_cfg->is_mc_list_enabled),
+				    HW_ATL_B0_MAC_MIN + i);
+	}
+
+	err = aq_hw_err_from_flags(self);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_b0_hw_interrupt_moderation_set(struct aq_hw_s *self)
+{
+	unsigned int i = 0U;
+	u32 itr_tx = 2U;
+	u32 itr_rx = 2U;
+
+	switch (self->aq_nic_cfg->itr) {
+	case  AQ_CFG_INTERRUPT_MODERATION_ON:
+	case  AQ_CFG_INTERRUPT_MODERATION_AUTO:
+		hw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 0U);
+		hw_atl_tdm_tdm_intr_moder_en_set(self, 1U);
+		hw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 0U);
+		hw_atl_rdm_rdm_intr_moder_en_set(self, 1U);
+
+		if (self->aq_nic_cfg->itr == AQ_CFG_INTERRUPT_MODERATION_ON) {
+			/* HW timers are in 2us units */
+			int tx_max_timer = self->aq_nic_cfg->tx_itr / 2;
+			int tx_min_timer = tx_max_timer / 2;
+
+			int rx_max_timer = self->aq_nic_cfg->rx_itr / 2;
+			int rx_min_timer = rx_max_timer / 2;
+
+			tx_max_timer = min(HW_ATL_INTR_MODER_MAX, tx_max_timer);
+			tx_min_timer = min(HW_ATL_INTR_MODER_MIN, tx_min_timer);
+			rx_max_timer = min(HW_ATL_INTR_MODER_MAX, rx_max_timer);
+			rx_min_timer = min(HW_ATL_INTR_MODER_MIN, rx_min_timer);
+
+			itr_tx |= tx_min_timer << 0x8U;
+			itr_tx |= tx_max_timer << 0x10U;
+			itr_rx |= rx_min_timer << 0x8U;
+			itr_rx |= rx_max_timer << 0x10U;
+		} else {
+			static unsigned int hw_atl_b0_timers_table_tx_[][2] = {
+				{0xfU, 0xffU}, /* 10Gbit */
+				{0xfU, 0x1ffU}, /* 5Gbit */
+				{0xfU, 0x1ffU}, /* 5Gbit 5GS */
+				{0xfU, 0x1ffU}, /* 2.5Gbit */
+				{0xfU, 0x1ffU}, /* 1Gbit */
+				{0xfU, 0x1ffU}, /* 100Mbit */
+			};
+
+			static unsigned int hw_atl_b0_timers_table_rx_[][2] = {
+				{0x6U, 0x38U},/* 10Gbit */
+				{0xCU, 0x70U},/* 5Gbit */
+				{0xCU, 0x70U},/* 5Gbit 5GS */
+				{0x18U, 0xE0U},/* 2.5Gbit */
+				{0x30U, 0x80U},/* 1Gbit */
+				{0x4U, 0x50U},/* 100Mbit */
+			};
+
+			unsigned int speed_index =
+					hw_atl_utils_mbps_2_speed_index(
+						self->aq_link_status.mbps);
+
+			/* Update user visible ITR settings */
+			self->aq_nic_cfg->tx_itr = hw_atl_b0_timers_table_tx_
+							[speed_index][1] * 2;
+			self->aq_nic_cfg->rx_itr = hw_atl_b0_timers_table_rx_
+							[speed_index][1] * 2;
+
+			itr_tx |= hw_atl_b0_timers_table_tx_
+						[speed_index][0] << 0x8U;
+			itr_tx |= hw_atl_b0_timers_table_tx_
+						[speed_index][1] << 0x10U;
+
+			itr_rx |= hw_atl_b0_timers_table_rx_
+						[speed_index][0] << 0x8U;
+			itr_rx |= hw_atl_b0_timers_table_rx_
+						[speed_index][1] << 0x10U;
+		}
+		break;
+	case AQ_CFG_INTERRUPT_MODERATION_OFF:
+		hw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 1U);
+		hw_atl_tdm_tdm_intr_moder_en_set(self, 0U);
+		hw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 1U);
+		hw_atl_rdm_rdm_intr_moder_en_set(self, 0U);
+		itr_tx = 0U;
+		itr_rx = 0U;
+		break;
+	}
+
+	for (i = HW_ATL_B0_RINGS_MAX; i--;) {
+		hw_atl_reg_tx_intr_moder_ctrl_set(self, itr_tx, i);
+		hw_atl_reg_rx_intr_moder_ctrl_set(self, itr_rx, i);
+	}
+
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_stop(struct aq_hw_s *self)
+{
+	hw_atl_b0_hw_irq_disable(self, HW_ATL_B0_INT_MASK);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_tx_stop(struct aq_hw_s *self,
+				     struct aq_ring_s *ring)
+{
+	hw_atl_tdm_tx_desc_en_set(self, 0U, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+static int hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self,
+				     struct aq_ring_s *ring)
+{
+	hw_atl_rdm_rx_desc_en_set(self, 0U, ring->idx);
+	return aq_hw_err_from_flags(self);
+}
+
+const struct aq_hw_ops hw_atl_ops_b0 = {
+	.hw_set_mac_address   = hw_atl_b0_hw_mac_addr_set,
+	.hw_init              = hw_atl_b0_hw_init,
+	.hw_reset             = hw_atl_b0_hw_reset,
+	.hw_start             = hw_atl_b0_hw_start,
+	.hw_ring_tx_start     = hw_atl_b0_hw_ring_tx_start,
+	.hw_ring_tx_stop      = hw_atl_b0_hw_ring_tx_stop,
+	.hw_ring_rx_start     = hw_atl_b0_hw_ring_rx_start,
+	.hw_ring_rx_stop      = hw_atl_b0_hw_ring_rx_stop,
+	.hw_stop              = hw_atl_b0_hw_stop,
+
+	.hw_ring_tx_xmit         = hw_atl_b0_hw_ring_tx_xmit,
+	.hw_ring_tx_head_update  = hw_atl_b0_hw_ring_tx_head_update,
+
+	.hw_ring_rx_receive      = hw_atl_b0_hw_ring_rx_receive,
+	.hw_ring_rx_fill         = hw_atl_b0_hw_ring_rx_fill,
+
+	.hw_irq_enable           = hw_atl_b0_hw_irq_enable,
+	.hw_irq_disable          = hw_atl_b0_hw_irq_disable,
+	.hw_irq_read             = hw_atl_b0_hw_irq_read,
+
+	.hw_ring_rx_init             = hw_atl_b0_hw_ring_rx_init,
+	.hw_ring_tx_init             = hw_atl_b0_hw_ring_tx_init,
+	.hw_packet_filter_set        = hw_atl_b0_hw_packet_filter_set,
+	.hw_multicast_list_set       = hw_atl_b0_hw_multicast_list_set,
+	.hw_interrupt_moderation_set = hw_atl_b0_hw_interrupt_moderation_set,
+	.hw_rss_set                  = hw_atl_b0_hw_rss_set,
+	.hw_rss_hash_set             = hw_atl_b0_hw_rss_hash_set,
+	.hw_get_regs                 = hw_atl_utils_hw_get_regs,
+	.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,
+	.hw_get_fw_version           = hw_atl_utils_get_fw_version,
+};
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.h
new file mode 100644
index 00000000..2cc8dac
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0.h
@@ -0,0 +1,42 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_b0.h: Declaration of abstract interface for Atlantic hardware
+ * specific functions.
+ */
+
+#ifndef HW_ATL_B0_H
+#define HW_ATL_B0_H
+
+#include "../aq_common.h"
+
+extern const struct aq_hw_caps_s hw_atl_b0_caps_aqc100;
+extern const struct aq_hw_caps_s hw_atl_b0_caps_aqc107;
+extern const struct aq_hw_caps_s hw_atl_b0_caps_aqc108;
+extern const struct aq_hw_caps_s hw_atl_b0_caps_aqc109;
+
+#define hw_atl_b0_caps_aqc111 hw_atl_b0_caps_aqc108
+#define hw_atl_b0_caps_aqc112 hw_atl_b0_caps_aqc109
+
+#define hw_atl_b0_caps_aqc100s hw_atl_b0_caps_aqc100
+#define hw_atl_b0_caps_aqc107s hw_atl_b0_caps_aqc107
+#define hw_atl_b0_caps_aqc108s hw_atl_b0_caps_aqc108
+#define hw_atl_b0_caps_aqc109s hw_atl_b0_caps_aqc109
+
+#define hw_atl_b0_caps_aqc111s hw_atl_b0_caps_aqc108
+#define hw_atl_b0_caps_aqc112s hw_atl_b0_caps_aqc109
+
+#define hw_atl_b0_caps_aqc111e hw_atl_b0_caps_aqc108
+#define hw_atl_b0_caps_aqc112e hw_atl_b0_caps_aqc109
+
+extern const struct aq_hw_ops hw_atl_ops_b0;
+
+#define hw_atl_ops_b1 hw_atl_ops_b0
+
+#endif /* HW_ATL_B0_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0_internal.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0_internal.h
new file mode 100644
index 00000000..495675e
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_b0_internal.h
@@ -0,0 +1,147 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_b0_internal.h: Definition of Atlantic B0 chip specific
+ * constants.
+ */
+
+#ifndef HW_ATL_B0_INTERNAL_H
+#define HW_ATL_B0_INTERNAL_H
+
+#include "../aq_common.h"
+
+#define HW_ATL_B0_MTU_JUMBO  16352U
+#define HW_ATL_B0_MTU        1514U
+
+#define HW_ATL_B0_TX_RINGS 4U
+#define HW_ATL_B0_RX_RINGS 4U
+
+#define HW_ATL_B0_RINGS_MAX 32U
+#define HW_ATL_B0_TXD_SIZE       (16U)
+#define HW_ATL_B0_RXD_SIZE       (16U)
+
+#define HW_ATL_B0_MAC      0U
+#define HW_ATL_B0_MAC_MIN  1U
+#define HW_ATL_B0_MAC_MAX  33U
+
+/* UCAST/MCAST filters */
+#define HW_ATL_B0_UCAST_FILTERS_MAX 38
+#define HW_ATL_B0_MCAST_FILTERS_MAX 8
+
+/* interrupts */
+#define HW_ATL_B0_ERR_INT 8U
+#define HW_ATL_B0_INT_MASK  (0xFFFFFFFFU)
+
+#define HW_ATL_B0_TXD_CTL2_LEN        (0xFFFFC000)
+#define HW_ATL_B0_TXD_CTL2_CTX_EN     (0x00002000)
+#define HW_ATL_B0_TXD_CTL2_CTX_IDX    (0x00001000)
+
+#define HW_ATL_B0_TXD_CTL_DESC_TYPE_TXD   (0x00000001)
+#define HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC   (0x00000002)
+#define HW_ATL_B0_TXD_CTL_BLEN        (0x000FFFF0)
+#define HW_ATL_B0_TXD_CTL_DD          (0x00100000)
+#define HW_ATL_B0_TXD_CTL_EOP         (0x00200000)
+
+#define HW_ATL_B0_TXD_CTL_CMD_X       (0x3FC00000)
+
+#define HW_ATL_B0_TXD_CTL_CMD_VLAN    BIT(22)
+#define HW_ATL_B0_TXD_CTL_CMD_FCS     BIT(23)
+#define HW_ATL_B0_TXD_CTL_CMD_IPCSO   BIT(24)
+#define HW_ATL_B0_TXD_CTL_CMD_TUCSO   BIT(25)
+#define HW_ATL_B0_TXD_CTL_CMD_LSO     BIT(26)
+#define HW_ATL_B0_TXD_CTL_CMD_WB      BIT(27)
+#define HW_ATL_B0_TXD_CTL_CMD_VXLAN   BIT(28)
+
+#define HW_ATL_B0_TXD_CTL_CMD_IPV6    BIT(21)
+#define HW_ATL_B0_TXD_CTL_CMD_TCP     BIT(22)
+
+#define HW_ATL_B0_MPI_CONTROL_ADR       0x0368U
+#define HW_ATL_B0_MPI_STATE_ADR         0x036CU
+
+#define HW_ATL_B0_MPI_SPEED_MSK         0xFFFFU
+#define HW_ATL_B0_MPI_SPEED_SHIFT       16U
+
+#define HW_ATL_B0_TXBUF_MAX  160U
+#define HW_ATL_B0_RXBUF_MAX  320U
+
+#define HW_ATL_B0_RSS_REDIRECTION_MAX 64U
+#define HW_ATL_B0_RSS_REDIRECTION_BITS 3U
+#define HW_ATL_B0_RSS_HASHKEY_BITS 320U
+
+#define HW_ATL_B0_TCRSS_4_8  1
+#define HW_ATL_B0_TC_MAX 1U
+#define HW_ATL_B0_RSS_MAX 8U
+
+#define HW_ATL_B0_LRO_RXD_MAX 2U
+#define HW_ATL_B0_RS_SLIP_ENABLED  0U
+
+/* (256k -1(max pay_len) - 54(header)) */
+#define HAL_ATL_B0_LSO_MAX_SEGMENT_SIZE 262089U
+
+/* (256k -1(max pay_len) - 74(header)) */
+#define HAL_ATL_B0_LSO_IPV6_MAX_SEGMENT_SIZE 262069U
+
+#define HW_ATL_B0_CHIP_REVISION_B0      0xA0U
+#define HW_ATL_B0_CHIP_REVISION_UNKNOWN 0xFFU
+
+#define HW_ATL_B0_FW_SEMA_RAM           0x2U
+
+#define HW_ATL_B0_TXC_LEN_TUNLEN    (0x0000FF00)
+#define HW_ATL_B0_TXC_LEN_OUTLEN    (0xFFFF0000)
+
+#define HW_ATL_B0_TXC_CTL_DESC_TYPE (0x00000007)
+#define HW_ATL_B0_TXC_CTL_CTX_ID    (0x00000008)
+#define HW_ATL_B0_TXC_CTL_VLAN      (0x000FFFF0)
+#define HW_ATL_B0_TXC_CTL_CMD       (0x00F00000)
+#define HW_ATL_B0_TXC_CTL_L2LEN     (0x7F000000)
+
+#define HW_ATL_B0_TXC_CTL_L3LEN     (0x80000000)	/* L3LEN lsb */
+#define HW_ATL_B0_TXC_LEN2_L3LEN    (0x000000FF)	/* L3LE upper bits */
+#define HW_ATL_B0_TXC_LEN2_L4LEN    (0x0000FF00)
+#define HW_ATL_B0_TXC_LEN2_MSSLEN   (0xFFFF0000)
+
+#define HW_ATL_B0_RXD_DD    (0x1)
+#define HW_ATL_B0_RXD_NCEA0 (0x1)
+
+#define HW_ATL_B0_RXD_WB_STAT_RSSTYPE (0x0000000F)
+#define HW_ATL_B0_RXD_WB_STAT_PKTTYPE (0x00000FF0)
+#define HW_ATL_B0_RXD_WB_STAT_RXCTRL  (0x00180000)
+#define HW_ATL_B0_RXD_WB_STAT_SPLHDR  (0x00200000)
+#define HW_ATL_B0_RXD_WB_STAT_HDRLEN  (0xFFC00000)
+
+#define HW_ATL_B0_RXD_WB_STAT2_DD      (0x0001)
+#define HW_ATL_B0_RXD_WB_STAT2_EOP     (0x0002)
+#define HW_ATL_B0_RXD_WB_STAT2_RXSTAT  (0x003C)
+#define HW_ATL_B0_RXD_WB_STAT2_MACERR  (0x0004)
+#define HW_ATL_B0_RXD_WB_STAT2_IP4ERR  (0x0008)
+#define HW_ATL_B0_RXD_WB_STAT2_TCPUPDERR  (0x0010)
+#define HW_ATL_B0_RXD_WB_STAT2_RXESTAT (0x0FC0)
+#define HW_ATL_B0_RXD_WB_STAT2_RSCCNT  (0xF000)
+
+#define L2_FILTER_ACTION_DISCARD (0x0)
+#define L2_FILTER_ACTION_HOST    (0x1)
+
+#define HW_ATL_B0_UCP_0X370_REG  (0x370)
+
+#define HW_ATL_B0_FLUSH() AQ_HW_READ_REG(self, 0x10)
+
+#define HW_ATL_INTR_MODER_MAX  0x1FF
+#define HW_ATL_INTR_MODER_MIN  0xFF
+
+#define HW_ATL_B0_MIN_RXD \
+	(ALIGN(AQ_CFG_SKB_FRAGS_MAX + 1U, AQ_HW_RXD_MULTIPLE))
+#define HW_ATL_B0_MIN_TXD \
+	(ALIGN(AQ_CFG_SKB_FRAGS_MAX + 1U, AQ_HW_TXD_MULTIPLE))
+
+#define HW_ATL_B0_MAX_RXD 8184U
+#define HW_ATL_B0_MAX_TXD 8184U
+
+/* HW layer capabilities */
+
+#endif /* HW_ATL_B0_INTERNAL_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.c b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.c
new file mode 100644
index 00000000..292c489
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.c
@@ -0,0 +1,1472 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_llh.c: Definitions of bitfield and register access functions for
+ * Atlantic registers.
+ */
+
+#include "hw_atl_llh.h"
+#include "hw_atl_llh_internal.h"
+#include "../aq_hw_utils.h"
+
+/* global */
+void hw_atl_reg_glb_cpu_sem_set(struct aq_hw_s *aq_hw, u32 glb_cpu_sem,
+				u32 semaphore)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_GLB_CPU_SEM_ADR(semaphore), glb_cpu_sem);
+}
+
+u32 hw_atl_reg_glb_cpu_sem_get(struct aq_hw_s *aq_hw, u32 semaphore)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_GLB_CPU_SEM_ADR(semaphore));
+}
+
+void hw_atl_glb_glb_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 glb_reg_res_dis)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_GLB_REG_RES_DIS_ADR,
+			    HW_ATL_GLB_REG_RES_DIS_MSK,
+			    HW_ATL_GLB_REG_RES_DIS_SHIFT,
+			    glb_reg_res_dis);
+}
+
+void hw_atl_glb_soft_res_set(struct aq_hw_s *aq_hw, u32 soft_res)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_GLB_SOFT_RES_ADR,
+			    HW_ATL_GLB_SOFT_RES_MSK,
+			    HW_ATL_GLB_SOFT_RES_SHIFT, soft_res);
+}
+
+u32 hw_atl_glb_soft_res_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_GLB_SOFT_RES_ADR,
+				  HW_ATL_GLB_SOFT_RES_MSK,
+				  HW_ATL_GLB_SOFT_RES_SHIFT);
+}
+
+u32 hw_atl_reg_rx_dma_stat_counter7get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_RX_DMA_STAT_COUNTER7_ADR);
+}
+
+u32 hw_atl_reg_glb_mif_id_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_GLB_MIF_ID_ADR);
+}
+
+/* stats */
+u32 hw_atl_rpb_rx_dma_drop_pkt_cnt_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_RPB_RX_DMA_DROP_PKT_CNT_ADR);
+}
+
+u32 hw_atl_stats_rx_dma_good_octet_counterlsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_RX_DMA_GOOD_OCTET_COUNTERLSW);
+}
+
+u32 hw_atl_stats_rx_dma_good_pkt_counterlsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_RX_DMA_GOOD_PKT_COUNTERLSW);
+}
+
+u32 hw_atl_stats_tx_dma_good_octet_counterlsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_TX_DMA_GOOD_OCTET_COUNTERLSW);
+}
+
+u32 hw_atl_stats_tx_dma_good_pkt_counterlsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_TX_DMA_GOOD_PKT_COUNTERLSW);
+}
+
+u32 hw_atl_stats_rx_dma_good_octet_countermsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_RX_DMA_GOOD_OCTET_COUNTERMSW);
+}
+
+u32 hw_atl_stats_rx_dma_good_pkt_countermsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_RX_DMA_GOOD_PKT_COUNTERMSW);
+}
+
+u32 hw_atl_stats_tx_dma_good_octet_countermsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_TX_DMA_GOOD_OCTET_COUNTERMSW);
+}
+
+u32 hw_atl_stats_tx_dma_good_pkt_countermsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_STATS_TX_DMA_GOOD_PKT_COUNTERMSW);
+}
+
+/* interrupt */
+void hw_atl_itr_irq_auto_masklsw_set(struct aq_hw_s *aq_hw,
+				     u32 irq_auto_masklsw)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_ITR_IAMRLSW_ADR, irq_auto_masklsw);
+}
+
+void hw_atl_itr_irq_map_en_rx_set(struct aq_hw_s *aq_hw, u32 irq_map_en_rx,
+				  u32 rx)
+{
+/* register address for bitfield imr_rx{r}_en */
+	static u32 itr_imr_rxren_adr[32] = {
+			0x00002100U, 0x00002100U, 0x00002104U, 0x00002104U,
+			0x00002108U, 0x00002108U, 0x0000210CU, 0x0000210CU,
+			0x00002110U, 0x00002110U, 0x00002114U, 0x00002114U,
+			0x00002118U, 0x00002118U, 0x0000211CU, 0x0000211CU,
+			0x00002120U, 0x00002120U, 0x00002124U, 0x00002124U,
+			0x00002128U, 0x00002128U, 0x0000212CU, 0x0000212CU,
+			0x00002130U, 0x00002130U, 0x00002134U, 0x00002134U,
+			0x00002138U, 0x00002138U, 0x0000213CU, 0x0000213CU
+		};
+
+/* bitmask for bitfield imr_rx{r}_en */
+	static u32 itr_imr_rxren_msk[32] = {
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U,
+			0x00008000U, 0x00000080U, 0x00008000U, 0x00000080U
+		};
+
+/* lower bit position of bitfield imr_rx{r}_en */
+	static u32 itr_imr_rxren_shift[32] = {
+			15U, 7U, 15U, 7U, 15U, 7U, 15U, 7U,
+			15U, 7U, 15U, 7U, 15U, 7U, 15U, 7U,
+			15U, 7U, 15U, 7U, 15U, 7U, 15U, 7U,
+			15U, 7U, 15U, 7U, 15U, 7U, 15U, 7U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, itr_imr_rxren_adr[rx],
+			    itr_imr_rxren_msk[rx],
+			    itr_imr_rxren_shift[rx],
+			    irq_map_en_rx);
+}
+
+void hw_atl_itr_irq_map_en_tx_set(struct aq_hw_s *aq_hw, u32 irq_map_en_tx,
+				  u32 tx)
+{
+/* register address for bitfield imr_tx{t}_en */
+	static u32 itr_imr_txten_adr[32] = {
+			0x00002100U, 0x00002100U, 0x00002104U, 0x00002104U,
+			0x00002108U, 0x00002108U, 0x0000210CU, 0x0000210CU,
+			0x00002110U, 0x00002110U, 0x00002114U, 0x00002114U,
+			0x00002118U, 0x00002118U, 0x0000211CU, 0x0000211CU,
+			0x00002120U, 0x00002120U, 0x00002124U, 0x00002124U,
+			0x00002128U, 0x00002128U, 0x0000212CU, 0x0000212CU,
+			0x00002130U, 0x00002130U, 0x00002134U, 0x00002134U,
+			0x00002138U, 0x00002138U, 0x0000213CU, 0x0000213CU
+		};
+
+/* bitmask for bitfield imr_tx{t}_en */
+	static u32 itr_imr_txten_msk[32] = {
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U,
+			0x80000000U, 0x00800000U, 0x80000000U, 0x00800000U
+		};
+
+/* lower bit position of bitfield imr_tx{t}_en */
+	static u32 itr_imr_txten_shift[32] = {
+			31U, 23U, 31U, 23U, 31U, 23U, 31U, 23U,
+			31U, 23U, 31U, 23U, 31U, 23U, 31U, 23U,
+			31U, 23U, 31U, 23U, 31U, 23U, 31U, 23U,
+			31U, 23U, 31U, 23U, 31U, 23U, 31U, 23U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, itr_imr_txten_adr[tx],
+			    itr_imr_txten_msk[tx],
+			    itr_imr_txten_shift[tx],
+			    irq_map_en_tx);
+}
+
+void hw_atl_itr_irq_map_rx_set(struct aq_hw_s *aq_hw, u32 irq_map_rx, u32 rx)
+{
+/* register address for bitfield imr_rx{r}[4:0] */
+	static u32 itr_imr_rxr_adr[32] = {
+			0x00002100U, 0x00002100U, 0x00002104U, 0x00002104U,
+			0x00002108U, 0x00002108U, 0x0000210CU, 0x0000210CU,
+			0x00002110U, 0x00002110U, 0x00002114U, 0x00002114U,
+			0x00002118U, 0x00002118U, 0x0000211CU, 0x0000211CU,
+			0x00002120U, 0x00002120U, 0x00002124U, 0x00002124U,
+			0x00002128U, 0x00002128U, 0x0000212CU, 0x0000212CU,
+			0x00002130U, 0x00002130U, 0x00002134U, 0x00002134U,
+			0x00002138U, 0x00002138U, 0x0000213CU, 0x0000213CU
+		};
+
+/* bitmask for bitfield imr_rx{r}[4:0] */
+	static u32 itr_imr_rxr_msk[32] = {
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU,
+			0x00001f00U, 0x0000001FU, 0x00001F00U, 0x0000001FU
+		};
+
+/* lower bit position of bitfield imr_rx{r}[4:0] */
+	static u32 itr_imr_rxr_shift[32] = {
+			8U, 0U, 8U, 0U, 8U, 0U, 8U, 0U,
+			8U, 0U, 8U, 0U, 8U, 0U, 8U, 0U,
+			8U, 0U, 8U, 0U, 8U, 0U, 8U, 0U,
+			8U, 0U, 8U, 0U, 8U, 0U, 8U, 0U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, itr_imr_rxr_adr[rx],
+			    itr_imr_rxr_msk[rx],
+			    itr_imr_rxr_shift[rx],
+			    irq_map_rx);
+}
+
+void hw_atl_itr_irq_map_tx_set(struct aq_hw_s *aq_hw, u32 irq_map_tx, u32 tx)
+{
+/* register address for bitfield imr_tx{t}[4:0] */
+	static u32 itr_imr_txt_adr[32] = {
+			0x00002100U, 0x00002100U, 0x00002104U, 0x00002104U,
+			0x00002108U, 0x00002108U, 0x0000210CU, 0x0000210CU,
+			0x00002110U, 0x00002110U, 0x00002114U, 0x00002114U,
+			0x00002118U, 0x00002118U, 0x0000211CU, 0x0000211CU,
+			0x00002120U, 0x00002120U, 0x00002124U, 0x00002124U,
+			0x00002128U, 0x00002128U, 0x0000212CU, 0x0000212CU,
+			0x00002130U, 0x00002130U, 0x00002134U, 0x00002134U,
+			0x00002138U, 0x00002138U, 0x0000213CU, 0x0000213CU
+		};
+
+/* bitmask for bitfield imr_tx{t}[4:0] */
+	static u32 itr_imr_txt_msk[32] = {
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U,
+			0x1f000000U, 0x001F0000U, 0x1F000000U, 0x001F0000U
+		};
+
+/* lower bit position of bitfield imr_tx{t}[4:0] */
+	static u32 itr_imr_txt_shift[32] = {
+			24U, 16U, 24U, 16U, 24U, 16U, 24U, 16U,
+			24U, 16U, 24U, 16U, 24U, 16U, 24U, 16U,
+			24U, 16U, 24U, 16U, 24U, 16U, 24U, 16U,
+			24U, 16U, 24U, 16U, 24U, 16U, 24U, 16U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, itr_imr_txt_adr[tx],
+			    itr_imr_txt_msk[tx],
+			    itr_imr_txt_shift[tx],
+			    irq_map_tx);
+}
+
+void hw_atl_itr_irq_msk_clearlsw_set(struct aq_hw_s *aq_hw,
+				     u32 irq_msk_clearlsw)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_ITR_IMCRLSW_ADR, irq_msk_clearlsw);
+}
+
+void hw_atl_itr_irq_msk_setlsw_set(struct aq_hw_s *aq_hw, u32 irq_msk_setlsw)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_ITR_IMSRLSW_ADR, irq_msk_setlsw);
+}
+
+void hw_atl_itr_irq_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 irq_reg_res_dis)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_ITR_REG_RES_DSBL_ADR,
+			    HW_ATL_ITR_REG_RES_DSBL_MSK,
+			    HW_ATL_ITR_REG_RES_DSBL_SHIFT, irq_reg_res_dis);
+}
+
+void hw_atl_itr_irq_status_clearlsw_set(struct aq_hw_s *aq_hw,
+					u32 irq_status_clearlsw)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_ITR_ISCRLSW_ADR, irq_status_clearlsw);
+}
+
+u32 hw_atl_itr_irq_statuslsw_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_ITR_ISRLSW_ADR);
+}
+
+u32 hw_atl_itr_res_irq_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_ITR_RES_ADR, HW_ATL_ITR_RES_MSK,
+				  HW_ATL_ITR_RES_SHIFT);
+}
+
+void hw_atl_itr_res_irq_set(struct aq_hw_s *aq_hw, u32 res_irq)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_ITR_RES_ADR, HW_ATL_ITR_RES_MSK,
+			    HW_ATL_ITR_RES_SHIFT, res_irq);
+}
+
+/* rdm */
+void hw_atl_rdm_cpu_id_set(struct aq_hw_s *aq_hw, u32 cpuid, u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCADCPUID_ADR(dca),
+			    HW_ATL_RDM_DCADCPUID_MSK,
+			    HW_ATL_RDM_DCADCPUID_SHIFT, cpuid);
+}
+
+void hw_atl_rdm_rx_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_dca_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCA_EN_ADR, HW_ATL_RDM_DCA_EN_MSK,
+			    HW_ATL_RDM_DCA_EN_SHIFT, rx_dca_en);
+}
+
+void hw_atl_rdm_rx_dca_mode_set(struct aq_hw_s *aq_hw, u32 rx_dca_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCA_MODE_ADR,
+			    HW_ATL_RDM_DCA_MODE_MSK,
+			    HW_ATL_RDM_DCA_MODE_SHIFT, rx_dca_mode);
+}
+
+void hw_atl_rdm_rx_desc_data_buff_size_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_data_buff_size,
+					   u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDDATA_SIZE_ADR(descriptor),
+			    HW_ATL_RDM_DESCDDATA_SIZE_MSK,
+			    HW_ATL_RDM_DESCDDATA_SIZE_SHIFT,
+			    rx_desc_data_buff_size);
+}
+
+void hw_atl_rdm_rx_desc_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_desc_dca_en,
+				   u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCADDESC_EN_ADR(dca),
+			    HW_ATL_RDM_DCADDESC_EN_MSK,
+			    HW_ATL_RDM_DCADDESC_EN_SHIFT,
+			    rx_desc_dca_en);
+}
+
+void hw_atl_rdm_rx_desc_en_set(struct aq_hw_s *aq_hw, u32 rx_desc_en,
+			       u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDEN_ADR(descriptor),
+			    HW_ATL_RDM_DESCDEN_MSK,
+			    HW_ATL_RDM_DESCDEN_SHIFT,
+			    rx_desc_en);
+}
+
+void hw_atl_rdm_rx_desc_head_buff_size_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_head_buff_size,
+					   u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDHDR_SIZE_ADR(descriptor),
+			    HW_ATL_RDM_DESCDHDR_SIZE_MSK,
+			    HW_ATL_RDM_DESCDHDR_SIZE_SHIFT,
+			    rx_desc_head_buff_size);
+}
+
+void hw_atl_rdm_rx_desc_head_splitting_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_head_splitting,
+					   u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDHDR_SPLIT_ADR(descriptor),
+			    HW_ATL_RDM_DESCDHDR_SPLIT_MSK,
+			    HW_ATL_RDM_DESCDHDR_SPLIT_SHIFT,
+			    rx_desc_head_splitting);
+}
+
+u32 hw_atl_rdm_rx_desc_head_ptr_get(struct aq_hw_s *aq_hw, u32 descriptor)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_RDM_DESCDHD_ADR(descriptor),
+				  HW_ATL_RDM_DESCDHD_MSK,
+				  HW_ATL_RDM_DESCDHD_SHIFT);
+}
+
+void hw_atl_rdm_rx_desc_len_set(struct aq_hw_s *aq_hw, u32 rx_desc_len,
+				u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDLEN_ADR(descriptor),
+			    HW_ATL_RDM_DESCDLEN_MSK, HW_ATL_RDM_DESCDLEN_SHIFT,
+			    rx_desc_len);
+}
+
+void hw_atl_rdm_rx_desc_res_set(struct aq_hw_s *aq_hw, u32 rx_desc_res,
+				u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DESCDRESET_ADR(descriptor),
+			    HW_ATL_RDM_DESCDRESET_MSK,
+			    HW_ATL_RDM_DESCDRESET_SHIFT,
+			    rx_desc_res);
+}
+
+void hw_atl_rdm_rx_desc_wr_wb_irq_en_set(struct aq_hw_s *aq_hw,
+					 u32 rx_desc_wr_wb_irq_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_INT_DESC_WRB_EN_ADR,
+			    HW_ATL_RDM_INT_DESC_WRB_EN_MSK,
+			    HW_ATL_RDM_INT_DESC_WRB_EN_SHIFT,
+			    rx_desc_wr_wb_irq_en);
+}
+
+void hw_atl_rdm_rx_head_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_head_dca_en,
+				   u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCADHDR_EN_ADR(dca),
+			    HW_ATL_RDM_DCADHDR_EN_MSK,
+			    HW_ATL_RDM_DCADHDR_EN_SHIFT,
+			    rx_head_dca_en);
+}
+
+void hw_atl_rdm_rx_pld_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_pld_dca_en,
+				  u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_DCADPAY_EN_ADR(dca),
+			    HW_ATL_RDM_DCADPAY_EN_MSK,
+			    HW_ATL_RDM_DCADPAY_EN_SHIFT,
+			    rx_pld_dca_en);
+}
+
+void hw_atl_rdm_rdm_intr_moder_en_set(struct aq_hw_s *aq_hw,
+				      u32 rdm_intr_moder_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RDM_INT_RIM_EN_ADR,
+			    HW_ATL_RDM_INT_RIM_EN_MSK,
+			    HW_ATL_RDM_INT_RIM_EN_SHIFT,
+			    rdm_intr_moder_en);
+}
+
+/* reg */
+void hw_atl_reg_gen_irq_map_set(struct aq_hw_s *aq_hw, u32 gen_intr_map,
+				u32 regidx)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_GEN_INTR_MAP_ADR(regidx), gen_intr_map);
+}
+
+u32 hw_atl_reg_gen_irq_status_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_GEN_INTR_STAT_ADR);
+}
+
+void hw_atl_reg_irq_glb_ctl_set(struct aq_hw_s *aq_hw, u32 intr_glb_ctl)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_INTR_GLB_CTL_ADR, intr_glb_ctl);
+}
+
+void hw_atl_reg_irq_thr_set(struct aq_hw_s *aq_hw, u32 intr_thr, u32 throttle)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_INTR_THR_ADR(throttle), intr_thr);
+}
+
+void hw_atl_reg_rx_dma_desc_base_addresslswset(struct aq_hw_s *aq_hw,
+					       u32 rx_dma_desc_base_addrlsw,
+					       u32 descriptor)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_DMA_DESC_BASE_ADDRLSW_ADR(descriptor),
+			rx_dma_desc_base_addrlsw);
+}
+
+void hw_atl_reg_rx_dma_desc_base_addressmswset(struct aq_hw_s *aq_hw,
+					       u32 rx_dma_desc_base_addrmsw,
+					       u32 descriptor)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_DMA_DESC_BASE_ADDRMSW_ADR(descriptor),
+			rx_dma_desc_base_addrmsw);
+}
+
+u32 hw_atl_reg_rx_dma_desc_status_get(struct aq_hw_s *aq_hw, u32 descriptor)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_RX_DMA_DESC_STAT_ADR(descriptor));
+}
+
+void hw_atl_reg_rx_dma_desc_tail_ptr_set(struct aq_hw_s *aq_hw,
+					 u32 rx_dma_desc_tail_ptr,
+					 u32 descriptor)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_DMA_DESC_TAIL_PTR_ADR(descriptor),
+			rx_dma_desc_tail_ptr);
+}
+
+void hw_atl_reg_rx_flr_mcst_flr_msk_set(struct aq_hw_s *aq_hw,
+					u32 rx_flr_mcst_flr_msk)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_FLR_MCST_FLR_MSK_ADR,
+			rx_flr_mcst_flr_msk);
+}
+
+void hw_atl_reg_rx_flr_mcst_flr_set(struct aq_hw_s *aq_hw, u32 rx_flr_mcst_flr,
+				    u32 filter)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_FLR_MCST_FLR_ADR(filter),
+			rx_flr_mcst_flr);
+}
+
+void hw_atl_reg_rx_flr_rss_control1set(struct aq_hw_s *aq_hw,
+				       u32 rx_flr_rss_control1)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_FLR_RSS_CONTROL1_ADR,
+			rx_flr_rss_control1);
+}
+
+void hw_atl_reg_rx_flr_control2_set(struct aq_hw_s *aq_hw,
+				    u32 rx_filter_control2)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_FLR_CONTROL2_ADR, rx_filter_control2);
+}
+
+void hw_atl_reg_rx_intr_moder_ctrl_set(struct aq_hw_s *aq_hw,
+				       u32 rx_intr_moderation_ctl,
+				       u32 queue)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RX_INTR_MODERATION_CTL_ADR(queue),
+			rx_intr_moderation_ctl);
+}
+
+void hw_atl_reg_tx_dma_debug_ctl_set(struct aq_hw_s *aq_hw,
+				     u32 tx_dma_debug_ctl)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_TX_DMA_DEBUG_CTL_ADR, tx_dma_debug_ctl);
+}
+
+void hw_atl_reg_tx_dma_desc_base_addresslswset(struct aq_hw_s *aq_hw,
+					       u32 tx_dma_desc_base_addrlsw,
+					       u32 descriptor)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_TX_DMA_DESC_BASE_ADDRLSW_ADR(descriptor),
+			tx_dma_desc_base_addrlsw);
+}
+
+void hw_atl_reg_tx_dma_desc_base_addressmswset(struct aq_hw_s *aq_hw,
+					       u32 tx_dma_desc_base_addrmsw,
+					       u32 descriptor)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_TX_DMA_DESC_BASE_ADDRMSW_ADR(descriptor),
+			tx_dma_desc_base_addrmsw);
+}
+
+void hw_atl_reg_tx_dma_desc_tail_ptr_set(struct aq_hw_s *aq_hw,
+					 u32 tx_dma_desc_tail_ptr,
+					 u32 descriptor)
+{
+	wmb();
+
+	aq_hw_write_reg(aq_hw, HW_ATL_TX_DMA_DESC_TAIL_PTR_ADR(descriptor),
+			tx_dma_desc_tail_ptr);
+}
+
+void hw_atl_reg_tx_intr_moder_ctrl_set(struct aq_hw_s *aq_hw,
+				       u32 tx_intr_moderation_ctl,
+				       u32 queue)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_TX_INTR_MODERATION_CTL_ADR(queue),
+			tx_intr_moderation_ctl);
+}
+
+/* RPB: rx packet buffer */
+void hw_atl_rpb_dma_sys_lbk_set(struct aq_hw_s *aq_hw, u32 dma_sys_lbk)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_DMA_SYS_LBK_ADR,
+			    HW_ATL_RPB_DMA_SYS_LBK_MSK,
+			    HW_ATL_RPB_DMA_SYS_LBK_SHIFT, dma_sys_lbk);
+}
+
+void hw_atl_rpb_rpf_rx_traf_class_mode_set(struct aq_hw_s *aq_hw,
+					   u32 rx_traf_class_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RPF_RX_TC_MODE_ADR,
+			    HW_ATL_RPB_RPF_RX_TC_MODE_MSK,
+			    HW_ATL_RPB_RPF_RX_TC_MODE_SHIFT,
+			    rx_traf_class_mode);
+}
+
+void hw_atl_rpb_rx_buff_en_set(struct aq_hw_s *aq_hw, u32 rx_buff_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RX_BUF_EN_ADR,
+			    HW_ATL_RPB_RX_BUF_EN_MSK,
+			    HW_ATL_RPB_RX_BUF_EN_SHIFT, rx_buff_en);
+}
+
+void hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 rx_buff_hi_threshold_per_tc,
+						u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RXBHI_THRESH_ADR(buffer),
+			    HW_ATL_RPB_RXBHI_THRESH_MSK,
+			    HW_ATL_RPB_RXBHI_THRESH_SHIFT,
+			    rx_buff_hi_threshold_per_tc);
+}
+
+void hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 rx_buff_lo_threshold_per_tc,
+						u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RXBLO_THRESH_ADR(buffer),
+			    HW_ATL_RPB_RXBLO_THRESH_MSK,
+			    HW_ATL_RPB_RXBLO_THRESH_SHIFT,
+			    rx_buff_lo_threshold_per_tc);
+}
+
+void hw_atl_rpb_rx_flow_ctl_mode_set(struct aq_hw_s *aq_hw, u32 rx_flow_ctl_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RX_FC_MODE_ADR,
+			    HW_ATL_RPB_RX_FC_MODE_MSK,
+			    HW_ATL_RPB_RX_FC_MODE_SHIFT, rx_flow_ctl_mode);
+}
+
+void hw_atl_rpb_rx_pkt_buff_size_per_tc_set(struct aq_hw_s *aq_hw,
+					    u32 rx_pkt_buff_size_per_tc, u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RXBBUF_SIZE_ADR(buffer),
+			    HW_ATL_RPB_RXBBUF_SIZE_MSK,
+			    HW_ATL_RPB_RXBBUF_SIZE_SHIFT,
+			    rx_pkt_buff_size_per_tc);
+}
+
+void hw_atl_rpb_rx_xoff_en_per_tc_set(struct aq_hw_s *aq_hw, u32 rx_xoff_en_per_tc,
+				      u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPB_RXBXOFF_EN_ADR(buffer),
+			    HW_ATL_RPB_RXBXOFF_EN_MSK,
+			    HW_ATL_RPB_RXBXOFF_EN_SHIFT,
+			    rx_xoff_en_per_tc);
+}
+
+/* rpf */
+
+void hw_atl_rpfl2broadcast_count_threshold_set(struct aq_hw_s *aq_hw,
+					       u32 l2broadcast_count_threshold)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2BC_THRESH_ADR,
+			    HW_ATL_RPFL2BC_THRESH_MSK,
+			    HW_ATL_RPFL2BC_THRESH_SHIFT,
+			    l2broadcast_count_threshold);
+}
+
+void hw_atl_rpfl2broadcast_en_set(struct aq_hw_s *aq_hw, u32 l2broadcast_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2BC_EN_ADR, HW_ATL_RPFL2BC_EN_MSK,
+			    HW_ATL_RPFL2BC_EN_SHIFT, l2broadcast_en);
+}
+
+void hw_atl_rpfl2broadcast_flr_act_set(struct aq_hw_s *aq_hw,
+				       u32 l2broadcast_flr_act)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2BC_ACT_ADR,
+			    HW_ATL_RPFL2BC_ACT_MSK,
+			    HW_ATL_RPFL2BC_ACT_SHIFT, l2broadcast_flr_act);
+}
+
+void hw_atl_rpfl2multicast_flr_en_set(struct aq_hw_s *aq_hw,
+				      u32 l2multicast_flr_en,
+				      u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2MC_ENF_ADR(filter),
+			    HW_ATL_RPFL2MC_ENF_MSK,
+			    HW_ATL_RPFL2MC_ENF_SHIFT, l2multicast_flr_en);
+}
+
+void hw_atl_rpfl2promiscuous_mode_en_set(struct aq_hw_s *aq_hw,
+					 u32 l2promiscuous_mode_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2PROMIS_MODE_ADR,
+			    HW_ATL_RPFL2PROMIS_MODE_MSK,
+			    HW_ATL_RPFL2PROMIS_MODE_SHIFT,
+			    l2promiscuous_mode_en);
+}
+
+void hw_atl_rpfl2unicast_flr_act_set(struct aq_hw_s *aq_hw,
+				     u32 l2unicast_flr_act,
+				     u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2UC_ACTF_ADR(filter),
+			    HW_ATL_RPFL2UC_ACTF_MSK, HW_ATL_RPFL2UC_ACTF_SHIFT,
+			    l2unicast_flr_act);
+}
+
+void hw_atl_rpfl2_uc_flr_en_set(struct aq_hw_s *aq_hw, u32 l2unicast_flr_en,
+				u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2UC_ENF_ADR(filter),
+			    HW_ATL_RPFL2UC_ENF_MSK,
+			    HW_ATL_RPFL2UC_ENF_SHIFT, l2unicast_flr_en);
+}
+
+void hw_atl_rpfl2unicast_dest_addresslsw_set(struct aq_hw_s *aq_hw,
+					     u32 l2unicast_dest_addresslsw,
+					     u32 filter)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RPFL2UC_DAFLSW_ADR(filter),
+			l2unicast_dest_addresslsw);
+}
+
+void hw_atl_rpfl2unicast_dest_addressmsw_set(struct aq_hw_s *aq_hw,
+					     u32 l2unicast_dest_addressmsw,
+					     u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2UC_DAFMSW_ADR(filter),
+			    HW_ATL_RPFL2UC_DAFMSW_MSK,
+			    HW_ATL_RPFL2UC_DAFMSW_SHIFT,
+			    l2unicast_dest_addressmsw);
+}
+
+void hw_atl_rpfl2_accept_all_mc_packets_set(struct aq_hw_s *aq_hw,
+					    u32 l2_accept_all_mc_packets)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPFL2MC_ACCEPT_ALL_ADR,
+			    HW_ATL_RPFL2MC_ACCEPT_ALL_MSK,
+			    HW_ATL_RPFL2MC_ACCEPT_ALL_SHIFT,
+			    l2_accept_all_mc_packets);
+}
+
+void hw_atl_rpf_rpb_user_priority_tc_map_set(struct aq_hw_s *aq_hw,
+					     u32 user_priority_tc_map, u32 tc)
+{
+/* register address for bitfield rx_tc_up{t}[2:0] */
+	static u32 rpf_rpb_rx_tc_upt_adr[8] = {
+			0x000054c4U, 0x000054C4U, 0x000054C4U, 0x000054C4U,
+			0x000054c4U, 0x000054C4U, 0x000054C4U, 0x000054C4U
+		};
+
+/* bitmask for bitfield rx_tc_up{t}[2:0] */
+	static u32 rpf_rpb_rx_tc_upt_msk[8] = {
+			0x00000007U, 0x00000070U, 0x00000700U, 0x00007000U,
+			0x00070000U, 0x00700000U, 0x07000000U, 0x70000000U
+		};
+
+/* lower bit position of bitfield rx_tc_up{t}[2:0] */
+	static u32 rpf_rpb_rx_tc_upt_shft[8] = {
+			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, rpf_rpb_rx_tc_upt_adr[tc],
+			    rpf_rpb_rx_tc_upt_msk[tc],
+			    rpf_rpb_rx_tc_upt_shft[tc],
+			    user_priority_tc_map);
+}
+
+void hw_atl_rpf_rss_key_addr_set(struct aq_hw_s *aq_hw, u32 rss_key_addr)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_RSS_KEY_ADDR_ADR,
+			    HW_ATL_RPF_RSS_KEY_ADDR_MSK,
+			    HW_ATL_RPF_RSS_KEY_ADDR_SHIFT,
+			    rss_key_addr);
+}
+
+void hw_atl_rpf_rss_key_wr_data_set(struct aq_hw_s *aq_hw, u32 rss_key_wr_data)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RPF_RSS_KEY_WR_DATA_ADR,
+			rss_key_wr_data);
+}
+
+u32 hw_atl_rpf_rss_key_wr_en_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_RPF_RSS_KEY_WR_ENI_ADR,
+				  HW_ATL_RPF_RSS_KEY_WR_ENI_MSK,
+				  HW_ATL_RPF_RSS_KEY_WR_ENI_SHIFT);
+}
+
+void hw_atl_rpf_rss_key_wr_en_set(struct aq_hw_s *aq_hw, u32 rss_key_wr_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_RSS_KEY_WR_ENI_ADR,
+			    HW_ATL_RPF_RSS_KEY_WR_ENI_MSK,
+			    HW_ATL_RPF_RSS_KEY_WR_ENI_SHIFT,
+			    rss_key_wr_en);
+}
+
+void hw_atl_rpf_rss_redir_tbl_addr_set(struct aq_hw_s *aq_hw,
+				       u32 rss_redir_tbl_addr)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_RSS_REDIR_ADDR_ADR,
+			    HW_ATL_RPF_RSS_REDIR_ADDR_MSK,
+			    HW_ATL_RPF_RSS_REDIR_ADDR_SHIFT,
+			    rss_redir_tbl_addr);
+}
+
+void hw_atl_rpf_rss_redir_tbl_wr_data_set(struct aq_hw_s *aq_hw,
+					  u32 rss_redir_tbl_wr_data)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_RSS_REDIR_WR_DATA_ADR,
+			    HW_ATL_RPF_RSS_REDIR_WR_DATA_MSK,
+			    HW_ATL_RPF_RSS_REDIR_WR_DATA_SHIFT,
+			    rss_redir_tbl_wr_data);
+}
+
+u32 hw_atl_rpf_rss_redir_wr_en_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_RPF_RSS_REDIR_WR_ENI_ADR,
+				  HW_ATL_RPF_RSS_REDIR_WR_ENI_MSK,
+				  HW_ATL_RPF_RSS_REDIR_WR_ENI_SHIFT);
+}
+
+void hw_atl_rpf_rss_redir_wr_en_set(struct aq_hw_s *aq_hw, u32 rss_redir_wr_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_RSS_REDIR_WR_ENI_ADR,
+			    HW_ATL_RPF_RSS_REDIR_WR_ENI_MSK,
+			    HW_ATL_RPF_RSS_REDIR_WR_ENI_SHIFT, rss_redir_wr_en);
+}
+
+void hw_atl_rpf_tpo_to_rpf_sys_lbk_set(struct aq_hw_s *aq_hw,
+				       u32 tpo_to_rpf_sys_lbk)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_TPO_RPF_SYS_LBK_ADR,
+			    HW_ATL_RPF_TPO_RPF_SYS_LBK_MSK,
+			    HW_ATL_RPF_TPO_RPF_SYS_LBK_SHIFT,
+			    tpo_to_rpf_sys_lbk);
+}
+
+void hw_atl_rpf_vlan_inner_etht_set(struct aq_hw_s *aq_hw, u32 vlan_inner_etht)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_INNER_TPID_ADR,
+			    HW_ATL_RPF_VL_INNER_TPID_MSK,
+			    HW_ATL_RPF_VL_INNER_TPID_SHIFT,
+			    vlan_inner_etht);
+}
+
+void hw_atl_rpf_vlan_outer_etht_set(struct aq_hw_s *aq_hw, u32 vlan_outer_etht)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_OUTER_TPID_ADR,
+			    HW_ATL_RPF_VL_OUTER_TPID_MSK,
+			    HW_ATL_RPF_VL_OUTER_TPID_SHIFT,
+			    vlan_outer_etht);
+}
+
+void hw_atl_rpf_vlan_prom_mode_en_set(struct aq_hw_s *aq_hw,
+				      u32 vlan_prom_mode_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_PROMIS_MODE_ADR,
+			    HW_ATL_RPF_VL_PROMIS_MODE_MSK,
+			    HW_ATL_RPF_VL_PROMIS_MODE_SHIFT,
+			    vlan_prom_mode_en);
+}
+
+void hw_atl_rpf_vlan_accept_untagged_packets_set(struct aq_hw_s *aq_hw,
+						 u32 vlan_acc_untagged_packets)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_ADR,
+			    HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_MSK,
+			    HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_SHIFT,
+			    vlan_acc_untagged_packets);
+}
+
+void hw_atl_rpf_vlan_untagged_act_set(struct aq_hw_s *aq_hw,
+				      u32 vlan_untagged_act)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_UNTAGGED_ACT_ADR,
+			    HW_ATL_RPF_VL_UNTAGGED_ACT_MSK,
+			    HW_ATL_RPF_VL_UNTAGGED_ACT_SHIFT,
+			    vlan_untagged_act);
+}
+
+void hw_atl_rpf_vlan_flr_en_set(struct aq_hw_s *aq_hw, u32 vlan_flr_en,
+				u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_EN_F_ADR(filter),
+			    HW_ATL_RPF_VL_EN_F_MSK,
+			    HW_ATL_RPF_VL_EN_F_SHIFT,
+			    vlan_flr_en);
+}
+
+void hw_atl_rpf_vlan_flr_act_set(struct aq_hw_s *aq_hw, u32 vlan_flr_act,
+				 u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_ACT_F_ADR(filter),
+			    HW_ATL_RPF_VL_ACT_F_MSK,
+			    HW_ATL_RPF_VL_ACT_F_SHIFT,
+			    vlan_flr_act);
+}
+
+void hw_atl_rpf_vlan_id_flr_set(struct aq_hw_s *aq_hw, u32 vlan_id_flr,
+				u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_VL_ID_F_ADR(filter),
+			    HW_ATL_RPF_VL_ID_F_MSK,
+			    HW_ATL_RPF_VL_ID_F_SHIFT,
+			    vlan_id_flr);
+}
+
+void hw_atl_rpf_etht_flr_en_set(struct aq_hw_s *aq_hw, u32 etht_flr_en,
+				u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_ENF_ADR(filter),
+			    HW_ATL_RPF_ET_ENF_MSK,
+			    HW_ATL_RPF_ET_ENF_SHIFT, etht_flr_en);
+}
+
+void hw_atl_rpf_etht_user_priority_en_set(struct aq_hw_s *aq_hw,
+					  u32 etht_user_priority_en, u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_UPFEN_ADR(filter),
+			    HW_ATL_RPF_ET_UPFEN_MSK, HW_ATL_RPF_ET_UPFEN_SHIFT,
+			    etht_user_priority_en);
+}
+
+void hw_atl_rpf_etht_rx_queue_en_set(struct aq_hw_s *aq_hw,
+				     u32 etht_rx_queue_en,
+				     u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_RXQFEN_ADR(filter),
+			    HW_ATL_RPF_ET_RXQFEN_MSK,
+			    HW_ATL_RPF_ET_RXQFEN_SHIFT,
+			    etht_rx_queue_en);
+}
+
+void hw_atl_rpf_etht_user_priority_set(struct aq_hw_s *aq_hw,
+				       u32 etht_user_priority,
+				       u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_UPF_ADR(filter),
+			    HW_ATL_RPF_ET_UPF_MSK,
+			    HW_ATL_RPF_ET_UPF_SHIFT, etht_user_priority);
+}
+
+void hw_atl_rpf_etht_rx_queue_set(struct aq_hw_s *aq_hw, u32 etht_rx_queue,
+				  u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_RXQF_ADR(filter),
+			    HW_ATL_RPF_ET_RXQF_MSK,
+			    HW_ATL_RPF_ET_RXQF_SHIFT, etht_rx_queue);
+}
+
+void hw_atl_rpf_etht_mgt_queue_set(struct aq_hw_s *aq_hw, u32 etht_mgt_queue,
+				   u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_MNG_RXQF_ADR(filter),
+			    HW_ATL_RPF_ET_MNG_RXQF_MSK,
+			    HW_ATL_RPF_ET_MNG_RXQF_SHIFT,
+			    etht_mgt_queue);
+}
+
+void hw_atl_rpf_etht_flr_act_set(struct aq_hw_s *aq_hw, u32 etht_flr_act,
+				 u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_ACTF_ADR(filter),
+			    HW_ATL_RPF_ET_ACTF_MSK,
+			    HW_ATL_RPF_ET_ACTF_SHIFT, etht_flr_act);
+}
+
+void hw_atl_rpf_etht_flr_set(struct aq_hw_s *aq_hw, u32 etht_flr, u32 filter)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPF_ET_VALF_ADR(filter),
+			    HW_ATL_RPF_ET_VALF_MSK,
+			    HW_ATL_RPF_ET_VALF_SHIFT, etht_flr);
+}
+
+/* RPO: rx packet offload */
+void hw_atl_rpo_ipv4header_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					      u32 ipv4header_crc_offload_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_IPV4CHK_EN_ADR,
+			    HW_ATL_RPO_IPV4CHK_EN_MSK,
+			    HW_ATL_RPO_IPV4CHK_EN_SHIFT,
+			    ipv4header_crc_offload_en);
+}
+
+void hw_atl_rpo_rx_desc_vlan_stripping_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_vlan_stripping,
+					   u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_DESCDVL_STRIP_ADR(descriptor),
+			    HW_ATL_RPO_DESCDVL_STRIP_MSK,
+			    HW_ATL_RPO_DESCDVL_STRIP_SHIFT,
+			    rx_desc_vlan_stripping);
+}
+
+void hw_atl_rpo_tcp_udp_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					   u32 tcp_udp_crc_offload_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPOL4CHK_EN_ADR,
+			    HW_ATL_RPOL4CHK_EN_MSK,
+			    HW_ATL_RPOL4CHK_EN_SHIFT, tcp_udp_crc_offload_en);
+}
+
+void hw_atl_rpo_lro_en_set(struct aq_hw_s *aq_hw, u32 lro_en)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RPO_LRO_EN_ADR, lro_en);
+}
+
+void hw_atl_rpo_lro_patch_optimization_en_set(struct aq_hw_s *aq_hw,
+					      u32 lro_patch_optimization_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_PTOPT_EN_ADR,
+			    HW_ATL_RPO_LRO_PTOPT_EN_MSK,
+			    HW_ATL_RPO_LRO_PTOPT_EN_SHIFT,
+			    lro_patch_optimization_en);
+}
+
+void hw_atl_rpo_lro_qsessions_lim_set(struct aq_hw_s *aq_hw,
+				      u32 lro_qsessions_lim)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_QSES_LMT_ADR,
+			    HW_ATL_RPO_LRO_QSES_LMT_MSK,
+			    HW_ATL_RPO_LRO_QSES_LMT_SHIFT,
+			    lro_qsessions_lim);
+}
+
+void hw_atl_rpo_lro_total_desc_lim_set(struct aq_hw_s *aq_hw,
+				       u32 lro_total_desc_lim)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_TOT_DSC_LMT_ADR,
+			    HW_ATL_RPO_LRO_TOT_DSC_LMT_MSK,
+			    HW_ATL_RPO_LRO_TOT_DSC_LMT_SHIFT,
+			    lro_total_desc_lim);
+}
+
+void hw_atl_rpo_lro_min_pay_of_first_pkt_set(struct aq_hw_s *aq_hw,
+					     u32 lro_min_pld_of_first_pkt)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_PKT_MIN_ADR,
+			    HW_ATL_RPO_LRO_PKT_MIN_MSK,
+			    HW_ATL_RPO_LRO_PKT_MIN_SHIFT,
+			    lro_min_pld_of_first_pkt);
+}
+
+void hw_atl_rpo_lro_pkt_lim_set(struct aq_hw_s *aq_hw, u32 lro_pkt_lim)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_RPO_LRO_RSC_MAX_ADR, lro_pkt_lim);
+}
+
+void hw_atl_rpo_lro_max_num_of_descriptors_set(struct aq_hw_s *aq_hw,
+					       u32 lro_max_number_of_descriptors,
+					       u32 lro)
+{
+/* Register address for bitfield lro{L}_des_max[1:0] */
+	static u32 rpo_lro_ldes_max_adr[32] = {
+			0x000055A0U, 0x000055A0U, 0x000055A0U, 0x000055A0U,
+			0x000055A0U, 0x000055A0U, 0x000055A0U, 0x000055A0U,
+			0x000055A4U, 0x000055A4U, 0x000055A4U, 0x000055A4U,
+			0x000055A4U, 0x000055A4U, 0x000055A4U, 0x000055A4U,
+			0x000055A8U, 0x000055A8U, 0x000055A8U, 0x000055A8U,
+			0x000055A8U, 0x000055A8U, 0x000055A8U, 0x000055A8U,
+			0x000055ACU, 0x000055ACU, 0x000055ACU, 0x000055ACU,
+			0x000055ACU, 0x000055ACU, 0x000055ACU, 0x000055ACU
+		};
+
+/* Bitmask for bitfield lro{L}_des_max[1:0] */
+	static u32 rpo_lro_ldes_max_msk[32] = {
+			0x00000003U, 0x00000030U, 0x00000300U, 0x00003000U,
+			0x00030000U, 0x00300000U, 0x03000000U, 0x30000000U,
+			0x00000003U, 0x00000030U, 0x00000300U, 0x00003000U,
+			0x00030000U, 0x00300000U, 0x03000000U, 0x30000000U,
+			0x00000003U, 0x00000030U, 0x00000300U, 0x00003000U,
+			0x00030000U, 0x00300000U, 0x03000000U, 0x30000000U,
+			0x00000003U, 0x00000030U, 0x00000300U, 0x00003000U,
+			0x00030000U, 0x00300000U, 0x03000000U, 0x30000000U
+		};
+
+/* Lower bit position of bitfield lro{L}_des_max[1:0] */
+	static u32 rpo_lro_ldes_max_shift[32] = {
+			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U,
+			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U,
+			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U,
+			0U, 4U, 8U, 12U, 16U, 20U, 24U, 28U
+		};
+
+	aq_hw_write_reg_bit(aq_hw, rpo_lro_ldes_max_adr[lro],
+			    rpo_lro_ldes_max_msk[lro],
+			    rpo_lro_ldes_max_shift[lro],
+			    lro_max_number_of_descriptors);
+}
+
+void hw_atl_rpo_lro_time_base_divider_set(struct aq_hw_s *aq_hw,
+					  u32 lro_time_base_divider)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_TB_DIV_ADR,
+			    HW_ATL_RPO_LRO_TB_DIV_MSK,
+			    HW_ATL_RPO_LRO_TB_DIV_SHIFT,
+			    lro_time_base_divider);
+}
+
+void hw_atl_rpo_lro_inactive_interval_set(struct aq_hw_s *aq_hw,
+					  u32 lro_inactive_interval)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_INA_IVAL_ADR,
+			    HW_ATL_RPO_LRO_INA_IVAL_MSK,
+			    HW_ATL_RPO_LRO_INA_IVAL_SHIFT,
+			    lro_inactive_interval);
+}
+
+void hw_atl_rpo_lro_max_coalescing_interval_set(struct aq_hw_s *aq_hw,
+						u32 lro_max_coal_interval)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RPO_LRO_MAX_IVAL_ADR,
+			    HW_ATL_RPO_LRO_MAX_IVAL_MSK,
+			    HW_ATL_RPO_LRO_MAX_IVAL_SHIFT,
+			    lro_max_coal_interval);
+}
+
+/* rx */
+void hw_atl_rx_rx_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 rx_reg_res_dis)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_RX_REG_RES_DSBL_ADR,
+			    HW_ATL_RX_REG_RES_DSBL_MSK,
+			    HW_ATL_RX_REG_RES_DSBL_SHIFT,
+			    rx_reg_res_dis);
+}
+
+/* tdm */
+void hw_atl_tdm_cpu_id_set(struct aq_hw_s *aq_hw, u32 cpuid, u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DCADCPUID_ADR(dca),
+			    HW_ATL_TDM_DCADCPUID_MSK,
+			    HW_ATL_TDM_DCADCPUID_SHIFT, cpuid);
+}
+
+void hw_atl_tdm_large_send_offload_en_set(struct aq_hw_s *aq_hw,
+					  u32 large_send_offload_en)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_TDM_LSO_EN_ADR, large_send_offload_en);
+}
+
+void hw_atl_tdm_tx_dca_en_set(struct aq_hw_s *aq_hw, u32 tx_dca_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DCA_EN_ADR, HW_ATL_TDM_DCA_EN_MSK,
+			    HW_ATL_TDM_DCA_EN_SHIFT, tx_dca_en);
+}
+
+void hw_atl_tdm_tx_dca_mode_set(struct aq_hw_s *aq_hw, u32 tx_dca_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DCA_MODE_ADR,
+			    HW_ATL_TDM_DCA_MODE_MSK,
+			    HW_ATL_TDM_DCA_MODE_SHIFT, tx_dca_mode);
+}
+
+void hw_atl_tdm_tx_desc_dca_en_set(struct aq_hw_s *aq_hw, u32 tx_desc_dca_en,
+				   u32 dca)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DCADDESC_EN_ADR(dca),
+			    HW_ATL_TDM_DCADDESC_EN_MSK,
+			    HW_ATL_TDM_DCADDESC_EN_SHIFT,
+			    tx_desc_dca_en);
+}
+
+void hw_atl_tdm_tx_desc_en_set(struct aq_hw_s *aq_hw, u32 tx_desc_en,
+			       u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DESCDEN_ADR(descriptor),
+			    HW_ATL_TDM_DESCDEN_MSK,
+			    HW_ATL_TDM_DESCDEN_SHIFT,
+			    tx_desc_en);
+}
+
+u32 hw_atl_tdm_tx_desc_head_ptr_get(struct aq_hw_s *aq_hw, u32 descriptor)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_TDM_DESCDHD_ADR(descriptor),
+				  HW_ATL_TDM_DESCDHD_MSK,
+				  HW_ATL_TDM_DESCDHD_SHIFT);
+}
+
+void hw_atl_tdm_tx_desc_len_set(struct aq_hw_s *aq_hw, u32 tx_desc_len,
+				u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DESCDLEN_ADR(descriptor),
+			    HW_ATL_TDM_DESCDLEN_MSK,
+			    HW_ATL_TDM_DESCDLEN_SHIFT,
+			    tx_desc_len);
+}
+
+void hw_atl_tdm_tx_desc_wr_wb_irq_en_set(struct aq_hw_s *aq_hw,
+					 u32 tx_desc_wr_wb_irq_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_INT_DESC_WRB_EN_ADR,
+			    HW_ATL_TDM_INT_DESC_WRB_EN_MSK,
+			    HW_ATL_TDM_INT_DESC_WRB_EN_SHIFT,
+			    tx_desc_wr_wb_irq_en);
+}
+
+void hw_atl_tdm_tx_desc_wr_wb_threshold_set(struct aq_hw_s *aq_hw,
+					    u32 tx_desc_wr_wb_threshold,
+					    u32 descriptor)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_DESCDWRB_THRESH_ADR(descriptor),
+			    HW_ATL_TDM_DESCDWRB_THRESH_MSK,
+			    HW_ATL_TDM_DESCDWRB_THRESH_SHIFT,
+			    tx_desc_wr_wb_threshold);
+}
+
+void hw_atl_tdm_tdm_intr_moder_en_set(struct aq_hw_s *aq_hw,
+				      u32 tdm_irq_moderation_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TDM_INT_MOD_EN_ADR,
+			    HW_ATL_TDM_INT_MOD_EN_MSK,
+			    HW_ATL_TDM_INT_MOD_EN_SHIFT,
+			    tdm_irq_moderation_en);
+}
+
+/* thm */
+void hw_atl_thm_lso_tcp_flag_of_first_pkt_set(struct aq_hw_s *aq_hw,
+					      u32 lso_tcp_flag_of_first_pkt)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_THM_LSO_TCP_FLAG_FIRST_ADR,
+			    HW_ATL_THM_LSO_TCP_FLAG_FIRST_MSK,
+			    HW_ATL_THM_LSO_TCP_FLAG_FIRST_SHIFT,
+			    lso_tcp_flag_of_first_pkt);
+}
+
+void hw_atl_thm_lso_tcp_flag_of_last_pkt_set(struct aq_hw_s *aq_hw,
+					     u32 lso_tcp_flag_of_last_pkt)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_THM_LSO_TCP_FLAG_LAST_ADR,
+			    HW_ATL_THM_LSO_TCP_FLAG_LAST_MSK,
+			    HW_ATL_THM_LSO_TCP_FLAG_LAST_SHIFT,
+			    lso_tcp_flag_of_last_pkt);
+}
+
+void hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(struct aq_hw_s *aq_hw,
+					       u32 lso_tcp_flag_of_middle_pkt)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_THM_LSO_TCP_FLAG_MID_ADR,
+			    HW_ATL_THM_LSO_TCP_FLAG_MID_MSK,
+			    HW_ATL_THM_LSO_TCP_FLAG_MID_SHIFT,
+			    lso_tcp_flag_of_middle_pkt);
+}
+
+/* TPB: tx packet buffer */
+void hw_atl_tpb_tx_buff_en_set(struct aq_hw_s *aq_hw, u32 tx_buff_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TX_BUF_EN_ADR,
+			    HW_ATL_TPB_TX_BUF_EN_MSK,
+			    HW_ATL_TPB_TX_BUF_EN_SHIFT, tx_buff_en);
+}
+
+void hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 tx_buff_hi_threshold_per_tc,
+					 u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TXBHI_THRESH_ADR(buffer),
+			    HW_ATL_TPB_TXBHI_THRESH_MSK,
+			    HW_ATL_TPB_TXBHI_THRESH_SHIFT,
+			    tx_buff_hi_threshold_per_tc);
+}
+
+void hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 tx_buff_lo_threshold_per_tc,
+					 u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TXBLO_THRESH_ADR(buffer),
+			    HW_ATL_TPB_TXBLO_THRESH_MSK,
+			    HW_ATL_TPB_TXBLO_THRESH_SHIFT,
+			    tx_buff_lo_threshold_per_tc);
+}
+
+void hw_atl_tpb_tx_dma_sys_lbk_en_set(struct aq_hw_s *aq_hw, u32 tx_dma_sys_lbk_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_DMA_SYS_LBK_ADR,
+			    HW_ATL_TPB_DMA_SYS_LBK_MSK,
+			    HW_ATL_TPB_DMA_SYS_LBK_SHIFT,
+			    tx_dma_sys_lbk_en);
+}
+
+void hw_atl_tpb_tx_pkt_buff_size_per_tc_set(struct aq_hw_s *aq_hw,
+					    u32 tx_pkt_buff_size_per_tc, u32 buffer)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TXBBUF_SIZE_ADR(buffer),
+			    HW_ATL_TPB_TXBBUF_SIZE_MSK,
+			    HW_ATL_TPB_TXBBUF_SIZE_SHIFT,
+			    tx_pkt_buff_size_per_tc);
+}
+
+void hw_atl_tpb_tx_path_scp_ins_en_set(struct aq_hw_s *aq_hw, u32 tx_path_scp_ins_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPB_TX_SCP_INS_EN_ADR,
+			    HW_ATL_TPB_TX_SCP_INS_EN_MSK,
+			    HW_ATL_TPB_TX_SCP_INS_EN_SHIFT,
+			    tx_path_scp_ins_en);
+}
+
+/* TPO: tx packet offload */
+void hw_atl_tpo_ipv4header_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					      u32 ipv4header_crc_offload_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPO_IPV4CHK_EN_ADR,
+			    HW_ATL_TPO_IPV4CHK_EN_MSK,
+			    HW_ATL_TPO_IPV4CHK_EN_SHIFT,
+			    ipv4header_crc_offload_en);
+}
+
+void hw_atl_tpo_tcp_udp_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					   u32 tcp_udp_crc_offload_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPOL4CHK_EN_ADR,
+			    HW_ATL_TPOL4CHK_EN_MSK,
+			    HW_ATL_TPOL4CHK_EN_SHIFT,
+			    tcp_udp_crc_offload_en);
+}
+
+void hw_atl_tpo_tx_pkt_sys_lbk_en_set(struct aq_hw_s *aq_hw,
+				      u32 tx_pkt_sys_lbk_en)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPO_PKT_SYS_LBK_ADR,
+			    HW_ATL_TPO_PKT_SYS_LBK_MSK,
+			    HW_ATL_TPO_PKT_SYS_LBK_SHIFT,
+			    tx_pkt_sys_lbk_en);
+}
+
+/* TPS: tx packet scheduler */
+void hw_atl_tps_tx_pkt_shed_data_arb_mode_set(struct aq_hw_s *aq_hw,
+					      u32 tx_pkt_shed_data_arb_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DATA_TC_ARB_MODE_ADR,
+			    HW_ATL_TPS_DATA_TC_ARB_MODE_MSK,
+			    HW_ATL_TPS_DATA_TC_ARB_MODE_SHIFT,
+			    tx_pkt_shed_data_arb_mode);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(struct aq_hw_s *aq_hw,
+							u32 curr_time_res)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_RATE_TA_RST_ADR,
+			    HW_ATL_TPS_DESC_RATE_TA_RST_MSK,
+			    HW_ATL_TPS_DESC_RATE_TA_RST_SHIFT,
+			    curr_time_res);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_rate_lim_set(struct aq_hw_s *aq_hw,
+					      u32 tx_pkt_shed_desc_rate_lim)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_RATE_LIM_ADR,
+			    HW_ATL_TPS_DESC_RATE_LIM_MSK,
+			    HW_ATL_TPS_DESC_RATE_LIM_SHIFT,
+			    tx_pkt_shed_desc_rate_lim);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(struct aq_hw_s *aq_hw,
+						 u32 arb_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_TC_ARB_MODE_ADR,
+			    HW_ATL_TPS_DESC_TC_ARB_MODE_MSK,
+			    HW_ATL_TPS_DESC_TC_ARB_MODE_SHIFT,
+			    arb_mode);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(struct aq_hw_s *aq_hw,
+						   u32 max_credit,
+						   u32 tc)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_TCTCREDIT_MAX_ADR(tc),
+			    HW_ATL_TPS_DESC_TCTCREDIT_MAX_MSK,
+			    HW_ATL_TPS_DESC_TCTCREDIT_MAX_SHIFT,
+			    max_credit);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(struct aq_hw_s *aq_hw,
+					       u32 tx_pkt_shed_desc_tc_weight,
+					       u32 tc)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_TCTWEIGHT_ADR(tc),
+			    HW_ATL_TPS_DESC_TCTWEIGHT_MSK,
+			    HW_ATL_TPS_DESC_TCTWEIGHT_SHIFT,
+			    tx_pkt_shed_desc_tc_weight);
+}
+
+void hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(struct aq_hw_s *aq_hw,
+						 u32 arb_mode)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DESC_VM_ARB_MODE_ADR,
+			    HW_ATL_TPS_DESC_VM_ARB_MODE_MSK,
+			    HW_ATL_TPS_DESC_VM_ARB_MODE_SHIFT,
+			    arb_mode);
+}
+
+void hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(struct aq_hw_s *aq_hw,
+						   u32 max_credit,
+						   u32 tc)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DATA_TCTCREDIT_MAX_ADR(tc),
+			    HW_ATL_TPS_DATA_TCTCREDIT_MAX_MSK,
+			    HW_ATL_TPS_DATA_TCTCREDIT_MAX_SHIFT,
+			    max_credit);
+}
+
+void hw_atl_tps_tx_pkt_shed_tc_data_weight_set(struct aq_hw_s *aq_hw,
+					       u32 tx_pkt_shed_tc_data_weight,
+					       u32 tc)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TPS_DATA_TCTWEIGHT_ADR(tc),
+			    HW_ATL_TPS_DATA_TCTWEIGHT_MSK,
+			    HW_ATL_TPS_DATA_TCTWEIGHT_SHIFT,
+			    tx_pkt_shed_tc_data_weight);
+}
+
+/* tx */
+void hw_atl_tx_tx_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 tx_reg_res_dis)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_TX_REG_RES_DSBL_ADR,
+			    HW_ATL_TX_REG_RES_DSBL_MSK,
+			    HW_ATL_TX_REG_RES_DSBL_SHIFT, tx_reg_res_dis);
+}
+
+/* msm */
+u32 hw_atl_msm_reg_access_status_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg_bit(aq_hw, HW_ATL_MSM_REG_ACCESS_BUSY_ADR,
+				  HW_ATL_MSM_REG_ACCESS_BUSY_MSK,
+				  HW_ATL_MSM_REG_ACCESS_BUSY_SHIFT);
+}
+
+void hw_atl_msm_reg_addr_for_indirect_addr_set(struct aq_hw_s *aq_hw,
+					       u32 reg_addr_for_indirect_addr)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_MSM_REG_ADDR_ADR,
+			    HW_ATL_MSM_REG_ADDR_MSK,
+			    HW_ATL_MSM_REG_ADDR_SHIFT,
+			    reg_addr_for_indirect_addr);
+}
+
+void hw_atl_msm_reg_rd_strobe_set(struct aq_hw_s *aq_hw, u32 reg_rd_strobe)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_MSM_REG_RD_STROBE_ADR,
+			    HW_ATL_MSM_REG_RD_STROBE_MSK,
+			    HW_ATL_MSM_REG_RD_STROBE_SHIFT,
+			    reg_rd_strobe);
+}
+
+u32 hw_atl_msm_reg_rd_data_get(struct aq_hw_s *aq_hw)
+{
+	return aq_hw_read_reg(aq_hw, HW_ATL_MSM_REG_RD_DATA_ADR);
+}
+
+void hw_atl_msm_reg_wr_data_set(struct aq_hw_s *aq_hw, u32 reg_wr_data)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_MSM_REG_WR_DATA_ADR, reg_wr_data);
+}
+
+void hw_atl_msm_reg_wr_strobe_set(struct aq_hw_s *aq_hw, u32 reg_wr_strobe)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_MSM_REG_WR_STROBE_ADR,
+			    HW_ATL_MSM_REG_WR_STROBE_MSK,
+			    HW_ATL_MSM_REG_WR_STROBE_SHIFT,
+			    reg_wr_strobe);
+}
+
+/* pci */
+void hw_atl_pci_pci_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 pci_reg_res_dis)
+{
+	aq_hw_write_reg_bit(aq_hw, HW_ATL_PCI_REG_RES_DSBL_ADR,
+			    HW_ATL_PCI_REG_RES_DSBL_MSK,
+			    HW_ATL_PCI_REG_RES_DSBL_SHIFT,
+			    pci_reg_res_dis);
+}
+
+void hw_atl_reg_glb_cpu_scratch_scp_set(struct aq_hw_s *aq_hw,
+					u32 glb_cpu_scratch_scp,
+					u32 scratch_scp)
+{
+	aq_hw_write_reg(aq_hw, HW_ATL_GLB_CPU_SCRATCH_SCP_ADR(scratch_scp),
+			glb_cpu_scratch_scp);
+}
+
+void mcp_up_force_intr_set(struct aq_hw_s *aq_hw, u32 up_force_intr)
+{
+
+	aq_hw_write_reg_bit(aq_hw, mcp_up_force_interrupt_adr,
+			mcp_up_force_interrupt_msk,
+			mcp_up_force_interrupt_shift, up_force_intr);
+}
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.h
new file mode 100644
index 00000000..d2da1a6
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh.h
@@ -0,0 +1,705 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_llh.h: Declarations of bitfield and register access functions for
+ * Atlantic registers.
+ */
+
+#ifndef HW_ATL_LLH_H
+#define HW_ATL_LLH_H
+
+#include <linux/types.h>
+
+struct aq_hw_s;
+
+/* global */
+
+/* set global microprocessor semaphore */
+void hw_atl_reg_glb_cpu_sem_set(struct aq_hw_s *aq_hw,	u32 glb_cpu_sem,
+				u32 semaphore);
+
+/* get global microprocessor semaphore */
+u32 hw_atl_reg_glb_cpu_sem_get(struct aq_hw_s *aq_hw, u32 semaphore);
+
+/* set global register reset disable */
+void hw_atl_glb_glb_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 glb_reg_res_dis);
+
+/* set soft reset */
+void hw_atl_glb_soft_res_set(struct aq_hw_s *aq_hw, u32 soft_res);
+
+/* get soft reset */
+u32 hw_atl_glb_soft_res_get(struct aq_hw_s *aq_hw);
+
+/* stats */
+
+u32 hw_atl_rpb_rx_dma_drop_pkt_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get rx dma good octet counter lsw */
+u32 hw_atl_stats_rx_dma_good_octet_counterlsw_get(struct aq_hw_s *aq_hw);
+
+/* get rx dma good packet counter lsw */
+u32 hw_atl_stats_rx_dma_good_pkt_counterlsw_get(struct aq_hw_s *aq_hw);
+
+/* get tx dma good octet counter lsw */
+u32 hw_atl_stats_tx_dma_good_octet_counterlsw_get(struct aq_hw_s *aq_hw);
+
+/* get tx dma good packet counter lsw */
+u32 hw_atl_stats_tx_dma_good_pkt_counterlsw_get(struct aq_hw_s *aq_hw);
+
+/* get rx dma good octet counter msw */
+u32 hw_atl_stats_rx_dma_good_octet_countermsw_get(struct aq_hw_s *aq_hw);
+
+/* get rx dma good packet counter msw */
+u32 hw_atl_stats_rx_dma_good_pkt_countermsw_get(struct aq_hw_s *aq_hw);
+
+/* get tx dma good octet counter msw */
+u32 hw_atl_stats_tx_dma_good_octet_countermsw_get(struct aq_hw_s *aq_hw);
+
+/* get tx dma good packet counter msw */
+u32 hw_atl_stats_tx_dma_good_pkt_countermsw_get(struct aq_hw_s *aq_hw);
+
+/* get msm rx errors counter register */
+u32 hw_atl_reg_mac_msm_rx_errs_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm rx unicast frames counter register */
+u32 hw_atl_reg_mac_msm_rx_ucst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm rx multicast frames counter register */
+u32 hw_atl_reg_mac_msm_rx_mcst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm rx broadcast frames counter register */
+u32 hw_atl_reg_mac_msm_rx_bcst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm rx broadcast octets counter register 1 */
+u32 hw_atl_reg_mac_msm_rx_bcst_octets_counter1get(struct aq_hw_s *aq_hw);
+
+/* get msm rx unicast octets counter register 0 */
+u32 hw_atl_reg_mac_msm_rx_ucst_octets_counter0get(struct aq_hw_s *aq_hw);
+
+/* get rx dma statistics counter 7 */
+u32 hw_atl_reg_rx_dma_stat_counter7get(struct aq_hw_s *aq_hw);
+
+/* get msm tx errors counter register */
+u32 hw_atl_reg_mac_msm_tx_errs_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm tx unicast frames counter register */
+u32 hw_atl_reg_mac_msm_tx_ucst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm tx multicast frames counter register */
+u32 hw_atl_reg_mac_msm_tx_mcst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm tx broadcast frames counter register */
+u32 hw_atl_reg_mac_msm_tx_bcst_frm_cnt_get(struct aq_hw_s *aq_hw);
+
+/* get msm tx multicast octets counter register 1 */
+u32 hw_atl_reg_mac_msm_tx_mcst_octets_counter1get(struct aq_hw_s *aq_hw);
+
+/* get msm tx broadcast octets counter register 1 */
+u32 hw_atl_reg_mac_msm_tx_bcst_octets_counter1get(struct aq_hw_s *aq_hw);
+
+/* get msm tx unicast octets counter register 0 */
+u32 hw_atl_reg_mac_msm_tx_ucst_octets_counter0get(struct aq_hw_s *aq_hw);
+
+/* get global mif identification */
+u32 hw_atl_reg_glb_mif_id_get(struct aq_hw_s *aq_hw);
+
+/* interrupt */
+
+/* set interrupt auto mask lsw */
+void hw_atl_itr_irq_auto_masklsw_set(struct aq_hw_s *aq_hw,
+				     u32 irq_auto_masklsw);
+
+/* set interrupt mapping enable rx */
+void hw_atl_itr_irq_map_en_rx_set(struct aq_hw_s *aq_hw, u32 irq_map_en_rx,
+				  u32 rx);
+
+/* set interrupt mapping enable tx */
+void hw_atl_itr_irq_map_en_tx_set(struct aq_hw_s *aq_hw, u32 irq_map_en_tx,
+				  u32 tx);
+
+/* set interrupt mapping rx */
+void hw_atl_itr_irq_map_rx_set(struct aq_hw_s *aq_hw, u32 irq_map_rx, u32 rx);
+
+/* set interrupt mapping tx */
+void hw_atl_itr_irq_map_tx_set(struct aq_hw_s *aq_hw, u32 irq_map_tx, u32 tx);
+
+/* set interrupt mask clear lsw */
+void hw_atl_itr_irq_msk_clearlsw_set(struct aq_hw_s *aq_hw,
+				     u32 irq_msk_clearlsw);
+
+/* set interrupt mask set lsw */
+void hw_atl_itr_irq_msk_setlsw_set(struct aq_hw_s *aq_hw, u32 irq_msk_setlsw);
+
+/* set interrupt register reset disable */
+void hw_atl_itr_irq_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 irq_reg_res_dis);
+
+/* set interrupt status clear lsw */
+void hw_atl_itr_irq_status_clearlsw_set(struct aq_hw_s *aq_hw,
+					u32 irq_status_clearlsw);
+
+/* get interrupt status lsw */
+u32 hw_atl_itr_irq_statuslsw_get(struct aq_hw_s *aq_hw);
+
+/* get reset interrupt */
+u32 hw_atl_itr_res_irq_get(struct aq_hw_s *aq_hw);
+
+/* set reset interrupt */
+void hw_atl_itr_res_irq_set(struct aq_hw_s *aq_hw, u32 res_irq);
+
+/* rdm */
+
+/* set cpu id */
+void hw_atl_rdm_cpu_id_set(struct aq_hw_s *aq_hw, u32 cpuid, u32 dca);
+
+/* set rx dca enable */
+void hw_atl_rdm_rx_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_dca_en);
+
+/* set rx dca mode */
+void hw_atl_rdm_rx_dca_mode_set(struct aq_hw_s *aq_hw, u32 rx_dca_mode);
+
+/* set rx descriptor data buffer size */
+void hw_atl_rdm_rx_desc_data_buff_size_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_data_buff_size,
+				    u32 descriptor);
+
+/* set rx descriptor dca enable */
+void hw_atl_rdm_rx_desc_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_desc_dca_en,
+				   u32 dca);
+
+/* set rx descriptor enable */
+void hw_atl_rdm_rx_desc_en_set(struct aq_hw_s *aq_hw, u32 rx_desc_en,
+			       u32 descriptor);
+
+/* set rx descriptor header splitting */
+void hw_atl_rdm_rx_desc_head_splitting_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_head_splitting,
+				    u32 descriptor);
+
+/* get rx descriptor head pointer */
+u32 hw_atl_rdm_rx_desc_head_ptr_get(struct aq_hw_s *aq_hw, u32 descriptor);
+
+/* set rx descriptor length */
+void hw_atl_rdm_rx_desc_len_set(struct aq_hw_s *aq_hw, u32 rx_desc_len,
+				u32 descriptor);
+
+/* set rx descriptor write-back interrupt enable */
+void hw_atl_rdm_rx_desc_wr_wb_irq_en_set(struct aq_hw_s *aq_hw,
+					 u32 rx_desc_wr_wb_irq_en);
+
+/* set rx header dca enable */
+void hw_atl_rdm_rx_head_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_head_dca_en,
+				   u32 dca);
+
+/* set rx payload dca enable */
+void hw_atl_rdm_rx_pld_dca_en_set(struct aq_hw_s *aq_hw, u32 rx_pld_dca_en,
+				  u32 dca);
+
+/* set rx descriptor header buffer size */
+void hw_atl_rdm_rx_desc_head_buff_size_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_head_buff_size,
+					   u32 descriptor);
+
+/* set rx descriptor reset */
+void hw_atl_rdm_rx_desc_res_set(struct aq_hw_s *aq_hw, u32 rx_desc_res,
+				u32 descriptor);
+
+/* Set RDM Interrupt Moderation Enable */
+void hw_atl_rdm_rdm_intr_moder_en_set(struct aq_hw_s *aq_hw,
+				      u32 rdm_intr_moder_en);
+
+/* reg */
+
+/* set general interrupt mapping register */
+void hw_atl_reg_gen_irq_map_set(struct aq_hw_s *aq_hw, u32 gen_intr_map,
+				u32 regidx);
+
+/* get general interrupt status register */
+u32 hw_atl_reg_gen_irq_status_get(struct aq_hw_s *aq_hw);
+
+/* set interrupt global control register */
+void hw_atl_reg_irq_glb_ctl_set(struct aq_hw_s *aq_hw, u32 intr_glb_ctl);
+
+/* set interrupt throttle register */
+void hw_atl_reg_irq_thr_set(struct aq_hw_s *aq_hw, u32 intr_thr, u32 throttle);
+
+/* set rx dma descriptor base address lsw */
+void hw_atl_reg_rx_dma_desc_base_addresslswset(struct aq_hw_s *aq_hw,
+					       u32 rx_dma_desc_base_addrlsw,
+					u32 descriptor);
+
+/* set rx dma descriptor base address msw */
+void hw_atl_reg_rx_dma_desc_base_addressmswset(struct aq_hw_s *aq_hw,
+					       u32 rx_dma_desc_base_addrmsw,
+					u32 descriptor);
+
+/* get rx dma descriptor status register */
+u32 hw_atl_reg_rx_dma_desc_status_get(struct aq_hw_s *aq_hw, u32 descriptor);
+
+/* set rx dma descriptor tail pointer register */
+void hw_atl_reg_rx_dma_desc_tail_ptr_set(struct aq_hw_s *aq_hw,
+					 u32 rx_dma_desc_tail_ptr,
+				  u32 descriptor);
+
+/* set rx filter multicast filter mask register */
+void hw_atl_reg_rx_flr_mcst_flr_msk_set(struct aq_hw_s *aq_hw,
+					u32 rx_flr_mcst_flr_msk);
+
+/* set rx filter multicast filter register */
+void hw_atl_reg_rx_flr_mcst_flr_set(struct aq_hw_s *aq_hw, u32 rx_flr_mcst_flr,
+				    u32 filter);
+
+/* set rx filter rss control register 1 */
+void hw_atl_reg_rx_flr_rss_control1set(struct aq_hw_s *aq_hw,
+				       u32 rx_flr_rss_control1);
+
+/* Set RX Filter Control Register 2 */
+void hw_atl_reg_rx_flr_control2_set(struct aq_hw_s *aq_hw, u32 rx_flr_control2);
+
+/* Set RX Interrupt Moderation Control Register */
+void hw_atl_reg_rx_intr_moder_ctrl_set(struct aq_hw_s *aq_hw,
+				       u32 rx_intr_moderation_ctl,
+				u32 queue);
+
+/* set tx dma debug control */
+void hw_atl_reg_tx_dma_debug_ctl_set(struct aq_hw_s *aq_hw,
+				     u32 tx_dma_debug_ctl);
+
+/* set tx dma descriptor base address lsw */
+void hw_atl_reg_tx_dma_desc_base_addresslswset(struct aq_hw_s *aq_hw,
+					       u32 tx_dma_desc_base_addrlsw,
+					u32 descriptor);
+
+/* set tx dma descriptor base address msw */
+void hw_atl_reg_tx_dma_desc_base_addressmswset(struct aq_hw_s *aq_hw,
+					       u32 tx_dma_desc_base_addrmsw,
+					u32 descriptor);
+
+/* set tx dma descriptor tail pointer register */
+void hw_atl_reg_tx_dma_desc_tail_ptr_set(struct aq_hw_s *aq_hw,
+					 u32 tx_dma_desc_tail_ptr,
+					 u32 descriptor);
+
+/* Set TX Interrupt Moderation Control Register */
+void hw_atl_reg_tx_intr_moder_ctrl_set(struct aq_hw_s *aq_hw,
+				       u32 tx_intr_moderation_ctl,
+				       u32 queue);
+
+/* set global microprocessor scratch pad */
+void hw_atl_reg_glb_cpu_scratch_scp_set(struct aq_hw_s *aq_hw,
+					u32 glb_cpu_scratch_scp,
+					u32 scratch_scp);
+
+/* rpb */
+
+/* set dma system loopback */
+void hw_atl_rpb_dma_sys_lbk_set(struct aq_hw_s *aq_hw, u32 dma_sys_lbk);
+
+/* set rx traffic class mode */
+void hw_atl_rpb_rpf_rx_traf_class_mode_set(struct aq_hw_s *aq_hw,
+					   u32 rx_traf_class_mode);
+
+/* set rx buffer enable */
+void hw_atl_rpb_rx_buff_en_set(struct aq_hw_s *aq_hw, u32 rx_buff_en);
+
+/* set rx buffer high threshold (per tc) */
+void hw_atl_rpb_rx_buff_hi_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 rx_buff_hi_threshold_per_tc,
+						u32 buffer);
+
+/* set rx buffer low threshold (per tc) */
+void hw_atl_rpb_rx_buff_lo_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 rx_buff_lo_threshold_per_tc,
+					 u32 buffer);
+
+/* set rx flow control mode */
+void hw_atl_rpb_rx_flow_ctl_mode_set(struct aq_hw_s *aq_hw, u32 rx_flow_ctl_mode);
+
+/* set rx packet buffer size (per tc) */
+void hw_atl_rpb_rx_pkt_buff_size_per_tc_set(struct aq_hw_s *aq_hw,
+					    u32 rx_pkt_buff_size_per_tc,
+					    u32 buffer);
+
+/* set rx xoff enable (per tc) */
+void hw_atl_rpb_rx_xoff_en_per_tc_set(struct aq_hw_s *aq_hw, u32 rx_xoff_en_per_tc,
+				      u32 buffer);
+
+/* rpf */
+
+/* set l2 broadcast count threshold */
+void hw_atl_rpfl2broadcast_count_threshold_set(struct aq_hw_s *aq_hw,
+					       u32 l2broadcast_count_threshold);
+
+/* set l2 broadcast enable */
+void hw_atl_rpfl2broadcast_en_set(struct aq_hw_s *aq_hw, u32 l2broadcast_en);
+
+/* set l2 broadcast filter action */
+void hw_atl_rpfl2broadcast_flr_act_set(struct aq_hw_s *aq_hw,
+				       u32 l2broadcast_flr_act);
+
+/* set l2 multicast filter enable */
+void hw_atl_rpfl2multicast_flr_en_set(struct aq_hw_s *aq_hw,
+				      u32 l2multicast_flr_en,
+				      u32 filter);
+
+/* set l2 promiscuous mode enable */
+void hw_atl_rpfl2promiscuous_mode_en_set(struct aq_hw_s *aq_hw,
+					 u32 l2promiscuous_mode_en);
+
+/* set l2 unicast filter action */
+void hw_atl_rpfl2unicast_flr_act_set(struct aq_hw_s *aq_hw,
+				     u32 l2unicast_flr_act,
+				     u32 filter);
+
+/* set l2 unicast filter enable */
+void hw_atl_rpfl2_uc_flr_en_set(struct aq_hw_s *aq_hw, u32 l2unicast_flr_en,
+				u32 filter);
+
+/* set l2 unicast destination address lsw */
+void hw_atl_rpfl2unicast_dest_addresslsw_set(struct aq_hw_s *aq_hw,
+					     u32 l2unicast_dest_addresslsw,
+				      u32 filter);
+
+/* set l2 unicast destination address msw */
+void hw_atl_rpfl2unicast_dest_addressmsw_set(struct aq_hw_s *aq_hw,
+					     u32 l2unicast_dest_addressmsw,
+				      u32 filter);
+
+/* Set L2 Accept all Multicast packets */
+void hw_atl_rpfl2_accept_all_mc_packets_set(struct aq_hw_s *aq_hw,
+					    u32 l2_accept_all_mc_packets);
+
+/* set user-priority tc mapping */
+void hw_atl_rpf_rpb_user_priority_tc_map_set(struct aq_hw_s *aq_hw,
+					     u32 user_priority_tc_map, u32 tc);
+
+/* set rss key address */
+void hw_atl_rpf_rss_key_addr_set(struct aq_hw_s *aq_hw, u32 rss_key_addr);
+
+/* set rss key write data */
+void hw_atl_rpf_rss_key_wr_data_set(struct aq_hw_s *aq_hw, u32 rss_key_wr_data);
+
+/* get rss key write enable */
+u32 hw_atl_rpf_rss_key_wr_en_get(struct aq_hw_s *aq_hw);
+
+/* set rss key write enable */
+void hw_atl_rpf_rss_key_wr_en_set(struct aq_hw_s *aq_hw, u32 rss_key_wr_en);
+
+/* set rss redirection table address */
+void hw_atl_rpf_rss_redir_tbl_addr_set(struct aq_hw_s *aq_hw,
+				       u32 rss_redir_tbl_addr);
+
+/* set rss redirection table write data */
+void hw_atl_rpf_rss_redir_tbl_wr_data_set(struct aq_hw_s *aq_hw,
+					  u32 rss_redir_tbl_wr_data);
+
+/* get rss redirection write enable */
+u32 hw_atl_rpf_rss_redir_wr_en_get(struct aq_hw_s *aq_hw);
+
+/* set rss redirection write enable */
+void hw_atl_rpf_rss_redir_wr_en_set(struct aq_hw_s *aq_hw, u32 rss_redir_wr_en);
+
+/* set tpo to rpf system loopback */
+void hw_atl_rpf_tpo_to_rpf_sys_lbk_set(struct aq_hw_s *aq_hw,
+				       u32 tpo_to_rpf_sys_lbk);
+
+/* set vlan inner ethertype */
+void hw_atl_rpf_vlan_inner_etht_set(struct aq_hw_s *aq_hw, u32 vlan_inner_etht);
+
+/* set vlan outer ethertype */
+void hw_atl_rpf_vlan_outer_etht_set(struct aq_hw_s *aq_hw, u32 vlan_outer_etht);
+
+/* set vlan promiscuous mode enable */
+void hw_atl_rpf_vlan_prom_mode_en_set(struct aq_hw_s *aq_hw,
+				      u32 vlan_prom_mode_en);
+
+/* Set VLAN untagged action */
+void hw_atl_rpf_vlan_untagged_act_set(struct aq_hw_s *aq_hw,
+				      u32 vlan_untagged_act);
+
+/* Set VLAN accept untagged packets */
+void hw_atl_rpf_vlan_accept_untagged_packets_set(struct aq_hw_s *aq_hw,
+						 u32 vlan_acc_untagged_packets);
+
+/* Set VLAN filter enable */
+void hw_atl_rpf_vlan_flr_en_set(struct aq_hw_s *aq_hw, u32 vlan_flr_en,
+				u32 filter);
+
+/* Set VLAN Filter Action */
+void hw_atl_rpf_vlan_flr_act_set(struct aq_hw_s *aq_hw, u32 vlan_filter_act,
+				 u32 filter);
+
+/* Set VLAN ID Filter */
+void hw_atl_rpf_vlan_id_flr_set(struct aq_hw_s *aq_hw, u32 vlan_id_flr,
+				u32 filter);
+
+/* set ethertype filter enable */
+void hw_atl_rpf_etht_flr_en_set(struct aq_hw_s *aq_hw, u32 etht_flr_en,
+				u32 filter);
+
+/* set  ethertype user-priority enable */
+void hw_atl_rpf_etht_user_priority_en_set(struct aq_hw_s *aq_hw,
+					  u32 etht_user_priority_en,
+					  u32 filter);
+
+/* set  ethertype rx queue enable */
+void hw_atl_rpf_etht_rx_queue_en_set(struct aq_hw_s *aq_hw,
+				     u32 etht_rx_queue_en,
+				     u32 filter);
+
+/* set ethertype rx queue */
+void hw_atl_rpf_etht_rx_queue_set(struct aq_hw_s *aq_hw, u32 etht_rx_queue,
+				  u32 filter);
+
+/* set ethertype user-priority */
+void hw_atl_rpf_etht_user_priority_set(struct aq_hw_s *aq_hw,
+				       u32 etht_user_priority,
+				       u32 filter);
+
+/* set ethertype management queue */
+void hw_atl_rpf_etht_mgt_queue_set(struct aq_hw_s *aq_hw, u32 etht_mgt_queue,
+				   u32 filter);
+
+/* set ethertype filter action */
+void hw_atl_rpf_etht_flr_act_set(struct aq_hw_s *aq_hw, u32 etht_flr_act,
+				 u32 filter);
+
+/* set ethertype filter */
+void hw_atl_rpf_etht_flr_set(struct aq_hw_s *aq_hw, u32 etht_flr, u32 filter);
+
+/* rpo */
+
+/* set ipv4 header checksum offload enable */
+void hw_atl_rpo_ipv4header_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					      u32 ipv4header_crc_offload_en);
+
+/* set rx descriptor vlan stripping */
+void hw_atl_rpo_rx_desc_vlan_stripping_set(struct aq_hw_s *aq_hw,
+					   u32 rx_desc_vlan_stripping,
+					   u32 descriptor);
+
+/* set tcp/udp checksum offload enable */
+void hw_atl_rpo_tcp_udp_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					   u32 tcp_udp_crc_offload_en);
+
+/* Set LRO Patch Optimization Enable. */
+void hw_atl_rpo_lro_patch_optimization_en_set(struct aq_hw_s *aq_hw,
+					      u32 lro_patch_optimization_en);
+
+/* Set Large Receive Offload Enable */
+void hw_atl_rpo_lro_en_set(struct aq_hw_s *aq_hw, u32 lro_en);
+
+/* Set LRO Q Sessions Limit */
+void hw_atl_rpo_lro_qsessions_lim_set(struct aq_hw_s *aq_hw,
+				      u32 lro_qsessions_lim);
+
+/* Set LRO Total Descriptor Limit */
+void hw_atl_rpo_lro_total_desc_lim_set(struct aq_hw_s *aq_hw,
+				       u32 lro_total_desc_lim);
+
+/* Set LRO Min Payload of First Packet */
+void hw_atl_rpo_lro_min_pay_of_first_pkt_set(struct aq_hw_s *aq_hw,
+					     u32 lro_min_pld_of_first_pkt);
+
+/* Set LRO Packet Limit */
+void hw_atl_rpo_lro_pkt_lim_set(struct aq_hw_s *aq_hw, u32 lro_packet_lim);
+
+/* Set LRO Max Number of Descriptors */
+void hw_atl_rpo_lro_max_num_of_descriptors_set(struct aq_hw_s *aq_hw,
+					       u32 lro_max_desc_num, u32 lro);
+
+/* Set LRO Time Base Divider */
+void hw_atl_rpo_lro_time_base_divider_set(struct aq_hw_s *aq_hw,
+					  u32 lro_time_base_divider);
+
+/*Set LRO Inactive Interval */
+void hw_atl_rpo_lro_inactive_interval_set(struct aq_hw_s *aq_hw,
+					  u32 lro_inactive_interval);
+
+/*Set LRO Max Coalescing Interval */
+void hw_atl_rpo_lro_max_coalescing_interval_set(struct aq_hw_s *aq_hw,
+						u32 lro_max_coal_interval);
+
+/* rx */
+
+/* set rx register reset disable */
+void hw_atl_rx_rx_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 rx_reg_res_dis);
+
+/* tdm */
+
+/* set cpu id */
+void hw_atl_tdm_cpu_id_set(struct aq_hw_s *aq_hw, u32 cpuid, u32 dca);
+
+/* set large send offload enable */
+void hw_atl_tdm_large_send_offload_en_set(struct aq_hw_s *aq_hw,
+					  u32 large_send_offload_en);
+
+/* set tx descriptor enable */
+void hw_atl_tdm_tx_desc_en_set(struct aq_hw_s *aq_hw, u32 tx_desc_en,
+			       u32 descriptor);
+
+/* set tx dca enable */
+void hw_atl_tdm_tx_dca_en_set(struct aq_hw_s *aq_hw, u32 tx_dca_en);
+
+/* set tx dca mode */
+void hw_atl_tdm_tx_dca_mode_set(struct aq_hw_s *aq_hw, u32 tx_dca_mode);
+
+/* set tx descriptor dca enable */
+void hw_atl_tdm_tx_desc_dca_en_set(struct aq_hw_s *aq_hw, u32 tx_desc_dca_en,
+				   u32 dca);
+
+/* get tx descriptor head pointer */
+u32 hw_atl_tdm_tx_desc_head_ptr_get(struct aq_hw_s *aq_hw, u32 descriptor);
+
+/* set tx descriptor length */
+void hw_atl_tdm_tx_desc_len_set(struct aq_hw_s *aq_hw, u32 tx_desc_len,
+				u32 descriptor);
+
+/* set tx descriptor write-back interrupt enable */
+void hw_atl_tdm_tx_desc_wr_wb_irq_en_set(struct aq_hw_s *aq_hw,
+					 u32 tx_desc_wr_wb_irq_en);
+
+/* set tx descriptor write-back threshold */
+void hw_atl_tdm_tx_desc_wr_wb_threshold_set(struct aq_hw_s *aq_hw,
+					    u32 tx_desc_wr_wb_threshold,
+				     u32 descriptor);
+
+/* Set TDM Interrupt Moderation Enable */
+void hw_atl_tdm_tdm_intr_moder_en_set(struct aq_hw_s *aq_hw,
+				      u32 tdm_irq_moderation_en);
+/* thm */
+
+/* set lso tcp flag of first packet */
+void hw_atl_thm_lso_tcp_flag_of_first_pkt_set(struct aq_hw_s *aq_hw,
+					      u32 lso_tcp_flag_of_first_pkt);
+
+/* set lso tcp flag of last packet */
+void hw_atl_thm_lso_tcp_flag_of_last_pkt_set(struct aq_hw_s *aq_hw,
+					     u32 lso_tcp_flag_of_last_pkt);
+
+/* set lso tcp flag of middle packet */
+void hw_atl_thm_lso_tcp_flag_of_middle_pkt_set(struct aq_hw_s *aq_hw,
+					       u32 lso_tcp_flag_of_middle_pkt);
+
+/* tpb */
+
+/* set tx buffer enable */
+void hw_atl_tpb_tx_buff_en_set(struct aq_hw_s *aq_hw, u32 tx_buff_en);
+
+/* set tx buffer high threshold (per tc) */
+void hw_atl_tpb_tx_buff_hi_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 tx_buff_hi_threshold_per_tc,
+					 u32 buffer);
+
+/* set tx buffer low threshold (per tc) */
+void hw_atl_tpb_tx_buff_lo_threshold_per_tc_set(struct aq_hw_s *aq_hw,
+						u32 tx_buff_lo_threshold_per_tc,
+					 u32 buffer);
+
+/* set tx dma system loopback enable */
+void hw_atl_tpb_tx_dma_sys_lbk_en_set(struct aq_hw_s *aq_hw, u32 tx_dma_sys_lbk_en);
+
+/* set tx packet buffer size (per tc) */
+void hw_atl_tpb_tx_pkt_buff_size_per_tc_set(struct aq_hw_s *aq_hw,
+					    u32 tx_pkt_buff_size_per_tc, u32 buffer);
+
+/* set tx path pad insert enable */
+void hw_atl_tpb_tx_path_scp_ins_en_set(struct aq_hw_s *aq_hw, u32 tx_path_scp_ins_en);
+
+/* tpo */
+
+/* set ipv4 header checksum offload enable */
+void hw_atl_tpo_ipv4header_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					      u32 ipv4header_crc_offload_en);
+
+/* set tcp/udp checksum offload enable */
+void hw_atl_tpo_tcp_udp_crc_offload_en_set(struct aq_hw_s *aq_hw,
+					   u32 tcp_udp_crc_offload_en);
+
+/* set tx pkt system loopback enable */
+void hw_atl_tpo_tx_pkt_sys_lbk_en_set(struct aq_hw_s *aq_hw,
+				      u32 tx_pkt_sys_lbk_en);
+
+/* tps */
+
+/* set tx packet scheduler data arbitration mode */
+void hw_atl_tps_tx_pkt_shed_data_arb_mode_set(struct aq_hw_s *aq_hw,
+					      u32 tx_pkt_shed_data_arb_mode);
+
+/* set tx packet scheduler descriptor rate current time reset */
+void hw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(struct aq_hw_s *aq_hw,
+							u32 curr_time_res);
+
+/* set tx packet scheduler descriptor rate limit */
+void hw_atl_tps_tx_pkt_shed_desc_rate_lim_set(struct aq_hw_s *aq_hw,
+					      u32 tx_pkt_shed_desc_rate_lim);
+
+/* set tx packet scheduler descriptor tc arbitration mode */
+void hw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(struct aq_hw_s *aq_hw,
+						 u32 arb_mode);
+
+/* set tx packet scheduler descriptor tc max credit */
+void hw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(struct aq_hw_s *aq_hw,
+						   u32 max_credit,
+					    u32 tc);
+
+/* set tx packet scheduler descriptor tc weight */
+void hw_atl_tps_tx_pkt_shed_desc_tc_weight_set(struct aq_hw_s *aq_hw,
+					       u32 tx_pkt_shed_desc_tc_weight,
+					u32 tc);
+
+/* set tx packet scheduler descriptor vm arbitration mode */
+void hw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(struct aq_hw_s *aq_hw,
+						 u32 arb_mode);
+
+/* set tx packet scheduler tc data max credit */
+void hw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(struct aq_hw_s *aq_hw,
+						   u32 max_credit,
+					    u32 tc);
+
+/* set tx packet scheduler tc data weight */
+void hw_atl_tps_tx_pkt_shed_tc_data_weight_set(struct aq_hw_s *aq_hw,
+					       u32 tx_pkt_shed_tc_data_weight,
+					u32 tc);
+
+/* tx */
+
+/* set tx register reset disable */
+void hw_atl_tx_tx_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 tx_reg_res_dis);
+
+/* msm */
+
+/* get register access status */
+u32 hw_atl_msm_reg_access_status_get(struct aq_hw_s *aq_hw);
+
+/* set  register address for indirect address */
+void hw_atl_msm_reg_addr_for_indirect_addr_set(struct aq_hw_s *aq_hw,
+					       u32 reg_addr_for_indirect_addr);
+
+/* set register read strobe */
+void hw_atl_msm_reg_rd_strobe_set(struct aq_hw_s *aq_hw, u32 reg_rd_strobe);
+
+/* get  register read data */
+u32 hw_atl_msm_reg_rd_data_get(struct aq_hw_s *aq_hw);
+
+/* set  register write data */
+void hw_atl_msm_reg_wr_data_set(struct aq_hw_s *aq_hw, u32 reg_wr_data);
+
+/* set register write strobe */
+void hw_atl_msm_reg_wr_strobe_set(struct aq_hw_s *aq_hw, u32 reg_wr_strobe);
+
+/* pci */
+
+/* set pci register reset disable */
+void hw_atl_pci_pci_reg_res_dis_set(struct aq_hw_s *aq_hw, u32 pci_reg_res_dis);
+
+/* set uP Force Interrupt */
+void mcp_up_force_intr_set(struct aq_hw_s *aq_hw, u32 up_force_intr);
+
+
+#endif /* HW_ATL_LLH_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh_internal.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh_internal.h
new file mode 100644
index 00000000..3448e10
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_llh_internal.h
@@ -0,0 +1,2403 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_llh_internal.h: Preprocessor definitions
+ * for Atlantic registers.
+ */
+
+#ifndef HW_ATL_LLH_INTERNAL_H
+#define HW_ATL_LLH_INTERNAL_H
+
+/* global microprocessor semaphore  definitions
+ * base address: 0x000003a0
+ * parameter: semaphore {s} | stride size 0x4 | range [0, 15]
+ */
+#define HW_ATL_GLB_CPU_SEM_ADR(semaphore)  (0x000003a0u + (semaphore) * 0x4)
+/* register address for bitfield rx dma good octet counter lsw [1f:0] */
+#define HW_ATL_STATS_RX_DMA_GOOD_OCTET_COUNTERLSW 0x00006808
+/* register address for bitfield rx dma good packet counter lsw [1f:0] */
+#define HW_ATL_STATS_RX_DMA_GOOD_PKT_COUNTERLSW 0x00006800
+/* register address for bitfield tx dma good octet counter lsw [1f:0] */
+#define HW_ATL_STATS_TX_DMA_GOOD_OCTET_COUNTERLSW 0x00008808
+/* register address for bitfield tx dma good packet counter lsw [1f:0] */
+#define HW_ATL_STATS_TX_DMA_GOOD_PKT_COUNTERLSW 0x00008800
+
+/* register address for bitfield rx dma good octet counter msw [3f:20] */
+#define HW_ATL_STATS_RX_DMA_GOOD_OCTET_COUNTERMSW 0x0000680c
+/* register address for bitfield rx dma good packet counter msw [3f:20] */
+#define HW_ATL_STATS_RX_DMA_GOOD_PKT_COUNTERMSW 0x00006804
+/* register address for bitfield tx dma good octet counter msw [3f:20] */
+#define HW_ATL_STATS_TX_DMA_GOOD_OCTET_COUNTERMSW 0x0000880c
+/* register address for bitfield tx dma good packet counter msw [3f:20] */
+#define HW_ATL_STATS_TX_DMA_GOOD_PKT_COUNTERMSW 0x00008804
+
+/* preprocessor definitions for msm rx errors counter register */
+#define HW_ATL_MAC_MSM_RX_ERRS_CNT_ADR 0x00000120u
+
+/* preprocessor definitions for msm rx unicast frames counter register */
+#define HW_ATL_MAC_MSM_RX_UCST_FRM_CNT_ADR 0x000000e0u
+
+/* preprocessor definitions for msm rx multicast frames counter register */
+#define HW_ATL_MAC_MSM_RX_MCST_FRM_CNT_ADR 0x000000e8u
+
+/* preprocessor definitions for msm rx broadcast frames counter register */
+#define HW_ATL_MAC_MSM_RX_BCST_FRM_CNT_ADR 0x000000f0u
+
+/* preprocessor definitions for msm rx broadcast octets counter register 1 */
+#define HW_ATL_MAC_MSM_RX_BCST_OCTETS_COUNTER1_ADR 0x000001b0u
+
+/* preprocessor definitions for msm rx broadcast octets counter register 2 */
+#define HW_ATL_MAC_MSM_RX_BCST_OCTETS_COUNTER2_ADR 0x000001b4u
+
+/* preprocessor definitions for msm rx unicast octets counter register 0 */
+#define HW_ATL_MAC_MSM_RX_UCST_OCTETS_COUNTER0_ADR 0x000001b8u
+
+/* preprocessor definitions for rx dma statistics counter 7 */
+#define HW_ATL_RX_DMA_STAT_COUNTER7_ADR 0x00006818u
+
+/* preprocessor definitions for msm tx unicast frames counter register */
+#define HW_ATL_MAC_MSM_TX_UCST_FRM_CNT_ADR 0x00000108u
+
+/* preprocessor definitions for msm tx multicast frames counter register */
+#define HW_ATL_MAC_MSM_TX_MCST_FRM_CNT_ADR 0x00000110u
+
+/* preprocessor definitions for global mif identification */
+#define HW_ATL_GLB_MIF_ID_ADR 0x0000001cu
+
+/* register address for bitfield iamr_lsw[1f:0] */
+#define HW_ATL_ITR_IAMRLSW_ADR 0x00002090
+/* register address for bitfield rx dma drop packet counter [1f:0] */
+#define HW_ATL_RPB_RX_DMA_DROP_PKT_CNT_ADR 0x00006818
+
+/* register address for bitfield imcr_lsw[1f:0] */
+#define HW_ATL_ITR_IMCRLSW_ADR 0x00002070
+/* register address for bitfield imsr_lsw[1f:0] */
+#define HW_ATL_ITR_IMSRLSW_ADR 0x00002060
+/* register address for bitfield itr_reg_res_dsbl */
+#define HW_ATL_ITR_REG_RES_DSBL_ADR 0x00002300
+/* bitmask for bitfield itr_reg_res_dsbl */
+#define HW_ATL_ITR_REG_RES_DSBL_MSK 0x20000000
+/* lower bit position of bitfield itr_reg_res_dsbl */
+#define HW_ATL_ITR_REG_RES_DSBL_SHIFT 29
+/* register address for bitfield iscr_lsw[1f:0] */
+#define HW_ATL_ITR_ISCRLSW_ADR 0x00002050
+/* register address for bitfield isr_lsw[1f:0] */
+#define HW_ATL_ITR_ISRLSW_ADR 0x00002000
+/* register address for bitfield itr_reset */
+#define HW_ATL_ITR_RES_ADR 0x00002300
+/* bitmask for bitfield itr_reset */
+#define HW_ATL_ITR_RES_MSK 0x80000000
+/* lower bit position of bitfield itr_reset */
+#define HW_ATL_ITR_RES_SHIFT 31
+/* register address for bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_RDM_DCADCPUID_ADR(dca) (0x00006100 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_RDM_DCADCPUID_MSK 0x000000ff
+/* lower bit position of bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_RDM_DCADCPUID_SHIFT 0
+/* register address for bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_ADR 0x00006180
+
+/* rx dca_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca_en".
+ * port="pif_rdm_dca_en_i"
+ */
+
+/* register address for bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_ADR 0x00006180
+/* bitmask for bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_MSK 0x80000000
+/* inverted bitmask for bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_MSKN 0x7fffffff
+/* lower bit position of bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_SHIFT 31
+/* width of bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_WIDTH 1
+/* default value of bitfield dca_en */
+#define HW_ATL_RDM_DCA_EN_DEFAULT 0x1
+
+/* rx dca_mode[3:0] bitfield definitions
+ * preprocessor definitions for the bitfield "dca_mode[3:0]".
+ * port="pif_rdm_dca_mode_i[3:0]"
+ */
+
+/* register address for bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_ADR 0x00006180
+/* bitmask for bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_MSK 0x0000000f
+/* inverted bitmask for bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_MSKN 0xfffffff0
+/* lower bit position of bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_SHIFT 0
+/* width of bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_WIDTH 4
+/* default value of bitfield dca_mode[3:0] */
+#define HW_ATL_RDM_DCA_MODE_DEFAULT 0x0
+
+/* rx desc{d}_data_size[4:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_data_size[4:0]".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_desc0_data_size_i[4:0]"
+ */
+
+/* register address for bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_ADR(descriptor) \
+	(0x00005b18 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_MSK 0x0000001f
+/* inverted bitmask for bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_MSKN 0xffffffe0
+/* lower bit position of bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_SHIFT 0
+/* width of bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_WIDTH 5
+/* default value of bitfield desc{d}_data_size[4:0] */
+#define HW_ATL_RDM_DESCDDATA_SIZE_DEFAULT 0x0
+
+/* rx dca{d}_desc_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca{d}_desc_en".
+ * parameter: dca {d} | stride size 0x4 | range [0, 31]
+ * port="pif_rdm_dca_desc_en_i[0]"
+ */
+
+/* register address for bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_ADR(dca) (0x00006100 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_MSK 0x80000000
+/* inverted bitmask for bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_MSKN 0x7fffffff
+/* lower bit position of bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_SHIFT 31
+/* width of bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_WIDTH 1
+/* default value of bitfield dca{d}_desc_en */
+#define HW_ATL_RDM_DCADDESC_EN_DEFAULT 0x0
+
+/* rx desc{d}_en bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_en".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_desc_en_i[0]"
+ */
+
+/* register address for bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_ADR(descriptor) (0x00005b08 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_MSK 0x80000000
+/* inverted bitmask for bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_MSKN 0x7fffffff
+/* lower bit position of bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_SHIFT 31
+/* width of bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_WIDTH 1
+/* default value of bitfield desc{d}_en */
+#define HW_ATL_RDM_DESCDEN_DEFAULT 0x0
+
+/* rx desc{d}_hdr_size[4:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_hdr_size[4:0]".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_desc0_hdr_size_i[4:0]"
+ */
+
+/* register address for bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_ADR(descriptor) \
+	(0x00005b18 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_MSK 0x00001f00
+/* inverted bitmask for bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_MSKN 0xffffe0ff
+/* lower bit position of bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_SHIFT 8
+/* width of bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_WIDTH 5
+/* default value of bitfield desc{d}_hdr_size[4:0] */
+#define HW_ATL_RDM_DESCDHDR_SIZE_DEFAULT 0x0
+
+/* rx desc{d}_hdr_split bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_hdr_split".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_desc_hdr_split_i[0]"
+ */
+
+/* register address for bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_ADR(descriptor) \
+	(0x00005b08 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_MSK 0x10000000
+/* inverted bitmask for bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_MSKN 0xefffffff
+/* lower bit position of bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_SHIFT 28
+/* width of bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_WIDTH 1
+/* default value of bitfield desc{d}_hdr_split */
+#define HW_ATL_RDM_DESCDHDR_SPLIT_DEFAULT 0x0
+
+/* rx desc{d}_hd[c:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_hd[c:0]".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="rdm_pif_desc0_hd_o[12:0]"
+ */
+
+/* register address for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_RDM_DESCDHD_ADR(descriptor) (0x00005b0c + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_RDM_DESCDHD_MSK 0x00001fff
+/* inverted bitmask for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_RDM_DESCDHD_MSKN 0xffffe000
+/* lower bit position of bitfield desc{d}_hd[c:0] */
+#define HW_ATL_RDM_DESCDHD_SHIFT 0
+/* width of bitfield desc{d}_hd[c:0] */
+#define HW_ATL_RDM_DESCDHD_WIDTH 13
+
+/* rx desc{d}_len[9:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_len[9:0]".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_desc0_len_i[9:0]"
+ */
+
+/* register address for bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_ADR(descriptor) (0x00005b08 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_MSK 0x00001ff8
+/* inverted bitmask for bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_MSKN 0xffffe007
+/* lower bit position of bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_SHIFT 3
+/* width of bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_WIDTH 10
+/* default value of bitfield desc{d}_len[9:0] */
+#define HW_ATL_RDM_DESCDLEN_DEFAULT 0x0
+
+/* rx desc{d}_reset bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_reset".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rdm_q_pf_res_i[0]"
+ */
+
+/* register address for bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_ADR(descriptor) (0x00005b08 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_MSK 0x02000000
+/* inverted bitmask for bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_MSKN 0xfdffffff
+/* lower bit position of bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_SHIFT 25
+/* width of bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_WIDTH 1
+/* default value of bitfield desc{d}_reset */
+#define HW_ATL_RDM_DESCDRESET_DEFAULT 0x0
+
+/* rx int_desc_wrb_en bitfield definitions
+ * preprocessor definitions for the bitfield "int_desc_wrb_en".
+ * port="pif_rdm_int_desc_wrb_en_i"
+ */
+
+/* register address for bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_ADR 0x00005a30
+/* bitmask for bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_MSK 0x00000004
+/* inverted bitmask for bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_MSKN 0xfffffffb
+/* lower bit position of bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_SHIFT 2
+/* width of bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_WIDTH 1
+/* default value of bitfield int_desc_wrb_en */
+#define HW_ATL_RDM_INT_DESC_WRB_EN_DEFAULT 0x0
+
+/* rx dca{d}_hdr_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca{d}_hdr_en".
+ * parameter: dca {d} | stride size 0x4 | range [0, 31]
+ * port="pif_rdm_dca_hdr_en_i[0]"
+ */
+
+/* register address for bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_ADR(dca) (0x00006100 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_MSK 0x40000000
+/* inverted bitmask for bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_MSKN 0xbfffffff
+/* lower bit position of bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_SHIFT 30
+/* width of bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_WIDTH 1
+/* default value of bitfield dca{d}_hdr_en */
+#define HW_ATL_RDM_DCADHDR_EN_DEFAULT 0x0
+
+/* rx dca{d}_pay_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca{d}_pay_en".
+ * parameter: dca {d} | stride size 0x4 | range [0, 31]
+ * port="pif_rdm_dca_pay_en_i[0]"
+ */
+
+/* register address for bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_ADR(dca) (0x00006100 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_MSK 0x20000000
+/* inverted bitmask for bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_MSKN 0xdfffffff
+/* lower bit position of bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_SHIFT 29
+/* width of bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_WIDTH 1
+/* default value of bitfield dca{d}_pay_en */
+#define HW_ATL_RDM_DCADPAY_EN_DEFAULT 0x0
+
+/* RX rdm_int_rim_en Bitfield Definitions
+ * Preprocessor definitions for the bitfield "rdm_int_rim_en".
+ * PORT="pif_rdm_int_rim_en_i"
+ */
+
+/* Register address for bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_ADR 0x00005A30
+/* Bitmask for bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_MSK 0x00000008
+/* Inverted bitmask for bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_MSKN 0xFFFFFFF7
+/* Lower bit position of bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_SHIFT 3
+/* Width of bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_WIDTH 1
+/* Default value of bitfield rdm_int_rim_en */
+#define HW_ATL_RDM_INT_RIM_EN_DEFAULT 0x0
+
+/* general interrupt mapping register definitions
+ * preprocessor definitions for general interrupt mapping register
+ * base address: 0x00002180
+ * parameter: regidx {f} | stride size 0x4 | range [0, 3]
+ */
+#define HW_ATL_GEN_INTR_MAP_ADR(regidx) (0x00002180u + (regidx) * 0x4)
+
+/* general interrupt status register definitions
+ * preprocessor definitions for general interrupt status register
+ * address: 0x000021A0
+ */
+
+#define HW_ATL_GEN_INTR_STAT_ADR 0x000021A4U
+
+/* interrupt global control register  definitions
+ * preprocessor definitions for interrupt global control register
+ * address: 0x00002300
+ */
+#define HW_ATL_INTR_GLB_CTL_ADR 0x00002300u
+
+/* interrupt throttle register definitions
+ * preprocessor definitions for interrupt throttle register
+ * base address: 0x00002800
+ * parameter: throttle {t} | stride size 0x4 | range [0, 31]
+ */
+#define HW_ATL_INTR_THR_ADR(throttle) (0x00002800u + (throttle) * 0x4)
+
+/* rx dma descriptor base address lsw definitions
+ * preprocessor definitions for rx dma descriptor base address lsw
+ * base address: 0x00005b00
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ */
+#define HW_ATL_RX_DMA_DESC_BASE_ADDRLSW_ADR(descriptor) \
+(0x00005b00u + (descriptor) * 0x20)
+
+/* rx dma descriptor base address msw definitions
+ * preprocessor definitions for rx dma descriptor base address msw
+ * base address: 0x00005b04
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ */
+#define HW_ATL_RX_DMA_DESC_BASE_ADDRMSW_ADR(descriptor) \
+(0x00005b04u + (descriptor) * 0x20)
+
+/* rx dma descriptor status register definitions
+ * preprocessor definitions for rx dma descriptor status register
+ * base address: 0x00005b14
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ */
+#define HW_ATL_RX_DMA_DESC_STAT_ADR(descriptor) \
+	(0x00005b14u + (descriptor) * 0x20)
+
+/* rx dma descriptor tail pointer register definitions
+ * preprocessor definitions for rx dma descriptor tail pointer register
+ * base address: 0x00005b10
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ */
+#define HW_ATL_RX_DMA_DESC_TAIL_PTR_ADR(descriptor) \
+	(0x00005b10u + (descriptor) * 0x20)
+
+/* rx interrupt moderation control register definitions
+ * Preprocessor definitions for RX Interrupt Moderation Control Register
+ * Base Address: 0x00005A40
+ * Parameter: RIM {R} | stride size 0x4 | range [0, 31]
+ */
+#define HW_ATL_RX_INTR_MODERATION_CTL_ADR(rim) (0x00005A40u + (rim) * 0x4)
+
+/* rx filter multicast filter mask register definitions
+ * preprocessor definitions for rx filter multicast filter mask register
+ * address: 0x00005270
+ */
+#define HW_ATL_RX_FLR_MCST_FLR_MSK_ADR 0x00005270u
+
+/* rx filter multicast filter register definitions
+ * preprocessor definitions for rx filter multicast filter register
+ * base address: 0x00005250
+ * parameter: filter {f} | stride size 0x4 | range [0, 7]
+ */
+#define HW_ATL_RX_FLR_MCST_FLR_ADR(filter) (0x00005250u + (filter) * 0x4)
+
+/* RX Filter RSS Control Register 1 Definitions
+ * Preprocessor definitions for RX Filter RSS Control Register 1
+ * Address: 0x000054C0
+ */
+#define HW_ATL_RX_FLR_RSS_CONTROL1_ADR 0x000054C0u
+
+/* RX Filter Control Register 2 Definitions
+ * Preprocessor definitions for RX Filter Control Register 2
+ * Address: 0x00005104
+ */
+#define HW_ATL_RX_FLR_CONTROL2_ADR 0x00005104u
+
+/* tx tx dma debug control [1f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "tx dma debug control [1f:0]".
+ * port="pif_tdm_debug_cntl_i[31:0]"
+ */
+
+/* register address for bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_ADR 0x00008920
+/* bitmask for bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_MSK 0xffffffff
+/* inverted bitmask for bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_MSKN 0x00000000
+/* lower bit position of bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_SHIFT 0
+/* width of bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_WIDTH 32
+/* default value of bitfield tx dma debug control [1f:0] */
+#define HW_ATL_TDM_TX_DMA_DEBUG_CTL_DEFAULT 0x0
+
+/* tx dma descriptor base address lsw definitions
+ * preprocessor definitions for tx dma descriptor base address lsw
+ * base address: 0x00007c00
+ * parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ */
+#define HW_ATL_TX_DMA_DESC_BASE_ADDRLSW_ADR(descriptor) \
+	(0x00007c00u + (descriptor) * 0x40)
+
+/* tx dma descriptor tail pointer register definitions
+ * preprocessor definitions for tx dma descriptor tail pointer register
+ * base address: 0x00007c10
+ *  parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ */
+#define HW_ATL_TX_DMA_DESC_TAIL_PTR_ADR(descriptor) \
+	(0x00007c10u + (descriptor) * 0x40)
+
+/* rx dma_sys_loopback bitfield definitions
+ * preprocessor definitions for the bitfield "dma_sys_loopback".
+ * port="pif_rpb_dma_sys_lbk_i"
+ */
+
+/* register address for bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_ADR 0x00005000
+/* bitmask for bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_MSK 0x00000040
+/* inverted bitmask for bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_MSKN 0xffffffbf
+/* lower bit position of bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_SHIFT 6
+/* width of bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_WIDTH 1
+/* default value of bitfield dma_sys_loopback */
+#define HW_ATL_RPB_DMA_SYS_LBK_DEFAULT 0x0
+
+/* rx rx_tc_mode bitfield definitions
+ * preprocessor definitions for the bitfield "rx_tc_mode".
+ * port="pif_rpb_rx_tc_mode_i,pif_rpf_rx_tc_mode_i"
+ */
+
+/* register address for bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_ADR 0x00005700
+/* bitmask for bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_MSK 0x00000100
+/* inverted bitmask for bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_MSKN 0xfffffeff
+/* lower bit position of bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_SHIFT 8
+/* width of bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_WIDTH 1
+/* default value of bitfield rx_tc_mode */
+#define HW_ATL_RPB_RPF_RX_TC_MODE_DEFAULT 0x0
+
+/* rx rx_buf_en bitfield definitions
+ * preprocessor definitions for the bitfield "rx_buf_en".
+ * port="pif_rpb_rx_buf_en_i"
+ */
+
+/* register address for bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_ADR 0x00005700
+/* bitmask for bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_MSK 0x00000001
+/* inverted bitmask for bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_MSKN 0xfffffffe
+/* lower bit position of bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_SHIFT 0
+/* width of bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_WIDTH 1
+/* default value of bitfield rx_buf_en */
+#define HW_ATL_RPB_RX_BUF_EN_DEFAULT 0x0
+
+/* rx rx{b}_hi_thresh[d:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rx{b}_hi_thresh[d:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_rpb_rx0_hi_thresh_i[13:0]"
+ */
+
+/* register address for bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_ADR(buffer) (0x00005714 + (buffer) * 0x10)
+/* bitmask for bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_MSK 0x3fff0000
+/* inverted bitmask for bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_MSKN 0xc000ffff
+/* lower bit position of bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_SHIFT 16
+/* width of bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_WIDTH 14
+/* default value of bitfield rx{b}_hi_thresh[d:0] */
+#define HW_ATL_RPB_RXBHI_THRESH_DEFAULT 0x0
+
+/* rx rx{b}_lo_thresh[d:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rx{b}_lo_thresh[d:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_rpb_rx0_lo_thresh_i[13:0]"
+ */
+
+/* register address for bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_ADR(buffer) (0x00005714 + (buffer) * 0x10)
+/* bitmask for bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_MSK 0x00003fff
+/* inverted bitmask for bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_MSKN 0xffffc000
+/* lower bit position of bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_SHIFT 0
+/* width of bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_WIDTH 14
+/* default value of bitfield rx{b}_lo_thresh[d:0] */
+#define HW_ATL_RPB_RXBLO_THRESH_DEFAULT 0x0
+
+/* rx rx_fc_mode[1:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rx_fc_mode[1:0]".
+ * port="pif_rpb_rx_fc_mode_i[1:0]"
+ */
+
+/* register address for bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_ADR 0x00005700
+/* bitmask for bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_MSK 0x00000030
+/* inverted bitmask for bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_MSKN 0xffffffcf
+/* lower bit position of bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_SHIFT 4
+/* width of bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_WIDTH 2
+/* default value of bitfield rx_fc_mode[1:0] */
+#define HW_ATL_RPB_RX_FC_MODE_DEFAULT 0x0
+
+/* rx rx{b}_buf_size[8:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rx{b}_buf_size[8:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_rpb_rx0_buf_size_i[8:0]"
+ */
+
+/* register address for bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_ADR(buffer) (0x00005710 + (buffer) * 0x10)
+/* bitmask for bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_MSK 0x000001ff
+/* inverted bitmask for bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_MSKN 0xfffffe00
+/* lower bit position of bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_SHIFT 0
+/* width of bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_WIDTH 9
+/* default value of bitfield rx{b}_buf_size[8:0] */
+#define HW_ATL_RPB_RXBBUF_SIZE_DEFAULT 0x0
+
+/* rx rx{b}_xoff_en bitfield definitions
+ * preprocessor definitions for the bitfield "rx{b}_xoff_en".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_rpb_rx_xoff_en_i[0]"
+ */
+
+/* register address for bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_ADR(buffer) (0x00005714 + (buffer) * 0x10)
+/* bitmask for bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_MSK 0x80000000
+/* inverted bitmask for bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_MSKN 0x7fffffff
+/* lower bit position of bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_SHIFT 31
+/* width of bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_WIDTH 1
+/* default value of bitfield rx{b}_xoff_en */
+#define HW_ATL_RPB_RXBXOFF_EN_DEFAULT 0x0
+
+/* rx l2_bc_thresh[f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "l2_bc_thresh[f:0]".
+ * port="pif_rpf_l2_bc_thresh_i[15:0]"
+ */
+
+/* register address for bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_ADR 0x00005100
+/* bitmask for bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_MSK 0xffff0000
+/* inverted bitmask for bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_MSKN 0x0000ffff
+/* lower bit position of bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_SHIFT 16
+/* width of bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_WIDTH 16
+/* default value of bitfield l2_bc_thresh[f:0] */
+#define HW_ATL_RPFL2BC_THRESH_DEFAULT 0x0
+
+/* rx l2_bc_en bitfield definitions
+ * preprocessor definitions for the bitfield "l2_bc_en".
+ * port="pif_rpf_l2_bc_en_i"
+ */
+
+/* register address for bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_ADR 0x00005100
+/* bitmask for bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_MSK 0x00000001
+/* inverted bitmask for bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_MSKN 0xfffffffe
+/* lower bit position of bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_SHIFT 0
+/* width of bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_WIDTH 1
+/* default value of bitfield l2_bc_en */
+#define HW_ATL_RPFL2BC_EN_DEFAULT 0x0
+
+/* rx l2_bc_act[2:0] bitfield definitions
+ * preprocessor definitions for the bitfield "l2_bc_act[2:0]".
+ * port="pif_rpf_l2_bc_act_i[2:0]"
+ */
+
+/* register address for bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_ADR 0x00005100
+/* bitmask for bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_MSK 0x00007000
+/* inverted bitmask for bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_MSKN 0xffff8fff
+/* lower bit position of bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_SHIFT 12
+/* width of bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_WIDTH 3
+/* default value of bitfield l2_bc_act[2:0] */
+#define HW_ATL_RPFL2BC_ACT_DEFAULT 0x0
+
+/* rx l2_mc_en{f} bitfield definitions
+ * preprocessor definitions for the bitfield "l2_mc_en{f}".
+ * parameter: filter {f} | stride size 0x4 | range [0, 7]
+ * port="pif_rpf_l2_mc_en_i[0]"
+ */
+
+/* register address for bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_ADR(filter) (0x00005250 + (filter) * 0x4)
+/* bitmask for bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_MSK 0x80000000
+/* inverted bitmask for bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_MSKN 0x7fffffff
+/* lower bit position of bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_SHIFT 31
+/* width of bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_WIDTH 1
+/* default value of bitfield l2_mc_en{f} */
+#define HW_ATL_RPFL2MC_ENF_DEFAULT 0x0
+
+/* rx l2_promis_mode bitfield definitions
+ * preprocessor definitions for the bitfield "l2_promis_mode".
+ * port="pif_rpf_l2_promis_mode_i"
+ */
+
+/* register address for bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_ADR 0x00005100
+/* bitmask for bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_MSK 0x00000008
+/* inverted bitmask for bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_MSKN 0xfffffff7
+/* lower bit position of bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_SHIFT 3
+/* width of bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_WIDTH 1
+/* default value of bitfield l2_promis_mode */
+#define HW_ATL_RPFL2PROMIS_MODE_DEFAULT 0x0
+
+/* rx l2_uc_act{f}[2:0] bitfield definitions
+ * preprocessor definitions for the bitfield "l2_uc_act{f}[2:0]".
+ * parameter: filter {f} | stride size 0x8 | range [0, 37]
+ * port="pif_rpf_l2_uc_act0_i[2:0]"
+ */
+
+/* register address for bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_ADR(filter) (0x00005114 + (filter) * 0x8)
+/* bitmask for bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_MSK 0x00070000
+/* inverted bitmask for bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_MSKN 0xfff8ffff
+/* lower bit position of bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_SHIFT 16
+/* width of bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_WIDTH 3
+/* default value of bitfield l2_uc_act{f}[2:0] */
+#define HW_ATL_RPFL2UC_ACTF_DEFAULT 0x0
+
+/* rx l2_uc_en{f} bitfield definitions
+ * preprocessor definitions for the bitfield "l2_uc_en{f}".
+ * parameter: filter {f} | stride size 0x8 | range [0, 37]
+ * port="pif_rpf_l2_uc_en_i[0]"
+ */
+
+/* register address for bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_ADR(filter) (0x00005114 + (filter) * 0x8)
+/* bitmask for bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_MSK 0x80000000
+/* inverted bitmask for bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_MSKN 0x7fffffff
+/* lower bit position of bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_SHIFT 31
+/* width of bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_WIDTH 1
+/* default value of bitfield l2_uc_en{f} */
+#define HW_ATL_RPFL2UC_ENF_DEFAULT 0x0
+
+/* register address for bitfield l2_uc_da{f}_lsw[1f:0] */
+#define HW_ATL_RPFL2UC_DAFLSW_ADR(filter) (0x00005110 + (filter) * 0x8)
+/* register address for bitfield l2_uc_da{f}_msw[f:0] */
+#define HW_ATL_RPFL2UC_DAFMSW_ADR(filter) (0x00005114 + (filter) * 0x8)
+/* bitmask for bitfield l2_uc_da{f}_msw[f:0] */
+#define HW_ATL_RPFL2UC_DAFMSW_MSK 0x0000ffff
+/* lower bit position of bitfield l2_uc_da{f}_msw[f:0] */
+#define HW_ATL_RPFL2UC_DAFMSW_SHIFT 0
+
+/* rx l2_mc_accept_all bitfield definitions
+ * Preprocessor definitions for the bitfield "l2_mc_accept_all".
+ * PORT="pif_rpf_l2_mc_all_accept_i"
+ */
+
+/* Register address for bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_ADR 0x00005270
+/* Bitmask for bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_MSK 0x00004000
+/* Inverted bitmask for bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_MSKN 0xFFFFBFFF
+/* Lower bit position of bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_SHIFT 14
+/* Width of bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_WIDTH 1
+/* Default value of bitfield l2_mc_accept_all */
+#define HW_ATL_RPFL2MC_ACCEPT_ALL_DEFAULT 0x0
+
+/* width of bitfield rx_tc_up{t}[2:0] */
+#define HW_ATL_RPF_RPB_RX_TC_UPT_WIDTH 3
+/* default value of bitfield rx_tc_up{t}[2:0] */
+#define HW_ATL_RPF_RPB_RX_TC_UPT_DEFAULT 0x0
+
+/* rx rss_key_addr[4:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rss_key_addr[4:0]".
+ * port="pif_rpf_rss_key_addr_i[4:0]"
+ */
+
+/* register address for bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_ADR 0x000054d0
+/* bitmask for bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_MSK 0x0000001f
+/* inverted bitmask for bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_MSKN 0xffffffe0
+/* lower bit position of bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_SHIFT 0
+/* width of bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_WIDTH 5
+/* default value of bitfield rss_key_addr[4:0] */
+#define HW_ATL_RPF_RSS_KEY_ADDR_DEFAULT 0x0
+
+/* rx rss_key_wr_data[1f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rss_key_wr_data[1f:0]".
+ * port="pif_rpf_rss_key_wr_data_i[31:0]"
+ */
+
+/* register address for bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_ADR 0x000054d4
+/* bitmask for bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_MSK 0xffffffff
+/* inverted bitmask for bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_MSKN 0x00000000
+/* lower bit position of bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_SHIFT 0
+/* width of bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_WIDTH 32
+/* default value of bitfield rss_key_wr_data[1f:0] */
+#define HW_ATL_RPF_RSS_KEY_WR_DATA_DEFAULT 0x0
+
+/* rx rss_key_wr_en_i bitfield definitions
+ * preprocessor definitions for the bitfield "rss_key_wr_en_i".
+ * port="pif_rpf_rss_key_wr_en_i"
+ */
+
+/* register address for bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_ADR 0x000054d0
+/* bitmask for bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_MSK 0x00000020
+/* inverted bitmask for bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_MSKN 0xffffffdf
+/* lower bit position of bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_SHIFT 5
+/* width of bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_WIDTH 1
+/* default value of bitfield rss_key_wr_en_i */
+#define HW_ATL_RPF_RSS_KEY_WR_ENI_DEFAULT 0x0
+
+/* rx rss_redir_addr[3:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rss_redir_addr[3:0]".
+ * port="pif_rpf_rss_redir_addr_i[3:0]"
+ */
+
+/* register address for bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_ADR 0x000054e0
+/* bitmask for bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_MSK 0x0000000f
+/* inverted bitmask for bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_MSKN 0xfffffff0
+/* lower bit position of bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_SHIFT 0
+/* width of bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_WIDTH 4
+/* default value of bitfield rss_redir_addr[3:0] */
+#define HW_ATL_RPF_RSS_REDIR_ADDR_DEFAULT 0x0
+
+/* rx rss_redir_wr_data[f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "rss_redir_wr_data[f:0]".
+ * port="pif_rpf_rss_redir_wr_data_i[15:0]"
+ */
+
+/* register address for bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_ADR 0x000054e4
+/* bitmask for bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_MSK 0x0000ffff
+/* inverted bitmask for bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_MSKN 0xffff0000
+/* lower bit position of bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_SHIFT 0
+/* width of bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_WIDTH 16
+/* default value of bitfield rss_redir_wr_data[f:0] */
+#define HW_ATL_RPF_RSS_REDIR_WR_DATA_DEFAULT 0x0
+
+/* rx rss_redir_wr_en_i bitfield definitions
+ * preprocessor definitions for the bitfield "rss_redir_wr_en_i".
+ * port="pif_rpf_rss_redir_wr_en_i"
+ */
+
+/* register address for bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_ADR 0x000054e0
+/* bitmask for bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_MSK 0x00000010
+/* inverted bitmask for bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_MSKN 0xffffffef
+/* lower bit position of bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_SHIFT 4
+/* width of bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_WIDTH 1
+/* default value of bitfield rss_redir_wr_en_i */
+#define HW_ATL_RPF_RSS_REDIR_WR_ENI_DEFAULT 0x0
+
+/* rx tpo_rpf_sys_loopback bitfield definitions
+ * preprocessor definitions for the bitfield "tpo_rpf_sys_loopback".
+ * port="pif_rpf_tpo_pkt_sys_lbk_i"
+ */
+
+/* register address for bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_ADR 0x00005000
+/* bitmask for bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_MSK 0x00000100
+/* inverted bitmask for bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_MSKN 0xfffffeff
+/* lower bit position of bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_SHIFT 8
+/* width of bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_WIDTH 1
+/* default value of bitfield tpo_rpf_sys_loopback */
+#define HW_ATL_RPF_TPO_RPF_SYS_LBK_DEFAULT 0x0
+
+/* rx vl_inner_tpid[f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "vl_inner_tpid[f:0]".
+ * port="pif_rpf_vl_inner_tpid_i[15:0]"
+ */
+
+/* register address for bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_ADR 0x00005284
+/* bitmask for bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_MSK 0x0000ffff
+/* inverted bitmask for bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_MSKN 0xffff0000
+/* lower bit position of bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_SHIFT 0
+/* width of bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_WIDTH 16
+/* default value of bitfield vl_inner_tpid[f:0] */
+#define HW_ATL_RPF_VL_INNER_TPID_DEFAULT 0x8100
+
+/* rx vl_outer_tpid[f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "vl_outer_tpid[f:0]".
+ * port="pif_rpf_vl_outer_tpid_i[15:0]"
+ */
+
+/* register address for bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_ADR 0x00005284
+/* bitmask for bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_MSK 0xffff0000
+/* inverted bitmask for bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_MSKN 0x0000ffff
+/* lower bit position of bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_SHIFT 16
+/* width of bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_WIDTH 16
+/* default value of bitfield vl_outer_tpid[f:0] */
+#define HW_ATL_RPF_VL_OUTER_TPID_DEFAULT 0x88a8
+
+/* rx vl_promis_mode bitfield definitions
+ * preprocessor definitions for the bitfield "vl_promis_mode".
+ * port="pif_rpf_vl_promis_mode_i"
+ */
+
+/* register address for bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_ADR 0x00005280
+/* bitmask for bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_MSK 0x00000002
+/* inverted bitmask for bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_MSKN 0xfffffffd
+/* lower bit position of bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_SHIFT 1
+/* width of bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_WIDTH 1
+/* default value of bitfield vl_promis_mode */
+#define HW_ATL_RPF_VL_PROMIS_MODE_DEFAULT 0x0
+
+/* RX vl_accept_untagged_mode Bitfield Definitions
+ * Preprocessor definitions for the bitfield "vl_accept_untagged_mode".
+ * PORT="pif_rpf_vl_accept_untagged_i"
+ */
+
+/* Register address for bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_ADR 0x00005280
+/* Bitmask for bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_MSK 0x00000004
+/* Inverted bitmask for bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_MSKN 0xFFFFFFFB
+/* Lower bit position of bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_SHIFT 2
+/* Width of bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_WIDTH 1
+/* Default value of bitfield vl_accept_untagged_mode */
+#define HW_ATL_RPF_VL_ACCEPT_UNTAGGED_MODE_DEFAULT 0x0
+
+/* rX vl_untagged_act[2:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "vl_untagged_act[2:0]".
+ * PORT="pif_rpf_vl_untagged_act_i[2:0]"
+ */
+
+/* Register address for bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_ADR 0x00005280
+/* Bitmask for bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_MSK 0x00000038
+/* Inverted bitmask for bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_MSKN 0xFFFFFFC7
+/* Lower bit position of bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_SHIFT 3
+/* Width of bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_WIDTH 3
+/* Default value of bitfield vl_untagged_act[2:0] */
+#define HW_ATL_RPF_VL_UNTAGGED_ACT_DEFAULT 0x0
+
+/* RX vl_en{F} Bitfield Definitions
+ * Preprocessor definitions for the bitfield "vl_en{F}".
+ * Parameter: filter {F} | stride size 0x4 | range [0, 15]
+ * PORT="pif_rpf_vl_en_i[0]"
+ */
+
+/* Register address for bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_ADR(filter) (0x00005290 + (filter) * 0x4)
+/* Bitmask for bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_MSK 0x80000000
+/* Inverted bitmask for bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_MSKN 0x7FFFFFFF
+/* Lower bit position of bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_SHIFT 31
+/* Width of bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_WIDTH 1
+/* Default value of bitfield vl_en{F} */
+#define HW_ATL_RPF_VL_EN_F_DEFAULT 0x0
+
+/* RX vl_act{F}[2:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "vl_act{F}[2:0]".
+ * Parameter: filter {F} | stride size 0x4 | range [0, 15]
+ * PORT="pif_rpf_vl_act0_i[2:0]"
+ */
+
+/* Register address for bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_ADR(filter) (0x00005290 + (filter) * 0x4)
+/* Bitmask for bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_MSK 0x00070000
+/* Inverted bitmask for bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_MSKN 0xFFF8FFFF
+/* Lower bit position of bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_SHIFT 16
+/* Width of bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_WIDTH 3
+/* Default value of bitfield vl_act{F}[2:0] */
+#define HW_ATL_RPF_VL_ACT_F_DEFAULT 0x0
+
+/* RX vl_id{F}[B:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "vl_id{F}[B:0]".
+ * Parameter: filter {F} | stride size 0x4 | range [0, 15]
+ * PORT="pif_rpf_vl_id0_i[11:0]"
+ */
+
+/* Register address for bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_ADR(filter) (0x00005290 + (filter) * 0x4)
+/* Bitmask for bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_MSK 0x00000FFF
+/* Inverted bitmask for bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_MSKN 0xFFFFF000
+/* Lower bit position of bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_SHIFT 0
+/* Width of bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_WIDTH 12
+/* Default value of bitfield vl_id{F}[B:0] */
+#define HW_ATL_RPF_VL_ID_F_DEFAULT 0x0
+
+/* RX et_en{F} Bitfield Definitions
+ * Preprocessor definitions for the bitfield "et_en{F}".
+ * Parameter: filter {F} | stride size 0x4 | range [0, 15]
+ * PORT="pif_rpf_et_en_i[0]"
+ */
+
+/* Register address for bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* Bitmask for bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_MSK 0x80000000
+/* Inverted bitmask for bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_MSKN 0x7FFFFFFF
+/* Lower bit position of bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_SHIFT 31
+/* Width of bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_WIDTH 1
+/* Default value of bitfield et_en{F} */
+#define HW_ATL_RPF_ET_EN_F_DEFAULT 0x0
+
+/* rx et_en{f} bitfield definitions
+ * preprocessor definitions for the bitfield "et_en{f}".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_en_i[0]"
+ */
+
+/* register address for bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_MSK 0x80000000
+/* inverted bitmask for bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_MSKN 0x7fffffff
+/* lower bit position of bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_SHIFT 31
+/* width of bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_WIDTH 1
+/* default value of bitfield et_en{f} */
+#define HW_ATL_RPF_ET_ENF_DEFAULT 0x0
+
+/* rx et_up{f}_en bitfield definitions
+ * preprocessor definitions for the bitfield "et_up{f}_en".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_up_en_i[0]"
+ */
+
+/* register address for bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_MSK 0x40000000
+/* inverted bitmask for bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_MSKN 0xbfffffff
+/* lower bit position of bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_SHIFT 30
+/* width of bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_WIDTH 1
+/* default value of bitfield et_up{f}_en */
+#define HW_ATL_RPF_ET_UPFEN_DEFAULT 0x0
+
+/* rx et_rxq{f}_en bitfield definitions
+ * preprocessor definitions for the bitfield "et_rxq{f}_en".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_rxq_en_i[0]"
+ */
+
+/* register address for bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_MSK 0x20000000
+/* inverted bitmask for bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_MSKN 0xdfffffff
+/* lower bit position of bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_SHIFT 29
+/* width of bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_WIDTH 1
+/* default value of bitfield et_rxq{f}_en */
+#define HW_ATL_RPF_ET_RXQFEN_DEFAULT 0x0
+
+/* rx et_up{f}[2:0] bitfield definitions
+ * preprocessor definitions for the bitfield "et_up{f}[2:0]".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_up0_i[2:0]"
+ */
+
+/* register address for bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_MSK 0x1c000000
+/* inverted bitmask for bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_MSKN 0xe3ffffff
+/* lower bit position of bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_SHIFT 26
+/* width of bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_WIDTH 3
+/* default value of bitfield et_up{f}[2:0] */
+#define HW_ATL_RPF_ET_UPF_DEFAULT 0x0
+
+/* rx et_rxq{f}[4:0] bitfield definitions
+ * preprocessor definitions for the bitfield "et_rxq{f}[4:0]".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_rxq0_i[4:0]"
+ */
+
+/* register address for bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_MSK 0x01f00000
+/* inverted bitmask for bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_MSKN 0xfe0fffff
+/* lower bit position of bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_SHIFT 20
+/* width of bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_WIDTH 5
+/* default value of bitfield et_rxq{f}[4:0] */
+#define HW_ATL_RPF_ET_RXQF_DEFAULT 0x0
+
+/* rx et_mng_rxq{f} bitfield definitions
+ * preprocessor definitions for the bitfield "et_mng_rxq{f}".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_mng_rxq_i[0]"
+ */
+
+/* register address for bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_MSK 0x00080000
+/* inverted bitmask for bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_MSKN 0xfff7ffff
+/* lower bit position of bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_SHIFT 19
+/* width of bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_WIDTH 1
+/* default value of bitfield et_mng_rxq{f} */
+#define HW_ATL_RPF_ET_MNG_RXQF_DEFAULT 0x0
+
+/* rx et_act{f}[2:0] bitfield definitions
+ * preprocessor definitions for the bitfield "et_act{f}[2:0]".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_act0_i[2:0]"
+ */
+
+/* register address for bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_MSK 0x00070000
+/* inverted bitmask for bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_MSKN 0xfff8ffff
+/* lower bit position of bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_SHIFT 16
+/* width of bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_WIDTH 3
+/* default value of bitfield et_act{f}[2:0] */
+#define HW_ATL_RPF_ET_ACTF_DEFAULT 0x0
+
+/* rx et_val{f}[f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "et_val{f}[f:0]".
+ * parameter: filter {f} | stride size 0x4 | range [0, 15]
+ * port="pif_rpf_et_val0_i[15:0]"
+ */
+
+/* register address for bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_ADR(filter) (0x00005300 + (filter) * 0x4)
+/* bitmask for bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_MSK 0x0000ffff
+/* inverted bitmask for bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_MSKN 0xffff0000
+/* lower bit position of bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_SHIFT 0
+/* width of bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_WIDTH 16
+/* default value of bitfield et_val{f}[f:0] */
+#define HW_ATL_RPF_ET_VALF_DEFAULT 0x0
+
+/* rx ipv4_chk_en bitfield definitions
+ * preprocessor definitions for the bitfield "ipv4_chk_en".
+ * port="pif_rpo_ipv4_chk_en_i"
+ */
+
+/* register address for bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_ADR 0x00005580
+/* bitmask for bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_MSK 0x00000002
+/* inverted bitmask for bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_MSKN 0xfffffffd
+/* lower bit position of bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_SHIFT 1
+/* width of bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_WIDTH 1
+/* default value of bitfield ipv4_chk_en */
+#define HW_ATL_RPO_IPV4CHK_EN_DEFAULT 0x0
+
+/* rx desc{d}_vl_strip bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_vl_strip".
+ * parameter: descriptor {d} | stride size 0x20 | range [0, 31]
+ * port="pif_rpo_desc_vl_strip_i[0]"
+ */
+
+/* register address for bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_ADR(descriptor) \
+	(0x00005b08 + (descriptor) * 0x20)
+/* bitmask for bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_MSK 0x20000000
+/* inverted bitmask for bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_MSKN 0xdfffffff
+/* lower bit position of bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_SHIFT 29
+/* width of bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_WIDTH 1
+/* default value of bitfield desc{d}_vl_strip */
+#define HW_ATL_RPO_DESCDVL_STRIP_DEFAULT 0x0
+
+/* rx l4_chk_en bitfield definitions
+ * preprocessor definitions for the bitfield "l4_chk_en".
+ * port="pif_rpo_l4_chk_en_i"
+ */
+
+/* register address for bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_ADR 0x00005580
+/* bitmask for bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_MSK 0x00000001
+/* inverted bitmask for bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_MSKN 0xfffffffe
+/* lower bit position of bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_SHIFT 0
+/* width of bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_WIDTH 1
+/* default value of bitfield l4_chk_en */
+#define HW_ATL_RPOL4CHK_EN_DEFAULT 0x0
+
+/* rx reg_res_dsbl bitfield definitions
+ * preprocessor definitions for the bitfield "reg_res_dsbl".
+ * port="pif_rx_reg_res_dsbl_i"
+ */
+
+/* register address for bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_ADR 0x00005000
+/* bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_MSK 0x20000000
+/* inverted bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_MSKN 0xdfffffff
+/* lower bit position of bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_SHIFT 29
+/* width of bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_WIDTH 1
+/* default value of bitfield reg_res_dsbl */
+#define HW_ATL_RX_REG_RES_DSBL_DEFAULT 0x1
+
+/* tx dca{d}_cpuid[7:0] bitfield definitions
+ * preprocessor definitions for the bitfield "dca{d}_cpuid[7:0]".
+ * parameter: dca {d} | stride size 0x4 | range [0, 31]
+ * port="pif_tdm_dca0_cpuid_i[7:0]"
+ */
+
+/* register address for bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_ADR(dca) (0x00008400 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_MSK 0x000000ff
+/* inverted bitmask for bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_MSKN 0xffffff00
+/* lower bit position of bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_SHIFT 0
+/* width of bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_WIDTH 8
+/* default value of bitfield dca{d}_cpuid[7:0] */
+#define HW_ATL_TDM_DCADCPUID_DEFAULT 0x0
+
+/* tx lso_en[1f:0] bitfield definitions
+ * preprocessor definitions for the bitfield "lso_en[1f:0]".
+ * port="pif_tdm_lso_en_i[31:0]"
+ */
+
+/* register address for bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_ADR 0x00007810
+/* bitmask for bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_MSK 0xffffffff
+/* inverted bitmask for bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_MSKN 0x00000000
+/* lower bit position of bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_SHIFT 0
+/* width of bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_WIDTH 32
+/* default value of bitfield lso_en[1f:0] */
+#define HW_ATL_TDM_LSO_EN_DEFAULT 0x0
+
+/* tx dca_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca_en".
+ * port="pif_tdm_dca_en_i"
+ */
+
+/* register address for bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_ADR 0x00008480
+/* bitmask for bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_MSK 0x80000000
+/* inverted bitmask for bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_MSKN 0x7fffffff
+/* lower bit position of bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_SHIFT 31
+/* width of bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_WIDTH 1
+/* default value of bitfield dca_en */
+#define HW_ATL_TDM_DCA_EN_DEFAULT 0x1
+
+/* tx dca_mode[3:0] bitfield definitions
+ * preprocessor definitions for the bitfield "dca_mode[3:0]".
+ * port="pif_tdm_dca_mode_i[3:0]"
+ */
+
+/* register address for bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_ADR 0x00008480
+/* bitmask for bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_MSK 0x0000000f
+/* inverted bitmask for bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_MSKN 0xfffffff0
+/* lower bit position of bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_SHIFT 0
+/* width of bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_WIDTH 4
+/* default value of bitfield dca_mode[3:0] */
+#define HW_ATL_TDM_DCA_MODE_DEFAULT 0x0
+
+/* tx dca{d}_desc_en bitfield definitions
+ * preprocessor definitions for the bitfield "dca{d}_desc_en".
+ * parameter: dca {d} | stride size 0x4 | range [0, 31]
+ * port="pif_tdm_dca_desc_en_i[0]"
+ */
+
+/* register address for bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_ADR(dca) (0x00008400 + (dca) * 0x4)
+/* bitmask for bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_MSK 0x80000000
+/* inverted bitmask for bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_MSKN 0x7fffffff
+/* lower bit position of bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_SHIFT 31
+/* width of bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_WIDTH 1
+/* default value of bitfield dca{d}_desc_en */
+#define HW_ATL_TDM_DCADDESC_EN_DEFAULT 0x0
+
+/* tx desc{d}_en bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_en".
+ * parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ * port="pif_tdm_desc_en_i[0]"
+ */
+
+/* register address for bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_ADR(descriptor) (0x00007c08 + (descriptor) * 0x40)
+/* bitmask for bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_MSK 0x80000000
+/* inverted bitmask for bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_MSKN 0x7fffffff
+/* lower bit position of bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_SHIFT 31
+/* width of bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_WIDTH 1
+/* default value of bitfield desc{d}_en */
+#define HW_ATL_TDM_DESCDEN_DEFAULT 0x0
+
+/* tx desc{d}_hd[c:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_hd[c:0]".
+ * parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ * port="tdm_pif_desc0_hd_o[12:0]"
+ */
+
+/* register address for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_TDM_DESCDHD_ADR(descriptor) (0x00007c0c + (descriptor) * 0x40)
+/* bitmask for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_TDM_DESCDHD_MSK 0x00001fff
+/* inverted bitmask for bitfield desc{d}_hd[c:0] */
+#define HW_ATL_TDM_DESCDHD_MSKN 0xffffe000
+/* lower bit position of bitfield desc{d}_hd[c:0] */
+#define HW_ATL_TDM_DESCDHD_SHIFT 0
+/* width of bitfield desc{d}_hd[c:0] */
+#define HW_ATL_TDM_DESCDHD_WIDTH 13
+
+/* tx desc{d}_len[9:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_len[9:0]".
+ * parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ * port="pif_tdm_desc0_len_i[9:0]"
+ */
+
+/* register address for bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_ADR(descriptor) (0x00007c08 + (descriptor) * 0x40)
+/* bitmask for bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_MSK 0x00001ff8
+/* inverted bitmask for bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_MSKN 0xffffe007
+/* lower bit position of bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_SHIFT 3
+/* width of bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_WIDTH 10
+/* default value of bitfield desc{d}_len[9:0] */
+#define HW_ATL_TDM_DESCDLEN_DEFAULT 0x0
+
+/* tx int_desc_wrb_en bitfield definitions
+ * preprocessor definitions for the bitfield "int_desc_wrb_en".
+ * port="pif_tdm_int_desc_wrb_en_i"
+ */
+
+/* register address for bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_ADR 0x00007b40
+/* bitmask for bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_MSK 0x00000002
+/* inverted bitmask for bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_MSKN 0xfffffffd
+/* lower bit position of bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_SHIFT 1
+/* width of bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_WIDTH 1
+/* default value of bitfield int_desc_wrb_en */
+#define HW_ATL_TDM_INT_DESC_WRB_EN_DEFAULT 0x0
+
+/* tx desc{d}_wrb_thresh[6:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc{d}_wrb_thresh[6:0]".
+ * parameter: descriptor {d} | stride size 0x40 | range [0, 31]
+ * port="pif_tdm_desc0_wrb_thresh_i[6:0]"
+ */
+
+/* register address for bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_ADR(descriptor) \
+	(0x00007c18 + (descriptor) * 0x40)
+/* bitmask for bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_MSK 0x00007f00
+/* inverted bitmask for bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_MSKN 0xffff80ff
+/* lower bit position of bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_SHIFT 8
+/* width of bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_WIDTH 7
+/* default value of bitfield desc{d}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESCDWRB_THRESH_DEFAULT 0x0
+
+/* tx lso_tcp_flag_first[b:0] bitfield definitions
+ * preprocessor definitions for the bitfield "lso_tcp_flag_first[b:0]".
+ * port="pif_thm_lso_tcp_flag_first_i[11:0]"
+ */
+
+/* register address for bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_ADR 0x00007820
+/* bitmask for bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_MSK 0x00000fff
+/* inverted bitmask for bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_MSKN 0xfffff000
+/* lower bit position of bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_SHIFT 0
+/* width of bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_WIDTH 12
+/* default value of bitfield lso_tcp_flag_first[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_FIRST_DEFAULT 0x0
+
+/* tx lso_tcp_flag_last[b:0] bitfield definitions
+ * preprocessor definitions for the bitfield "lso_tcp_flag_last[b:0]".
+ * port="pif_thm_lso_tcp_flag_last_i[11:0]"
+ */
+
+/* register address for bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_ADR 0x00007824
+/* bitmask for bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_MSK 0x00000fff
+/* inverted bitmask for bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_MSKN 0xfffff000
+/* lower bit position of bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_SHIFT 0
+/* width of bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_WIDTH 12
+/* default value of bitfield lso_tcp_flag_last[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_LAST_DEFAULT 0x0
+
+/* tx lso_tcp_flag_mid[b:0] bitfield definitions
+ * preprocessor definitions for the bitfield "lso_tcp_flag_mid[b:0]".
+ * port="pif_thm_lso_tcp_flag_mid_i[11:0]"
+ */
+
+/* Register address for bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_ADR 0x00005598
+/* Bitmask for bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_MSK 0xFFFFFFFF
+/* Inverted bitmask for bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_MSKN 0x00000000
+/* Lower bit position of bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_SHIFT 0
+/* Width of bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_WIDTH 32
+/* Default value of bitfield lro_rsc_max[1F:0] */
+#define HW_ATL_RPO_LRO_RSC_MAX_DEFAULT 0x0
+
+/* RX lro_en[1F:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_en[1F:0]".
+ * PORT="pif_rpo_lro_en_i[31:0]"
+ */
+
+/* Register address for bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_ADR 0x00005590
+/* Bitmask for bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_MSK 0xFFFFFFFF
+/* Inverted bitmask for bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_MSKN 0x00000000
+/* Lower bit position of bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_SHIFT 0
+/* Width of bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_WIDTH 32
+/* Default value of bitfield lro_en[1F:0] */
+#define HW_ATL_RPO_LRO_EN_DEFAULT 0x0
+
+/* RX lro_ptopt_en Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_ptopt_en".
+ * PORT="pif_rpo_lro_ptopt_en_i"
+ */
+
+/* Register address for bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_ADR 0x00005594
+/* Bitmask for bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_MSK 0x00008000
+/* Inverted bitmask for bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_MSKN 0xFFFF7FFF
+/* Lower bit position of bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_SHIFT 15
+/* Width of bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_WIDTH 1
+/* Default value of bitfield lro_ptopt_en */
+#define HW_ATL_RPO_LRO_PTOPT_EN_DEFALT 0x1
+
+/* RX lro_q_ses_lmt Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_q_ses_lmt".
+ * PORT="pif_rpo_lro_q_ses_lmt_i[1:0]"
+ */
+
+/* Register address for bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_ADR 0x00005594
+/* Bitmask for bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_MSK 0x00003000
+/* Inverted bitmask for bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_MSKN 0xFFFFCFFF
+/* Lower bit position of bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_SHIFT 12
+/* Width of bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_WIDTH 2
+/* Default value of bitfield lro_q_ses_lmt */
+#define HW_ATL_RPO_LRO_QSES_LMT_DEFAULT 0x1
+
+/* RX lro_tot_dsc_lmt[1:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_tot_dsc_lmt[1:0]".
+ * PORT="pif_rpo_lro_tot_dsc_lmt_i[1:0]"
+ */
+
+/* Register address for bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_ADR 0x00005594
+/* Bitmask for bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_MSK 0x00000060
+/* Inverted bitmask for bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_MSKN 0xFFFFFF9F
+/* Lower bit position of bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_SHIFT 5
+/* Width of bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_WIDTH 2
+/* Default value of bitfield lro_tot_dsc_lmt[1:0] */
+#define HW_ATL_RPO_LRO_TOT_DSC_LMT_DEFALT 0x1
+
+/* RX lro_pkt_min[4:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_pkt_min[4:0]".
+ * PORT="pif_rpo_lro_pkt_min_i[4:0]"
+ */
+
+/* Register address for bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_ADR 0x00005594
+/* Bitmask for bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_MSK 0x0000001F
+/* Inverted bitmask for bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_MSKN 0xFFFFFFE0
+/* Lower bit position of bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_SHIFT 0
+/* Width of bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_WIDTH 5
+/* Default value of bitfield lro_pkt_min[4:0] */
+#define HW_ATL_RPO_LRO_PKT_MIN_DEFAULT 0x8
+
+/* Width of bitfield lro{L}_des_max[1:0] */
+#define HW_ATL_RPO_LRO_LDES_MAX_WIDTH 2
+/* Default value of bitfield lro{L}_des_max[1:0] */
+#define HW_ATL_RPO_LRO_LDES_MAX_DEFAULT 0x0
+
+/* RX lro_tb_div[11:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_tb_div[11:0]".
+ * PORT="pif_rpo_lro_tb_div_i[11:0]"
+ */
+
+/* Register address for bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_ADR 0x00005620
+/* Bitmask for bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_MSK 0xFFF00000
+/* Inverted bitmask for bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_MSKN 0x000FFFFF
+/* Lower bit position of bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_SHIFT 20
+/* Width of bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_WIDTH 12
+/* Default value of bitfield lro_tb_div[11:0] */
+#define HW_ATL_RPO_LRO_TB_DIV_DEFAULT 0xC35
+
+/* RX lro_ina_ival[9:0] Bitfield Definitions
+ *   Preprocessor definitions for the bitfield "lro_ina_ival[9:0]".
+ *   PORT="pif_rpo_lro_ina_ival_i[9:0]"
+ */
+
+/* Register address for bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_ADR 0x00005620
+/* Bitmask for bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_MSK 0x000FFC00
+/* Inverted bitmask for bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_MSKN 0xFFF003FF
+/* Lower bit position of bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_SHIFT 10
+/* Width of bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_WIDTH 10
+/* Default value of bitfield lro_ina_ival[9:0] */
+#define HW_ATL_RPO_LRO_INA_IVAL_DEFAULT 0xA
+
+/* RX lro_max_ival[9:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lro_max_ival[9:0]".
+ * PORT="pif_rpo_lro_max_ival_i[9:0]"
+ */
+
+/* Register address for bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_ADR 0x00005620
+/* Bitmask for bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_MSK 0x000003FF
+/* Inverted bitmask for bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_MSKN 0xFFFFFC00
+/* Lower bit position of bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_SHIFT 0
+/* Width of bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_WIDTH 10
+/* Default value of bitfield lro_max_ival[9:0] */
+#define HW_ATL_RPO_LRO_MAX_IVAL_DEFAULT 0x19
+
+/* TX dca{D}_cpuid[7:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "dca{D}_cpuid[7:0]".
+ * Parameter: DCA {D} | stride size 0x4 | range [0, 31]
+ * PORT="pif_tdm_dca0_cpuid_i[7:0]"
+ */
+
+/* Register address for bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_ADR(dca) (0x00008400 + (dca) * 0x4)
+/* Bitmask for bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_MSK 0x000000FF
+/* Inverted bitmask for bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_MSKN 0xFFFFFF00
+/* Lower bit position of bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_SHIFT 0
+/* Width of bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_WIDTH 8
+/* Default value of bitfield dca{D}_cpuid[7:0] */
+#define HW_ATL_TDM_DCA_DCPUID_DEFAULT 0x0
+
+/* TX dca{D}_desc_en Bitfield Definitions
+ * Preprocessor definitions for the bitfield "dca{D}_desc_en".
+ * Parameter: DCA {D} | stride size 0x4 | range [0, 31]
+ * PORT="pif_tdm_dca_desc_en_i[0]"
+ */
+
+/* Register address for bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_ADR(dca) (0x00008400 + (dca) * 0x4)
+/* Bitmask for bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_MSK 0x80000000
+/* Inverted bitmask for bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_MSKN 0x7FFFFFFF
+/* Lower bit position of bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_SHIFT 31
+/* Width of bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_WIDTH 1
+/* Default value of bitfield dca{D}_desc_en */
+#define HW_ATL_TDM_DCA_DDESC_EN_DEFAULT 0x0
+
+/* TX desc{D}_en Bitfield Definitions
+ * Preprocessor definitions for the bitfield "desc{D}_en".
+ * Parameter: descriptor {D} | stride size 0x40 | range [0, 31]
+ * PORT="pif_tdm_desc_en_i[0]"
+ */
+
+/* Register address for bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_ADR(descriptor) (0x00007C08 + (descriptor) * 0x40)
+/* Bitmask for bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_MSK 0x80000000
+/* Inverted bitmask for bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_MSKN 0x7FFFFFFF
+/* Lower bit position of bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_SHIFT 31
+/* Width of bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_WIDTH 1
+/* Default value of bitfield desc{D}_en */
+#define HW_ATL_TDM_DESC_DEN_DEFAULT 0x0
+
+/* TX desc{D}_hd[C:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "desc{D}_hd[C:0]".
+ * Parameter: descriptor {D} | stride size 0x40 | range [0, 31]
+ * PORT="tdm_pif_desc0_hd_o[12:0]"
+ */
+
+/* Register address for bitfield desc{D}_hd[C:0] */
+#define HW_ATL_TDM_DESC_DHD_ADR(descriptor) (0x00007C0C + (descriptor) * 0x40)
+/* Bitmask for bitfield desc{D}_hd[C:0] */
+#define HW_ATL_TDM_DESC_DHD_MSK 0x00001FFF
+/* Inverted bitmask for bitfield desc{D}_hd[C:0] */
+#define HW_ATL_TDM_DESC_DHD_MSKN 0xFFFFE000
+/* Lower bit position of bitfield desc{D}_hd[C:0] */
+#define HW_ATL_TDM_DESC_DHD_SHIFT 0
+/* Width of bitfield desc{D}_hd[C:0] */
+#define HW_ATL_TDM_DESC_DHD_WIDTH 13
+
+/* TX desc{D}_len[9:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "desc{D}_len[9:0]".
+ * Parameter: descriptor {D} | stride size 0x40 | range [0, 31]
+ * PORT="pif_tdm_desc0_len_i[9:0]"
+ */
+
+/* Register address for bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_ADR(descriptor) (0x00007C08 + (descriptor) * 0x40)
+/* Bitmask for bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_MSK 0x00001FF8
+/* Inverted bitmask for bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_MSKN 0xFFFFE007
+/* Lower bit position of bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_SHIFT 3
+/* Width of bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_WIDTH 10
+/* Default value of bitfield desc{D}_len[9:0] */
+#define HW_ATL_TDM_DESC_DLEN_DEFAULT 0x0
+
+/* TX desc{D}_wrb_thresh[6:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "desc{D}_wrb_thresh[6:0]".
+ * Parameter: descriptor {D} | stride size 0x40 | range [0, 31]
+ * PORT="pif_tdm_desc0_wrb_thresh_i[6:0]"
+ */
+
+/* Register address for bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_ADR(descriptor) \
+	(0x00007C18 + (descriptor) * 0x40)
+/* Bitmask for bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_MSK 0x00007F00
+/* Inverted bitmask for bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_MSKN 0xFFFF80FF
+/* Lower bit position of bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_SHIFT 8
+/* Width of bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_WIDTH 7
+/* Default value of bitfield desc{D}_wrb_thresh[6:0] */
+#define HW_ATL_TDM_DESC_DWRB_THRESH_DEFAULT 0x0
+
+/* TX tdm_int_mod_en Bitfield Definitions
+ * Preprocessor definitions for the bitfield "tdm_int_mod_en".
+ * PORT="pif_tdm_int_mod_en_i"
+ */
+
+/* Register address for bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_ADR 0x00007B40
+/* Bitmask for bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_MSK 0x00000010
+/* Inverted bitmask for bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_MSKN 0xFFFFFFEF
+/* Lower bit position of bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_SHIFT 4
+/* Width of bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_WIDTH 1
+/* Default value of bitfield tdm_int_mod_en */
+#define HW_ATL_TDM_INT_MOD_EN_DEFAULT 0x0
+
+/* TX lso_tcp_flag_mid[B:0] Bitfield Definitions
+ * Preprocessor definitions for the bitfield "lso_tcp_flag_mid[B:0]".
+ * PORT="pif_thm_lso_tcp_flag_mid_i[11:0]"
+ */
+/* register address for bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_ADR 0x00007820
+/* bitmask for bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_MSK 0x0fff0000
+/* inverted bitmask for bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_MSKN 0xf000ffff
+/* lower bit position of bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_SHIFT 16
+/* width of bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_WIDTH 12
+/* default value of bitfield lso_tcp_flag_mid[b:0] */
+#define HW_ATL_THM_LSO_TCP_FLAG_MID_DEFAULT 0x0
+
+/* tx tx_buf_en bitfield definitions
+ * preprocessor definitions for the bitfield "tx_buf_en".
+ * port="pif_tpb_tx_buf_en_i"
+ */
+
+/* register address for bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_ADR 0x00007900
+/* bitmask for bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_MSK 0x00000001
+/* inverted bitmask for bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_MSKN 0xfffffffe
+/* lower bit position of bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_SHIFT 0
+/* width of bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_WIDTH 1
+/* default value of bitfield tx_buf_en */
+#define HW_ATL_TPB_TX_BUF_EN_DEFAULT 0x0
+
+/* tx tx{b}_hi_thresh[c:0] bitfield definitions
+ * preprocessor definitions for the bitfield "tx{b}_hi_thresh[c:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_tpb_tx0_hi_thresh_i[12:0]"
+ */
+
+/* register address for bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_ADR(buffer) (0x00007914 + (buffer) * 0x10)
+/* bitmask for bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_MSK 0x1fff0000
+/* inverted bitmask for bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_MSKN 0xe000ffff
+/* lower bit position of bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_SHIFT 16
+/* width of bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_WIDTH 13
+/* default value of bitfield tx{b}_hi_thresh[c:0] */
+#define HW_ATL_TPB_TXBHI_THRESH_DEFAULT 0x0
+
+/* tx tx{b}_lo_thresh[c:0] bitfield definitions
+ * preprocessor definitions for the bitfield "tx{b}_lo_thresh[c:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_tpb_tx0_lo_thresh_i[12:0]"
+ */
+
+/* register address for bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_ADR(buffer) (0x00007914 + (buffer) * 0x10)
+/* bitmask for bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_MSK 0x00001fff
+/* inverted bitmask for bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_MSKN 0xffffe000
+/* lower bit position of bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_SHIFT 0
+/* width of bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_WIDTH 13
+/* default value of bitfield tx{b}_lo_thresh[c:0] */
+#define HW_ATL_TPB_TXBLO_THRESH_DEFAULT 0x0
+
+/* tx dma_sys_loopback bitfield definitions
+ * preprocessor definitions for the bitfield "dma_sys_loopback".
+ * port="pif_tpb_dma_sys_lbk_i"
+ */
+
+/* register address for bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_ADR 0x00007000
+/* bitmask for bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_MSK 0x00000040
+/* inverted bitmask for bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_MSKN 0xffffffbf
+/* lower bit position of bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_SHIFT 6
+/* width of bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_WIDTH 1
+/* default value of bitfield dma_sys_loopback */
+#define HW_ATL_TPB_DMA_SYS_LBK_DEFAULT 0x0
+
+/* tx tx{b}_buf_size[7:0] bitfield definitions
+ * preprocessor definitions for the bitfield "tx{b}_buf_size[7:0]".
+ * parameter: buffer {b} | stride size 0x10 | range [0, 7]
+ * port="pif_tpb_tx0_buf_size_i[7:0]"
+ */
+
+/* register address for bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_ADR(buffer) (0x00007910 + (buffer) * 0x10)
+/* bitmask for bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_MSK 0x000000ff
+/* inverted bitmask for bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_MSKN 0xffffff00
+/* lower bit position of bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_SHIFT 0
+/* width of bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_WIDTH 8
+/* default value of bitfield tx{b}_buf_size[7:0] */
+#define HW_ATL_TPB_TXBBUF_SIZE_DEFAULT 0x0
+
+/* tx tx_scp_ins_en bitfield definitions
+ * preprocessor definitions for the bitfield "tx_scp_ins_en".
+ * port="pif_tpb_scp_ins_en_i"
+ */
+
+/* register address for bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_ADR 0x00007900
+/* bitmask for bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_MSK 0x00000004
+/* inverted bitmask for bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_MSKN 0xfffffffb
+/* lower bit position of bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_SHIFT 2
+/* width of bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_WIDTH 1
+/* default value of bitfield tx_scp_ins_en */
+#define HW_ATL_TPB_TX_SCP_INS_EN_DEFAULT 0x0
+
+/* tx ipv4_chk_en bitfield definitions
+ * preprocessor definitions for the bitfield "ipv4_chk_en".
+ * port="pif_tpo_ipv4_chk_en_i"
+ */
+
+/* register address for bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_ADR 0x00007800
+/* bitmask for bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_MSK 0x00000002
+/* inverted bitmask for bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_MSKN 0xfffffffd
+/* lower bit position of bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_SHIFT 1
+/* width of bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_WIDTH 1
+/* default value of bitfield ipv4_chk_en */
+#define HW_ATL_TPO_IPV4CHK_EN_DEFAULT 0x0
+
+/* tx l4_chk_en bitfield definitions
+ * preprocessor definitions for the bitfield "l4_chk_en".
+ * port="pif_tpo_l4_chk_en_i"
+ */
+
+/* register address for bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_ADR 0x00007800
+/* bitmask for bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_MSK 0x00000001
+/* inverted bitmask for bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_MSKN 0xfffffffe
+/* lower bit position of bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_SHIFT 0
+/* width of bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_WIDTH 1
+/* default value of bitfield l4_chk_en */
+#define HW_ATL_TPOL4CHK_EN_DEFAULT 0x0
+
+/* tx pkt_sys_loopback bitfield definitions
+ * preprocessor definitions for the bitfield "pkt_sys_loopback".
+ * port="pif_tpo_pkt_sys_lbk_i"
+ */
+
+/* register address for bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_ADR 0x00007000
+/* bitmask for bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_MSK 0x00000080
+/* inverted bitmask for bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_MSKN 0xffffff7f
+/* lower bit position of bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_SHIFT 7
+/* width of bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_WIDTH 1
+/* default value of bitfield pkt_sys_loopback */
+#define HW_ATL_TPO_PKT_SYS_LBK_DEFAULT 0x0
+
+/* tx data_tc_arb_mode bitfield definitions
+ * preprocessor definitions for the bitfield "data_tc_arb_mode".
+ * port="pif_tps_data_tc_arb_mode_i"
+ */
+
+/* register address for bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_ADR 0x00007100
+/* bitmask for bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_MSK 0x00000001
+/* inverted bitmask for bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_MSKN 0xfffffffe
+/* lower bit position of bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_SHIFT 0
+/* width of bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_WIDTH 1
+/* default value of bitfield data_tc_arb_mode */
+#define HW_ATL_TPS_DATA_TC_ARB_MODE_DEFAULT 0x0
+
+/* tx desc_rate_ta_rst bitfield definitions
+ * preprocessor definitions for the bitfield "desc_rate_ta_rst".
+ * port="pif_tps_desc_rate_ta_rst_i"
+ */
+
+/* register address for bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_ADR 0x00007310
+/* bitmask for bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_MSK 0x80000000
+/* inverted bitmask for bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_MSKN 0x7fffffff
+/* lower bit position of bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_SHIFT 31
+/* width of bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_WIDTH 1
+/* default value of bitfield desc_rate_ta_rst */
+#define HW_ATL_TPS_DESC_RATE_TA_RST_DEFAULT 0x0
+
+/* tx desc_rate_limit[a:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc_rate_limit[a:0]".
+ * port="pif_tps_desc_rate_lim_i[10:0]"
+ */
+
+/* register address for bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_ADR 0x00007310
+/* bitmask for bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_MSK 0x000007ff
+/* inverted bitmask for bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_MSKN 0xfffff800
+/* lower bit position of bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_SHIFT 0
+/* width of bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_WIDTH 11
+/* default value of bitfield desc_rate_limit[a:0] */
+#define HW_ATL_TPS_DESC_RATE_LIM_DEFAULT 0x0
+
+/* tx desc_tc_arb_mode[1:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc_tc_arb_mode[1:0]".
+ * port="pif_tps_desc_tc_arb_mode_i[1:0]"
+ */
+
+/* register address for bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_ADR 0x00007200
+/* bitmask for bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_MSK 0x00000003
+/* inverted bitmask for bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_MSKN 0xfffffffc
+/* lower bit position of bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_SHIFT 0
+/* width of bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_WIDTH 2
+/* default value of bitfield desc_tc_arb_mode[1:0] */
+#define HW_ATL_TPS_DESC_TC_ARB_MODE_DEFAULT 0x0
+
+/* tx desc_tc{t}_credit_max[b:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc_tc{t}_credit_max[b:0]".
+ * parameter: tc {t} | stride size 0x4 | range [0, 7]
+ * port="pif_tps_desc_tc0_credit_max_i[11:0]"
+ */
+
+/* register address for bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_ADR(tc) (0x00007210 + (tc) * 0x4)
+/* bitmask for bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_MSK 0x0fff0000
+/* inverted bitmask for bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_MSKN 0xf000ffff
+/* lower bit position of bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_SHIFT 16
+/* width of bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_WIDTH 12
+/* default value of bitfield desc_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DESC_TCTCREDIT_MAX_DEFAULT 0x0
+
+/* tx desc_tc{t}_weight[8:0] bitfield definitions
+ * preprocessor definitions for the bitfield "desc_tc{t}_weight[8:0]".
+ * parameter: tc {t} | stride size 0x4 | range [0, 7]
+ * port="pif_tps_desc_tc0_weight_i[8:0]"
+ */
+
+/* register address for bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_ADR(tc) (0x00007210 + (tc) * 0x4)
+/* bitmask for bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_MSK 0x000001ff
+/* inverted bitmask for bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_MSKN 0xfffffe00
+/* lower bit position of bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_SHIFT 0
+/* width of bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_WIDTH 9
+/* default value of bitfield desc_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DESC_TCTWEIGHT_DEFAULT 0x0
+
+/* tx desc_vm_arb_mode bitfield definitions
+ * preprocessor definitions for the bitfield "desc_vm_arb_mode".
+ * port="pif_tps_desc_vm_arb_mode_i"
+ */
+
+/* register address for bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_ADR 0x00007300
+/* bitmask for bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_MSK 0x00000001
+/* inverted bitmask for bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_MSKN 0xfffffffe
+/* lower bit position of bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_SHIFT 0
+/* width of bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_WIDTH 1
+/* default value of bitfield desc_vm_arb_mode */
+#define HW_ATL_TPS_DESC_VM_ARB_MODE_DEFAULT 0x0
+
+/* tx data_tc{t}_credit_max[b:0] bitfield definitions
+ * preprocessor definitions for the bitfield "data_tc{t}_credit_max[b:0]".
+ * parameter: tc {t} | stride size 0x4 | range [0, 7]
+ * port="pif_tps_data_tc0_credit_max_i[11:0]"
+ */
+
+/* register address for bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_ADR(tc) (0x00007110 + (tc) * 0x4)
+/* bitmask for bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_MSK 0x0fff0000
+/* inverted bitmask for bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_MSKN 0xf000ffff
+/* lower bit position of bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_SHIFT 16
+/* width of bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_WIDTH 12
+/* default value of bitfield data_tc{t}_credit_max[b:0] */
+#define HW_ATL_TPS_DATA_TCTCREDIT_MAX_DEFAULT 0x0
+
+/* tx data_tc{t}_weight[8:0] bitfield definitions
+ * preprocessor definitions for the bitfield "data_tc{t}_weight[8:0]".
+ * parameter: tc {t} | stride size 0x4 | range [0, 7]
+ * port="pif_tps_data_tc0_weight_i[8:0]"
+ */
+
+/* register address for bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_ADR(tc) (0x00007110 + (tc) * 0x4)
+/* bitmask for bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_MSK 0x000001ff
+/* inverted bitmask for bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_MSKN 0xfffffe00
+/* lower bit position of bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_SHIFT 0
+/* width of bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_WIDTH 9
+/* default value of bitfield data_tc{t}_weight[8:0] */
+#define HW_ATL_TPS_DATA_TCTWEIGHT_DEFAULT 0x0
+
+/* tx reg_res_dsbl bitfield definitions
+ * preprocessor definitions for the bitfield "reg_res_dsbl".
+ * port="pif_tx_reg_res_dsbl_i"
+ */
+
+/* register address for bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_ADR 0x00007000
+/* bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_MSK 0x20000000
+/* inverted bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_MSKN 0xdfffffff
+/* lower bit position of bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_SHIFT 29
+/* width of bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_WIDTH 1
+/* default value of bitfield reg_res_dsbl */
+#define HW_ATL_TX_REG_RES_DSBL_DEFAULT 0x1
+
+/* mac_phy register access busy bitfield definitions
+ * preprocessor definitions for the bitfield "register access busy".
+ * port="msm_pif_reg_busy_o"
+ */
+
+/* register address for bitfield register access busy */
+#define HW_ATL_MSM_REG_ACCESS_BUSY_ADR 0x00004400
+/* bitmask for bitfield register access busy */
+#define HW_ATL_MSM_REG_ACCESS_BUSY_MSK 0x00001000
+/* inverted bitmask for bitfield register access busy */
+#define HW_ATL_MSM_REG_ACCESS_BUSY_MSKN 0xffffefff
+/* lower bit position of bitfield register access busy */
+#define HW_ATL_MSM_REG_ACCESS_BUSY_SHIFT 12
+/* width of bitfield register access busy */
+#define HW_ATL_MSM_REG_ACCESS_BUSY_WIDTH 1
+
+/* mac_phy msm register address[7:0] bitfield definitions
+ * preprocessor definitions for the bitfield "msm register address[7:0]".
+ * port="pif_msm_reg_addr_i[7:0]"
+ */
+
+/* register address for bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_ADR 0x00004400
+/* bitmask for bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_MSK 0x000000ff
+/* inverted bitmask for bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_MSKN 0xffffff00
+/* lower bit position of bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_SHIFT 0
+/* width of bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_WIDTH 8
+/* default value of bitfield msm register address[7:0] */
+#define HW_ATL_MSM_REG_ADDR_DEFAULT 0x0
+
+/* mac_phy register read strobe bitfield definitions
+ * preprocessor definitions for the bitfield "register read strobe".
+ * port="pif_msm_reg_rden_i"
+ */
+
+/* register address for bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_ADR 0x00004400
+/* bitmask for bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_MSK 0x00000200
+/* inverted bitmask for bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_MSKN 0xfffffdff
+/* lower bit position of bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_SHIFT 9
+/* width of bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_WIDTH 1
+/* default value of bitfield register read strobe */
+#define HW_ATL_MSM_REG_RD_STROBE_DEFAULT 0x0
+
+/* mac_phy msm register read data[31:0] bitfield definitions
+ * preprocessor definitions for the bitfield "msm register read data[31:0]".
+ * port="msm_pif_reg_rd_data_o[31:0]"
+ */
+
+/* register address for bitfield msm register read data[31:0] */
+#define HW_ATL_MSM_REG_RD_DATA_ADR 0x00004408
+/* bitmask for bitfield msm register read data[31:0] */
+#define HW_ATL_MSM_REG_RD_DATA_MSK 0xffffffff
+/* inverted bitmask for bitfield msm register read data[31:0] */
+#define HW_ATL_MSM_REG_RD_DATA_MSKN 0x00000000
+/* lower bit position of bitfield msm register read data[31:0] */
+#define HW_ATL_MSM_REG_RD_DATA_SHIFT 0
+/* width of bitfield msm register read data[31:0] */
+#define HW_ATL_MSM_REG_RD_DATA_WIDTH 32
+
+/* mac_phy msm register write data[31:0] bitfield definitions
+ * preprocessor definitions for the bitfield "msm register write data[31:0]".
+ * port="pif_msm_reg_wr_data_i[31:0]"
+ */
+
+/* register address for bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_ADR 0x00004404
+/* bitmask for bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_MSK 0xffffffff
+/* inverted bitmask for bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_MSKN 0x00000000
+/* lower bit position of bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_SHIFT 0
+/* width of bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_WIDTH 32
+/* default value of bitfield msm register write data[31:0] */
+#define HW_ATL_MSM_REG_WR_DATA_DEFAULT 0x0
+
+/* mac_phy register write strobe bitfield definitions
+ * preprocessor definitions for the bitfield "register write strobe".
+ * port="pif_msm_reg_wren_i"
+ */
+
+/* register address for bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_ADR 0x00004400
+/* bitmask for bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_MSK 0x00000100
+/* inverted bitmask for bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_MSKN 0xfffffeff
+/* lower bit position of bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_SHIFT 8
+/* width of bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_WIDTH 1
+/* default value of bitfield register write strobe */
+#define HW_ATL_MSM_REG_WR_STROBE_DEFAULT 0x0
+
+/* mif soft reset bitfield definitions
+ * preprocessor definitions for the bitfield "soft reset".
+ * port="pif_glb_res_i"
+ */
+
+/* register address for bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_ADR 0x00000000
+/* bitmask for bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_MSK 0x00008000
+/* inverted bitmask for bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_MSKN 0xffff7fff
+/* lower bit position of bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_SHIFT 15
+/* width of bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_WIDTH 1
+/* default value of bitfield soft reset */
+#define HW_ATL_GLB_SOFT_RES_DEFAULT 0x0
+
+/* mif register reset disable bitfield definitions
+ * preprocessor definitions for the bitfield "register reset disable".
+ * port="pif_glb_reg_res_dsbl_i"
+ */
+
+/* register address for bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_ADR 0x00000000
+/* bitmask for bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_MSK 0x00004000
+/* inverted bitmask for bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_MSKN 0xffffbfff
+/* lower bit position of bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_SHIFT 14
+/* width of bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_WIDTH 1
+/* default value of bitfield register reset disable */
+#define HW_ATL_GLB_REG_RES_DIS_DEFAULT 0x1
+
+/* tx dma debug control definitions */
+#define HW_ATL_TX_DMA_DEBUG_CTL_ADR 0x00008920u
+
+/* tx dma descriptor base address msw definitions */
+#define HW_ATL_TX_DMA_DESC_BASE_ADDRMSW_ADR(descriptor) \
+			(0x00007c04u + (descriptor) * 0x40)
+
+/* tx dma total request limit */
+#define HW_ATL_TX_DMA_TOTAL_REQ_LIMIT_ADR 0x00007b20u
+
+/* tx interrupt moderation control register definitions
+ * Preprocessor definitions for TX Interrupt Moderation Control Register
+ * Base Address: 0x00008980
+ * Parameter: queue {Q} | stride size 0x4 | range [0, 31]
+ */
+
+#define HW_ATL_TX_INTR_MODERATION_CTL_ADR(queue) (0x00008980u + (queue) * 0x4)
+
+/* pcie reg_res_dsbl bitfield definitions
+ * preprocessor definitions for the bitfield "reg_res_dsbl".
+ * port="pif_pci_reg_res_dsbl_i"
+ */
+
+/* register address for bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_ADR 0x00001000
+/* bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_MSK 0x20000000
+/* inverted bitmask for bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_MSKN 0xdfffffff
+/* lower bit position of bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_SHIFT 29
+/* width of bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_WIDTH 1
+/* default value of bitfield reg_res_dsbl */
+#define HW_ATL_PCI_REG_RES_DSBL_DEFAULT 0x1
+
+/* PCI core control register */
+#define HW_ATL_PCI_REG_CONTROL6_ADR 0x1014u
+
+/* global microprocessor scratch pad definitions */
+#define HW_ATL_GLB_CPU_SCRATCH_SCP_ADR(scratch_scp) \
+	(0x00000300u + (scratch_scp) * 0x4)
+
+/* register address for bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_adr 0x00000404
+/* bitmask for bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_msk 0x00000002
+/* inverted bitmask for bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_mskn 0xFFFFFFFD
+/* lower bit position of bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_shift 1
+/* width of bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_width 1
+/* default value of bitfield uP Force Interrupt */
+#define mcp_up_force_interrupt_default 0x0
+
+#endif /* HW_ATL_LLH_INTERNAL_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.c b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.c
new file mode 100644
index 00000000..dc84363
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.c
@@ -0,0 +1,922 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_utils.c: Definition of common functions for Atlantic hardware
+ * abstraction layer.
+ */
+
+#include "../aq_nic.h"
+#include "../aq_hw_utils.h"
+#include "hw_atl_utils.h"
+#include "hw_atl_llh.h"
+#include "hw_atl_llh_internal.h"
+
+#include <linux/random.h>
+
+#define HW_ATL_UCP_0X370_REG    0x0370U
+
+#define HW_ATL_MIF_CMD          0x0200U
+#define HW_ATL_MIF_ADDR         0x0208U
+#define HW_ATL_MIF_VAL          0x020CU
+
+#define HW_ATL_FW_SM_RAM        0x2U
+#define HW_ATL_MPI_FW_VERSION	0x18
+#define HW_ATL_MPI_CONTROL_ADR  0x0368U
+#define HW_ATL_MPI_STATE_ADR    0x036CU
+
+#define HW_ATL_MPI_STATE_MSK      0x00FFU
+#define HW_ATL_MPI_STATE_SHIFT    0U
+#define HW_ATL_MPI_SPEED_MSK      0x00FF0000U
+#define HW_ATL_MPI_SPEED_SHIFT    16U
+#define HW_ATL_MPI_DIRTY_WAKE_MSK 0x02000000U
+
+#define HW_ATL_MPI_DAISY_CHAIN_STATUS	0x704
+#define HW_ATL_MPI_BOOT_EXIT_CODE	0x388
+
+#define HW_ATL_MAC_PHY_CONTROL	0x4000
+#define HW_ATL_MAC_PHY_MPI_RESET_BIT 0x1D
+
+#define HW_ATL_FW_VER_1X 0x01050006U
+#define HW_ATL_FW_VER_2X 0x02000000U
+#define HW_ATL_FW_VER_3X 0x03000000U
+
+#define FORCE_FLASHLESS 0
+
+static int hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual);
+static int hw_atl_utils_mpi_set_state(struct aq_hw_s *self,
+				      enum hal_atl_utils_fw_state_e state);
+
+int hw_atl_utils_initfw(struct aq_hw_s *self, const struct aq_fw_ops **fw_ops)
+{
+	int err = 0;
+
+	err = hw_atl_utils_soft_reset(self);
+	if (err)
+		return err;
+
+	hw_atl_utils_hw_chip_features_init(self,
+					   &self->chip_features);
+
+	hw_atl_utils_get_fw_version(self, &self->fw_ver_actual);
+
+	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
+				   self->fw_ver_actual) == 0) {
+		*fw_ops = &aq_fw_1x_ops;
+	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X,
+					self->fw_ver_actual) == 0) {
+		*fw_ops = &aq_fw_2x_ops;
+	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X,
+					self->fw_ver_actual) == 0) {
+		*fw_ops = &aq_fw_2x_ops;
+	} else {
+		aq_pr_err("Bad FW version detected: %x\n",
+			  self->fw_ver_actual);
+		return -EOPNOTSUPP;
+	}
+	self->aq_fw_ops = *fw_ops;
+	err = self->aq_fw_ops->init(self);
+	return err;
+}
+
+static int hw_atl_utils_soft_reset_flb(struct aq_hw_s *self)
+{
+	u32 gsr, val;
+	int k = 0;
+
+	aq_hw_write_reg(self, 0x404, 0x40e1);
+	AQ_HW_SLEEP(50);
+
+	/* Cleanup SPI */
+	val = aq_hw_read_reg(self, 0x53C);
+	aq_hw_write_reg(self, 0x53C, val | 0x10);
+
+	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+
+	/* Kickstart MAC */
+	aq_hw_write_reg(self, 0x404, 0x80e0);
+	aq_hw_write_reg(self, 0x32a8, 0x0);
+	aq_hw_write_reg(self, 0x520, 0x1);
+
+	/* Reset SPI again because of possible interrupted SPI burst */
+	val = aq_hw_read_reg(self, 0x53C);
+	aq_hw_write_reg(self, 0x53C, val | 0x10);
+	AQ_HW_SLEEP(10);
+	/* Clear SPI reset state */
+	aq_hw_write_reg(self, 0x53C, val & ~0x10);
+
+	aq_hw_write_reg(self, 0x404, 0x180e0);
+
+	for (k = 0; k < 1000; k++) {
+		u32 flb_status = aq_hw_read_reg(self,
+						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+
+		flb_status = flb_status & 0x10;
+		if (flb_status)
+			break;
+		AQ_HW_SLEEP(10);
+	}
+	if (k == 1000) {
+		aq_pr_err("MAC kickstart failed\n");
+		return -EIO;
+	}
+
+	/* FW reset */
+	aq_hw_write_reg(self, 0x404, 0x80e0);
+	AQ_HW_SLEEP(50);
+	aq_hw_write_reg(self, 0x3a0, 0x1);
+
+	/* Kickstart PHY - skipped */
+
+	/* Global software reset*/
+	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+
+	for (k = 0; k < 1000; k++) {
+		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+
+		if (fw_state)
+			break;
+		AQ_HW_SLEEP(10);
+	}
+	if (k == 1000) {
+		aq_pr_err("FW kickstart failed\n");
+		return -EIO;
+	}
+	/* Old FW requires fixed delay after init */
+	AQ_HW_SLEEP(15);
+
+	return 0;
+}
+
+static int hw_atl_utils_soft_reset_rbl(struct aq_hw_s *self)
+{
+	u32 gsr, val, rbl_status;
+	int k;
+
+	aq_hw_write_reg(self, 0x404, 0x40e1);
+	aq_hw_write_reg(self, 0x3a0, 0x1);
+	aq_hw_write_reg(self, 0x32a8, 0x0);
+
+	/* Alter RBL status */
+	aq_hw_write_reg(self, 0x388, 0xDEAD);
+
+	/* Cleanup SPI */
+	val = aq_hw_read_reg(self, 0x53C);
+	aq_hw_write_reg(self, 0x53C, val | 0x10);
+
+	/* Global software reset*/
+	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR,
+			(gsr & 0xFFFFBFFF) | 0x8000);
+
+	if (FORCE_FLASHLESS)
+		aq_hw_write_reg(self, 0x534, 0x0);
+
+	aq_hw_write_reg(self, 0x404, 0x40e0);
+
+	/* Wait for RBL boot */
+	for (k = 0; k < 1000; k++) {
+		rbl_status = aq_hw_read_reg(self, 0x388) & 0xFFFF;
+		if (rbl_status && rbl_status != 0xDEAD)
+			break;
+		AQ_HW_SLEEP(10);
+	}
+	if (!rbl_status || rbl_status == 0xDEAD) {
+		aq_pr_err("RBL Restart failed");
+		return -EIO;
+	}
+
+	/* Restore NVR */
+	if (FORCE_FLASHLESS)
+		aq_hw_write_reg(self, 0x534, 0xA0);
+
+	if (rbl_status == 0xF1A7) {
+		aq_pr_err("No FW detected. Dynamic FW load not implemented\n");
+		return -ENOTSUPP;
+	}
+
+	for (k = 0; k < 1000; k++) {
+		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+
+		if (fw_state)
+			break;
+		AQ_HW_SLEEP(10);
+	}
+	if (k == 1000) {
+		aq_pr_err("FW kickstart failed\n");
+		return -EIO;
+	}
+	/* Old FW requires fixed delay after init */
+	AQ_HW_SLEEP(15);
+
+	return 0;
+}
+
+int hw_atl_utils_soft_reset(struct aq_hw_s *self)
+{
+	int k;
+	u32 boot_exit_code = 0;
+
+	for (k = 0; k < 1000; ++k) {
+		u32 flb_status = aq_hw_read_reg(self,
+						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+		boot_exit_code = aq_hw_read_reg(self,
+						HW_ATL_MPI_BOOT_EXIT_CODE);
+		if (flb_status != 0x06000000 || boot_exit_code != 0)
+			break;
+	}
+
+	if (k == 1000) {
+		aq_pr_err("Neither RBL nor FLB firmware started\n");
+		return -EOPNOTSUPP;
+	}
+
+	self->rbl_enabled = (boot_exit_code != 0);
+
+	/* FW 1.x may bootup in an invalid POWER state (WOL feature).
+	 * We should work around this by forcing its state back to DEINIT
+	 */
+	if (!hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
+				    aq_hw_read_reg(self,
+						   HW_ATL_MPI_FW_VERSION))) {
+		int err = 0;
+
+		hw_atl_utils_mpi_set_state(self, MPI_DEINIT);
+		AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_MPI_STATE_ADR) &
+			       HW_ATL_MPI_STATE_MSK) == MPI_DEINIT,
+			       10, 1000U);
+	}
+
+	if (self->rbl_enabled)
+		return hw_atl_utils_soft_reset_rbl(self);
+	else
+		return hw_atl_utils_soft_reset_flb(self);
+}
+
+int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
+				  u32 *p, u32 cnt)
+{
+	int err = 0;
+
+	AQ_HW_WAIT_FOR(hw_atl_reg_glb_cpu_sem_get(self,
+						  HW_ATL_FW_SM_RAM) == 1U,
+						  1U, 10000U);
+
+	if (err < 0) {
+		bool is_locked;
+
+		hw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);
+		is_locked = hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RAM);
+		if (!is_locked) {
+			err = -ETIME;
+			goto err_exit;
+		}
+	}
+
+	aq_hw_write_reg(self, HW_ATL_MIF_ADDR, a);
+
+	for (++cnt; --cnt && !err;) {
+		aq_hw_write_reg(self, HW_ATL_MIF_CMD, 0x00008000U);
+
+		if (IS_CHIP_FEATURE(REVISION_B1))
+			AQ_HW_WAIT_FOR(a != aq_hw_read_reg(self,
+							   HW_ATL_MIF_ADDR),
+				       1, 1000U);
+		else
+			AQ_HW_WAIT_FOR(!(0x100 & aq_hw_read_reg(self,
+							   HW_ATL_MIF_CMD)),
+				       1, 1000U);
+
+		*(p++) = aq_hw_read_reg(self, HW_ATL_MIF_VAL);
+		a += 4;
+	}
+
+	hw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_utils_fw_upload_dwords(struct aq_hw_s *self, u32 a, u32 *p,
+					 u32 cnt)
+{
+	int err = 0;
+	bool is_locked;
+
+	is_locked = hw_atl_reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RAM);
+	if (!is_locked) {
+		err = -ETIME;
+		goto err_exit;
+	}
+	if (IS_CHIP_FEATURE(REVISION_B1)) {
+		u32 offset = 0;
+
+		for (; offset < cnt; ++offset) {
+			aq_hw_write_reg(self, 0x328, p[offset]);
+			aq_hw_write_reg(self, 0x32C,
+				(0x80000000 | (0xFFFF & (offset * 4))));
+			mcp_up_force_intr_set(self, 1);
+			/* 1000 times by 10us = 10ms */
+			AQ_HW_WAIT_FOR((aq_hw_read_reg(self,
+					0x32C) & 0xF0000000) != 0x80000000,
+					10, 1000);
+		}
+	} else {
+		u32 offset = 0;
+
+		aq_hw_write_reg(self, 0x208, a);
+
+		for (; offset < cnt; ++offset) {
+			aq_hw_write_reg(self, 0x20C, p[offset]);
+			aq_hw_write_reg(self, 0x200, 0xC000);
+
+			AQ_HW_WAIT_FOR((aq_hw_read_reg(self, 0x200U)
+					& 0x100) == 0, 10, 1000);
+		}
+	}
+
+	hw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual)
+{
+	int err = 0;
+	const u32 dw_major_mask = 0xff000000U;
+	const u32 dw_minor_mask = 0x00ffffffU;
+
+	err = (dw_major_mask & (ver_expected ^ ver_actual)) ? -EOPNOTSUPP : 0;
+	if (err < 0)
+		goto err_exit;
+	err = ((dw_minor_mask & ver_expected) > (dw_minor_mask & ver_actual)) ?
+		-EOPNOTSUPP : 0;
+err_exit:
+	return err;
+}
+
+static int hw_atl_utils_init_ucp(struct aq_hw_s *self,
+				 const struct aq_hw_caps_s *aq_hw_caps)
+{
+	int err = 0;
+
+	if (!aq_hw_read_reg(self, 0x370U)) {
+		unsigned int rnd = 0U;
+		unsigned int ucp_0x370 = 0U;
+
+		get_random_bytes(&rnd, sizeof(unsigned int));
+
+		ucp_0x370 = 0x02020202U | (0xFEFEFEFEU & rnd);
+		aq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);
+	}
+
+	hw_atl_reg_glb_cpu_scratch_scp_set(self, 0x00000000U, 25U);
+
+	/* check 10 times by 1ms */
+	AQ_HW_WAIT_FOR(0U != (self->mbox_addr =
+		       aq_hw_read_reg(self, 0x360U)), 1000U, 10U);
+	AQ_HW_WAIT_FOR(0U != (self->rpc_addr =
+		       aq_hw_read_reg(self, 0x334U)), 1000U, 100U);
+
+	return err;
+}
+
+#define HW_ATL_RPC_CONTROL_ADR 0x0338U
+#define HW_ATL_RPC_STATE_ADR   0x033CU
+
+struct aq_hw_atl_utils_fw_rpc_tid_s {
+	union {
+		u32 val;
+		struct {
+			u16 tid;
+			u16 len;
+		};
+	};
+};
+
+#define hw_atl_utils_fw_rpc_init(_H_) hw_atl_utils_fw_rpc_wait(_H_, NULL)
+
+int hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size)
+{
+	int err = 0;
+	struct aq_hw_atl_utils_fw_rpc_tid_s sw;
+
+	if (!IS_CHIP_FEATURE(MIPS)) {
+		err = -1;
+		goto err_exit;
+	}
+	err = hw_atl_utils_fw_upload_dwords(self, self->rpc_addr,
+					    (u32 *)(void *)&self->rpc,
+					    (rpc_size + sizeof(u32) -
+					    sizeof(u8)) / sizeof(u32));
+	if (err < 0)
+		goto err_exit;
+
+	sw.tid = 0xFFFFU & (++self->rpc_tid);
+	sw.len = (u16)rpc_size;
+	aq_hw_write_reg(self, HW_ATL_RPC_CONTROL_ADR, sw.val);
+
+err_exit:
+	return err;
+}
+
+int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,
+				    struct hw_aq_atl_utils_fw_rpc **rpc)
+{
+	int err = 0;
+	struct aq_hw_atl_utils_fw_rpc_tid_s sw;
+	struct aq_hw_atl_utils_fw_rpc_tid_s fw;
+
+	do {
+		sw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);
+
+		self->rpc_tid = sw.tid;
+
+		AQ_HW_WAIT_FOR(sw.tid ==
+				(fw.val =
+				aq_hw_read_reg(self, HW_ATL_RPC_STATE_ADR),
+				fw.tid), 1000U, 100U);
+		if (err < 0)
+			goto err_exit;
+
+		if (fw.len == 0xFFFFU) {
+			err = hw_atl_utils_fw_rpc_call(self, sw.len);
+			if (err < 0)
+				goto err_exit;
+		}
+	} while (sw.tid != fw.tid || 0xFFFFU == fw.len);
+	if (err < 0)
+		goto err_exit;
+
+	if (rpc) {
+		if (fw.len) {
+			err =
+			hw_atl_utils_fw_downld_dwords(self,
+						      self->rpc_addr,
+						      (u32 *)(void *)
+						      &self->rpc,
+						      (fw.len + sizeof(u32) -
+						      sizeof(u8)) /
+						      sizeof(u32));
+			if (err < 0)
+				goto err_exit;
+		}
+
+		*rpc = &self->rpc;
+	}
+
+err_exit:
+	return err;
+}
+
+static int hw_atl_utils_mpi_create(struct aq_hw_s *self)
+{
+	int err = 0;
+
+	err = hw_atl_utils_init_ucp(self, self->aq_nic_cfg->aq_hw_caps);
+	if (err < 0)
+		goto err_exit;
+
+	err = hw_atl_utils_fw_rpc_init(self);
+	if (err < 0)
+		goto err_exit;
+
+err_exit:
+	return err;
+}
+
+int hw_atl_utils_mpi_read_mbox(struct aq_hw_s *self,
+			       struct hw_aq_atl_utils_mbox_header *pmbox)
+{
+	return hw_atl_utils_fw_downld_dwords(self,
+				      self->mbox_addr,
+				      (u32 *)(void *)pmbox,
+				      sizeof(*pmbox) / sizeof(u32));
+}
+
+void hw_atl_utils_mpi_read_stats(struct aq_hw_s *self,
+				 struct hw_aq_atl_utils_mbox *pmbox)
+{
+	int err = 0;
+
+	err = hw_atl_utils_fw_downld_dwords(self,
+					    self->mbox_addr,
+					    (u32 *)(void *)pmbox,
+					    sizeof(*pmbox) / sizeof(u32));
+	if (err < 0)
+		goto err_exit;
+
+	if (IS_CHIP_FEATURE(REVISION_A0)) {
+		unsigned int mtu = self->aq_nic_cfg ?
+					self->aq_nic_cfg->mtu : 1514U;
+		pmbox->stats.ubrc = pmbox->stats.uprc * mtu;
+		pmbox->stats.ubtc = pmbox->stats.uptc * mtu;
+		pmbox->stats.dpc = atomic_read(&self->dpc);
+	} else {
+		pmbox->stats.dpc = hw_atl_reg_rx_dma_stat_counter7get(self);
+	}
+
+err_exit:;
+}
+
+int hw_atl_utils_mpi_set_speed(struct aq_hw_s *self, u32 speed)
+{
+	u32 val = aq_hw_read_reg(self, HW_ATL_MPI_CONTROL_ADR);
+
+	val = val & ~HW_ATL_MPI_SPEED_MSK;
+	val |= speed << HW_ATL_MPI_SPEED_SHIFT;
+	aq_hw_write_reg(self, HW_ATL_MPI_CONTROL_ADR, val);
+
+	return 0;
+}
+
+int hw_atl_utils_mpi_set_state(struct aq_hw_s *self,
+				enum hal_atl_utils_fw_state_e state)
+{
+	int err = 0;
+	u32 transaction_id = 0;
+	struct hw_aq_atl_utils_mbox_header mbox;
+	u32 val = aq_hw_read_reg(self, HW_ATL_MPI_CONTROL_ADR);
+
+	if (state == MPI_RESET) {
+		hw_atl_utils_mpi_read_mbox(self, &mbox);
+
+		transaction_id = mbox.transaction_id;
+
+		AQ_HW_WAIT_FOR(transaction_id !=
+				(hw_atl_utils_mpi_read_mbox(self, &mbox),
+				 mbox.transaction_id),
+			       1000U, 100U);
+		if (err < 0)
+			goto err_exit;
+	}
+	/* On interface DEINIT we disable DW (raise bit)
+	 * Otherwise enable DW (clear bit)
+	 */
+	if (state == MPI_DEINIT || state == MPI_POWER)
+		val |= HW_ATL_MPI_DIRTY_WAKE_MSK;
+	else
+		val &= ~HW_ATL_MPI_DIRTY_WAKE_MSK;
+
+	/* Set new state bits */
+	val = val & ~HW_ATL_MPI_STATE_MSK;
+	val |= state & HW_ATL_MPI_STATE_MSK;
+
+	aq_hw_write_reg(self, HW_ATL_MPI_CONTROL_ADR, val);
+err_exit:
+	return err;
+}
+
+int hw_atl_utils_mpi_get_link_status(struct aq_hw_s *self)
+{
+	u32 cp0x036C = aq_hw_read_reg(self, HW_ATL_MPI_STATE_ADR);
+	u32 link_speed_mask = cp0x036C >> HW_ATL_MPI_SPEED_SHIFT;
+	struct aq_hw_link_status_s *link_status = &self->aq_link_status;
+
+	if (!link_speed_mask) {
+		link_status->mbps = 0U;
+	} else {
+		switch (link_speed_mask) {
+		case HAL_ATLANTIC_RATE_10G:
+			link_status->mbps = 10000U;
+			break;
+
+		case HAL_ATLANTIC_RATE_5G:
+		case HAL_ATLANTIC_RATE_5GSR:
+			link_status->mbps = 5000U;
+			break;
+
+		case HAL_ATLANTIC_RATE_2GS:
+			link_status->mbps = 2500U;
+			break;
+
+		case HAL_ATLANTIC_RATE_1G:
+			link_status->mbps = 1000U;
+			break;
+
+		case HAL_ATLANTIC_RATE_100M:
+			link_status->mbps = 100U;
+			break;
+
+		default:
+			return -EBUSY;
+		}
+	}
+
+	return 0;
+}
+
+int hw_atl_utils_get_mac_permanent(struct aq_hw_s *self,
+				   u8 *mac)
+{
+	int err = 0;
+	u32 h = 0U;
+	u32 l = 0U;
+	u32 mac_addr[2];
+
+	if (!aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG)) {
+		unsigned int rnd = 0;
+		unsigned int ucp_0x370 = 0;
+
+		get_random_bytes(&rnd, sizeof(unsigned int));
+
+		ucp_0x370 = 0x02020202 | (0xFEFEFEFE & rnd);
+		aq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);
+	}
+
+	err = hw_atl_utils_fw_downld_dwords(self,
+					    aq_hw_read_reg(self, 0x00000374U) +
+					    (40U * 4U),
+					    mac_addr,
+					    ARRAY_SIZE(mac_addr));
+	if (err < 0) {
+		mac_addr[0] = 0U;
+		mac_addr[1] = 0U;
+		err = 0;
+	} else {
+		mac_addr[0] = __swab32(mac_addr[0]);
+		mac_addr[1] = __swab32(mac_addr[1]);
+	}
+
+	ether_addr_copy(mac, (u8 *)mac_addr);
+
+	if ((mac[0] & 0x01U) || ((mac[0] | mac[1] | mac[2]) == 0x00U)) {
+		/* chip revision */
+		l = 0xE3000000U
+			| (0xFFFFU & aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG))
+			| (0x00 << 16);
+		h = 0x8001300EU;
+
+		mac[5] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[4] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[3] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[2] = (u8)(0xFFU & l);
+		mac[1] = (u8)(0xFFU & h);
+		h >>= 8;
+		mac[0] = (u8)(0xFFU & h);
+	}
+
+	return err;
+}
+
+unsigned int hw_atl_utils_mbps_2_speed_index(unsigned int mbps)
+{
+	unsigned int ret = 0U;
+
+	switch (mbps) {
+	case 100U:
+		ret = 5U;
+		break;
+
+	case 1000U:
+		ret = 4U;
+		break;
+
+	case 2500U:
+		ret = 3U;
+		break;
+
+	case 5000U:
+		ret = 1U;
+		break;
+
+	case 10000U:
+		ret = 0U;
+		break;
+
+	default:
+		break;
+	}
+	return ret;
+}
+
+void hw_atl_utils_hw_chip_features_init(struct aq_hw_s *self, u32 *p)
+{
+	u32 chip_features = 0U;
+	u32 val = hw_atl_reg_glb_mif_id_get(self);
+	u32 mif_rev = val & 0xFFU;
+
+	if ((0xFU & mif_rev) == 1U) {
+		chip_features |= HAL_ATLANTIC_UTILS_CHIP_REVISION_A0 |
+			HAL_ATLANTIC_UTILS_CHIP_MPI_AQ |
+			HAL_ATLANTIC_UTILS_CHIP_MIPS;
+	} else if ((0xFU & mif_rev) == 2U) {
+		chip_features |= HAL_ATLANTIC_UTILS_CHIP_REVISION_B0 |
+			HAL_ATLANTIC_UTILS_CHIP_MPI_AQ |
+			HAL_ATLANTIC_UTILS_CHIP_MIPS |
+			HAL_ATLANTIC_UTILS_CHIP_TPO2 |
+			HAL_ATLANTIC_UTILS_CHIP_RPF2;
+	} else if ((0xFU & mif_rev) == 0xAU) {
+		chip_features |= HAL_ATLANTIC_UTILS_CHIP_REVISION_B1 |
+			HAL_ATLANTIC_UTILS_CHIP_MPI_AQ |
+			HAL_ATLANTIC_UTILS_CHIP_MIPS |
+			HAL_ATLANTIC_UTILS_CHIP_TPO2 |
+			HAL_ATLANTIC_UTILS_CHIP_RPF2;
+	}
+
+	*p = chip_features;
+}
+
+static int hw_atl_fw1x_deinit(struct aq_hw_s *self)
+{
+	hw_atl_utils_mpi_set_speed(self, 0);
+	hw_atl_utils_mpi_set_state(self, MPI_DEINIT);
+	return 0;
+}
+
+int hw_atl_utils_update_stats(struct aq_hw_s *self)
+{
+	struct hw_aq_atl_utils_mbox mbox;
+
+	hw_atl_utils_mpi_read_stats(self, &mbox);
+
+#define AQ_SDELTA(_N_) (self->curr_stats._N_ += \
+			mbox.stats._N_ - self->last_stats._N_)
+
+	if (self->aq_link_status.mbps) {
+		AQ_SDELTA(uprc);
+		AQ_SDELTA(mprc);
+		AQ_SDELTA(bprc);
+		AQ_SDELTA(erpt);
+
+		AQ_SDELTA(uptc);
+		AQ_SDELTA(mptc);
+		AQ_SDELTA(bptc);
+		AQ_SDELTA(erpr);
+
+		AQ_SDELTA(ubrc);
+		AQ_SDELTA(ubtc);
+		AQ_SDELTA(mbrc);
+		AQ_SDELTA(mbtc);
+		AQ_SDELTA(bbrc);
+		AQ_SDELTA(bbtc);
+		AQ_SDELTA(dpc);
+	}
+#undef AQ_SDELTA
+	self->curr_stats.dma_pkt_rc = hw_atl_stats_rx_dma_good_pkt_counterlsw_get(self);
+	self->curr_stats.dma_pkt_tc = hw_atl_stats_tx_dma_good_pkt_counterlsw_get(self);
+	self->curr_stats.dma_oct_rc = hw_atl_stats_rx_dma_good_octet_counterlsw_get(self);
+	self->curr_stats.dma_oct_tc = hw_atl_stats_tx_dma_good_octet_counterlsw_get(self);
+
+	memcpy(&self->last_stats, &mbox.stats, sizeof(mbox.stats));
+
+	return 0;
+}
+
+struct aq_stats_s *hw_atl_utils_get_hw_stats(struct aq_hw_s *self)
+{
+	return &self->curr_stats;
+}
+
+static const u32 hw_atl_utils_hw_mac_regs[] = {
+	0x00005580U, 0x00005590U, 0x000055B0U, 0x000055B4U,
+	0x000055C0U, 0x00005B00U, 0x00005B04U, 0x00005B08U,
+	0x00005B0CU, 0x00005B10U, 0x00005B14U, 0x00005B18U,
+	0x00005B1CU, 0x00005B20U, 0x00005B24U, 0x00005B28U,
+	0x00005B2CU, 0x00005B30U, 0x00005B34U, 0x00005B38U,
+	0x00005B3CU, 0x00005B40U, 0x00005B44U, 0x00005B48U,
+	0x00005B4CU, 0x00005B50U, 0x00005B54U, 0x00005B58U,
+	0x00005B5CU, 0x00005B60U, 0x00005B64U, 0x00005B68U,
+	0x00005B6CU, 0x00005B70U, 0x00005B74U, 0x00005B78U,
+	0x00005B7CU, 0x00007C00U, 0x00007C04U, 0x00007C08U,
+	0x00007C0CU, 0x00007C10U, 0x00007C14U, 0x00007C18U,
+	0x00007C1CU, 0x00007C20U, 0x00007C40U, 0x00007C44U,
+	0x00007C48U, 0x00007C4CU, 0x00007C50U, 0x00007C54U,
+	0x00007C58U, 0x00007C5CU, 0x00007C60U, 0x00007C80U,
+	0x00007C84U, 0x00007C88U, 0x00007C8CU, 0x00007C90U,
+	0x00007C94U, 0x00007C98U, 0x00007C9CU, 0x00007CA0U,
+	0x00007CC0U, 0x00007CC4U, 0x00007CC8U, 0x00007CCCU,
+	0x00007CD0U, 0x00007CD4U, 0x00007CD8U, 0x00007CDCU,
+	0x00007CE0U, 0x00000300U, 0x00000304U, 0x00000308U,
+	0x0000030cU, 0x00000310U, 0x00000314U, 0x00000318U,
+	0x0000031cU, 0x00000360U, 0x00000364U, 0x00000368U,
+	0x0000036cU, 0x00000370U, 0x00000374U, 0x00006900U,
+};
+
+int hw_atl_utils_hw_get_regs(struct aq_hw_s *self,
+			     const struct aq_hw_caps_s *aq_hw_caps,
+			     u32 *regs_buff)
+{
+	unsigned int i = 0U;
+
+	for (i = 0; i < aq_hw_caps->mac_regs_count; i++)
+		regs_buff[i] = aq_hw_read_reg(self,
+					      hw_atl_utils_hw_mac_regs[i]);
+	return 0;
+}
+
+int hw_atl_utils_get_fw_version(struct aq_hw_s *self, u32 *fw_version)
+{
+	*fw_version = aq_hw_read_reg(self, 0x18U);
+	return 0;
+}
+
+static int aq_fw1x_set_wol(struct aq_hw_s *self, bool wol_enabled, u8 *mac)
+{
+	struct hw_aq_atl_utils_fw_rpc *prpc = NULL;
+	unsigned int rpc_size = 0U;
+	int err = 0;
+
+	err = hw_atl_utils_fw_rpc_wait(self, &prpc);
+	if (err < 0)
+				goto err_exit;
+
+	memset(prpc, 0, sizeof *prpc);
+
+	if (wol_enabled) {
+		rpc_size = sizeof(prpc->msg_id) + sizeof(prpc->msg_wol);
+
+		prpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_WOL_ADD;
+		prpc->msg_wol.priority = 0x10000000; /* normal priority */
+		prpc->msg_wol.pattern_id = 1U;
+		prpc->msg_wol.wol_packet_type = 2U; /* Magic Packet */
+
+		ether_addr_copy((u8 *)&prpc->msg_wol.wol_pattern, mac);
+	} else {
+		rpc_size = sizeof(prpc->msg_id) + sizeof(prpc->msg_del_id);
+
+		prpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_WOL_DEL;
+		prpc->msg_wol.pattern_id = 1U;
+	}
+
+	err = hw_atl_utils_fw_rpc_call(self, rpc_size);
+	if (err < 0)
+		goto err_exit;
+err_exit:
+	return err;
+}
+
+int aq_fw1x_set_power(struct aq_hw_s *self,unsigned int power_state,
+		u8 *mac)
+{
+	struct hw_aq_atl_utils_fw_rpc *prpc = NULL;
+	unsigned int rpc_size = 0U;
+	int err = 0;
+	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
+		err = aq_fw1x_set_wol(self, 1, mac);
+
+		if (err < 0)
+			goto err_exit;
+
+		rpc_size = sizeof(prpc->msg_id) +
+				sizeof(prpc->msg_enable_wakeup);
+
+		err = hw_atl_utils_fw_rpc_wait(self, &prpc);
+
+		if (err < 0)
+			goto err_exit;
+
+		memset(prpc, 0, rpc_size);
+
+		prpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_ENABLE_WAKEUP;
+		prpc->msg_enable_wakeup.pattern_mask = 0x00000002;
+
+		err = hw_atl_utils_fw_rpc_call(self, rpc_size);
+		if (err < 0)
+			goto err_exit;
+	}
+	hw_atl_utils_mpi_set_speed(self, 0);
+	hw_atl_utils_mpi_set_state(self, MPI_POWER);
+err_exit:
+	return err;
+}
+
+
+
+const struct aq_fw_ops aq_fw_1x_ops = {
+	.init = hw_atl_utils_mpi_create,
+	.deinit = hw_atl_fw1x_deinit,
+	.reset = NULL,
+	.get_mac_permanent = hw_atl_utils_get_mac_permanent,
+	.set_link_speed = hw_atl_utils_mpi_set_speed,
+	.set_state = hw_atl_utils_mpi_set_state,
+	.update_link_status = hw_atl_utils_mpi_get_link_status,
+	.update_stats = hw_atl_utils_update_stats,
+	.set_power = aq_fw1x_set_power,
+	.get_temp = NULL,
+	.get_cable_len = NULL,
+	.set_eee_rate = NULL,
+	.get_eee_rate = NULL,
+	.set_flow_control = NULL,
+};
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.h b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.h
new file mode 100644
index 00000000..755b23a
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils.h
@@ -0,0 +1,486 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_utils.h: Declaration of common functions for Atlantic hardware
+ * abstraction layer.
+ */
+
+#ifndef HW_ATL_UTILS_H
+#define HW_ATL_UTILS_H
+
+#define HW_ATL_FLUSH() { (void)aq_hw_read_reg(self, 0x10); }
+
+/* Hardware tx descriptor */
+struct __packed hw_atl_txd_s {
+	u64 buf_addr;
+	u32 ctl;
+	u32 ctl2; /* 63..46 - payload length, 45 - ctx enable, 44 - ctx index */
+};
+
+/* Hardware tx context descriptor */
+struct __packed hw_atl_txc_s {
+	u32 rsvd;
+	u32 len;
+	u32 ctl;
+	u32 len2;
+};
+
+/* Hardware rx descriptor */
+struct __packed hw_atl_rxd_s {
+	u64 buf_addr;
+	u64 hdr_addr;
+};
+
+/* Hardware rx descriptor writeback */
+struct __packed hw_atl_rxd_wb_s {
+	u32 type;
+	u32 rss_hash;
+	u16 status;
+	u16 pkt_len;
+	u16 next_desc_ptr;
+	u16 vlan;
+};
+
+struct __packed hw_atl_stats_s {
+	u32 uprc;
+	u32 mprc;
+	u32 bprc;
+	u32 erpt;
+	u32 uptc;
+	u32 mptc;
+	u32 bptc;
+	u32 erpr;
+	u32 mbtc;
+	u32 bbtc;
+	u32 mbrc;
+	u32 bbrc;
+	u32 ubrc;
+	u32 ubtc;
+	u32 dpc;
+};
+
+union __packed ip_addr {
+	struct {
+		u8 addr[16];
+	} v6;
+	struct {
+		u8 padding[12];
+		u8 addr[4];
+	} v4;
+};
+
+struct __packed hw_aq_atl_utils_fw_rpc {
+	u32 msg_id;
+
+	union {
+		struct {
+			u32 pong;
+		} msg_ping;
+
+		struct {
+			u8 mac_addr[6];
+			u32 ip_addr_cnt;
+
+			struct {
+				union ip_addr addr;
+				union ip_addr mask;
+			} ip[1];
+		} msg_arp;
+
+		struct {
+			u32 len;
+			u8 packet[1514U];
+		} msg_inject;
+
+		struct {
+			u32 priority;
+			u32 wol_packet_type;
+			u32 pattern_id;
+			u32 next_wol_pattern_offset;
+			union {
+				struct {
+					u32 flags;
+					u8 ipv4_source_address[4];
+					u8 ipv4_dest_address[4];
+					u16 tcp_source_port_number;
+					u16 tcp_dest_port_number;
+				} ipv4_tcp_syn_parameters;
+
+				struct {
+					u32 flags;
+					u8 ipv6_source_address[16];
+					u8 ipv6_dest_address[16];
+					u16 tcp_source_port_number;
+					u16 tcp_dest_port_number;
+				} ipv6_tcp_syn_parameters;
+
+				struct {
+					u32 flags;
+				} eapol_request_id_message_parameters;
+
+				struct {
+					u32 flags;
+					u32 mask_offset;
+					u32 mask_size;
+					u32 pattern_offset;
+					u32 pattern_size;
+				} wol_bit_map_pattern;
+				struct {
+					u8 mac_addr[6];
+				} wol_magic_packet_pattern;
+
+			} wol_pattern;
+		} msg_wol;
+
+		struct {
+			u16 tcQuanta[8];
+			u16 tcThreshold[8];
+		} msg_msm_pfc_quantas;
+
+		struct {
+			union {
+				u32 pattern_mask;
+				struct {
+					u32 aq_pm_wol_reason_arp_v4_pkt : 1;
+					u32 aq_pm_wol_reason_ipv4_ping_pkt : 1;
+					u32 aq_pm_wol_reason_ipv6_ns_pkt : 1;
+					u32 aq_pm_wol_reason_ipv6_ping_pkt : 1;
+					u32 aq_pm_wol_reason_link_up : 1;
+					u32 aq_pm_wol_reason_link_down : 1;
+					u32 aq_pm_wol_reason_maximum : 1;
+				};
+			};
+			union {
+				u32 offload_mask;
+			};
+		} msg_enable_wakeup;
+
+		struct {
+			u32 priority;
+			u32 protocol_offload_type;
+			u32 protocol_offload_id;
+			u32 next_protocol_offload_offset;
+
+			union {
+				struct {
+					u32 flags;
+					u8 remote_ipv4_addr[4];
+					u8 host_ipv4_addr[4];
+					u8 mac_addr[6];
+				} ipv4_arp_params;
+			};
+		} msg_offload;
+
+		struct {
+			u32 id;
+		} msg_del_id;
+
+	};
+};
+
+struct __packed hw_aq_atl_utils_mbox_header {
+	u32 version;
+	u32 transaction_id;
+	u32 error;
+};
+
+struct __packed hw_aq_info {
+	u8 reserved[6];
+	u16 phy_fault_code;
+	u16 phy_temperature;
+	u8 cable_len;
+	u8 reserved1;
+	u32 cable_diag_data[4];
+	u8 reserved2[32];
+	u32 caps_lo;
+	u32 caps_hi;
+};
+
+struct __packed hw_aq_atl_utils_mbox {
+	struct hw_aq_atl_utils_mbox_header header;
+	struct hw_atl_stats_s stats;
+	struct hw_aq_info info;
+};
+
+/* fw2x */
+typedef u16	in_port_t;
+typedef u32	ip4_addr_t;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
+typedef int	int32_t;
+typedef short	int16_t;
+#endif
+typedef u32	fw_offset_t;
+
+struct __packed ip6_addr {
+	u32 addr[4];
+};
+
+struct __packed offload_ka_v4 {
+	u32 timeout;
+	in_port_t local_port;
+	in_port_t remote_port;
+	u8 remote_mac_addr[6];
+	u16 win_size;
+	u32 seq_num;
+	u32 ack_num;
+	ip4_addr_t local_ip;
+	ip4_addr_t remote_ip;
+};
+
+struct __packed offload_ka_v6 {
+	u32 timeout;
+	in_port_t local_port;
+	in_port_t remote_port;
+	u8 remote_mac_addr[6];
+	u16 win_size;
+	u32 seq_num;
+	u32 ack_num;
+	struct ip6_addr local_ip;
+	struct ip6_addr remote_ip;
+};
+
+struct __packed offload_ip_info {
+	u8 v4_local_addr_count;
+	u8 v4_addr_count;
+	u8 v6_local_addr_count;
+	u8 v6_addr_count;
+	fw_offset_t v4_addr;
+	fw_offset_t v4_prefix;
+	fw_offset_t v6_addr;
+	fw_offset_t v6_prefix;
+};
+
+struct __packed offload_port_info {
+	u16 udp_port_count;
+	u16 tcp_port_count;
+	fw_offset_t udp_port;
+	fw_offset_t tcp_port;
+};
+
+struct __packed offload_ka_info {
+	u16 v4_ka_count;
+	u16 v6_ka_count;
+	u32 retry_count;
+	u32 retry_interval;
+	fw_offset_t v4_ka;
+	fw_offset_t v6_ka;
+};
+
+struct __packed offload_rr_info {
+	u32 rr_count;
+	u32 rr_buf_len;
+	fw_offset_t rr_id_x;
+	fw_offset_t rr_buf;
+};
+
+struct __packed offload_info {
+	u32 version;		// current version is 0x00000000
+	u32 len;		// The whole structure length
+				// including the variable-size buf
+	u8 mac_addr[6];		// 8 bytes to keep alignment. Only
+				// first 6 meaningful.
+
+	u8 reserved[2];
+
+	struct offload_ip_info ips;
+	struct offload_port_info ports;
+	struct offload_ka_info kas;
+	struct offload_rr_info rrs;
+	u8 buf[0];
+};
+
+#define HAL_ATLANTIC_UTILS_CHIP_MIPS         0x00000001U
+#define HAL_ATLANTIC_UTILS_CHIP_TPO2         0x00000002U
+#define HAL_ATLANTIC_UTILS_CHIP_RPF2         0x00000004U
+#define HAL_ATLANTIC_UTILS_CHIP_MPI_AQ       0x00000010U
+#define HAL_ATLANTIC_UTILS_CHIP_REVISION_A0  0x01000000U
+#define HAL_ATLANTIC_UTILS_CHIP_REVISION_B0  0x02000000U
+#define HAL_ATLANTIC_UTILS_CHIP_REVISION_B1  0x04000000U
+
+
+#define IS_CHIP_FEATURE(_F_) (HAL_ATLANTIC_UTILS_CHIP_##_F_ & \
+	self->chip_features)
+
+enum hal_atl_utils_fw_state_e {
+	MPI_DEINIT = 0,
+	MPI_RESET = 1,
+	MPI_INIT = 2,
+	MPI_POWER = 4,
+};
+
+#define HAL_ATLANTIC_RATE_10G        BIT(0)
+#define HAL_ATLANTIC_RATE_5G         BIT(1)
+#define HAL_ATLANTIC_RATE_5GSR       BIT(2)
+#define HAL_ATLANTIC_RATE_2GS        BIT(3)
+#define HAL_ATLANTIC_RATE_1G         BIT(4)
+#define HAL_ATLANTIC_RATE_100M       BIT(5)
+#define HAL_ATLANTIC_RATE_INVALID    BIT(6)
+
+#define HAL_ATLANTIC_UTILS_FW_MSG_PING     1U
+#define HAL_ATLANTIC_UTILS_FW_MSG_ARP      2U
+#define HAL_ATLANTIC_UTILS_FW_MSG_INJECT   3U
+#define HAL_ATLANTIC_UTILS_FW_MSG_WOL_ADD 4U
+#define HAL_ATLANTIC_UTILS_FW_MSG_WOL_DEL 5U
+#define HAL_ATLANTIC_UTILS_FW_MSG_ENABLE_WAKEUP 6U
+#define HAL_ATLANTIC_UTILS_FW_MSG_MSM_PFC  7U
+#define HAL_ATLANTIC_UTILS_FW_MSG_PROVISIONING 8U
+#define HAL_ATLANTIC_UTILS_FW_MSG_OFFLOAD_ADD  9U
+#define HAL_ATLANTIC_UTILS_FW_MSG_OFFLOAD_DEL  10U
+#define HAL_ATLANTIC_UTILS_FW_MSG_CABLE_DIAG   13U // 0xd
+
+enum hw_atl_fw2x_rate {
+	FW2X_RATE_100M    = 0x20,
+	FW2X_RATE_1G      = 0x100,
+	FW2X_RATE_2G5     = 0x200,
+	FW2X_RATE_5G      = 0x400,
+	FW2X_RATE_10G     = 0x800,
+};
+
+enum hw_atl_fw2x_caps_lo {
+	CAPS_LO_10BASET_HD = 0x00,
+	CAPS_LO_10BASET_FD,
+	CAPS_LO_100BASETX_HD,
+	CAPS_LO_100BASET4_HD,
+	CAPS_LO_100BASET2_HD,
+	CAPS_LO_100BASETX_FD,
+	CAPS_LO_100BASET2_FD,
+	CAPS_LO_1000BASET_HD,
+	CAPS_LO_1000BASET_FD,
+	CAPS_LO_2P5GBASET_FD,
+	CAPS_LO_5GBASET_FD,
+	CAPS_LO_10GBASET_FD,
+};
+
+enum hw_atl_fw2x_caps_hi {
+	CAPS_HI_RESERVED1 = 0x00,
+	CAPS_HI_10BASET_EEE,
+	CAPS_HI_RESERVED2,
+	CAPS_HI_PAUSE,
+	CAPS_HI_ASYMMETRIC_PAUSE,
+	CAPS_HI_100BASETX_EEE,
+	CAPS_HI_RESERVED3,
+	CAPS_HI_RESERVED4,
+	CAPS_HI_1000BASET_FD_EEE,
+	CAPS_HI_2P5GBASET_FD_EEE,
+	CAPS_HI_5GBASET_FD_EEE,
+	CAPS_HI_10GBASET_FD_EEE,
+	CAPS_HI_RESERVED5,
+	CAPS_HI_RESERVED6,
+	CAPS_HI_RESERVED7,
+	CAPS_HI_RESERVED8,
+	CAPS_HI_RESERVED9,
+	CAPS_HI_CABLE_DIAG,
+	CAPS_HI_TEMPERATURE,
+	CAPS_HI_DOWNSHIFT,
+	CAPS_HI_PTP_AVB_EN,
+	CAPS_HI_MEDIA_DETECT,
+	CAPS_HI_LINK_DROP,
+	CAPS_HI_SLEEP_PROXY,
+	CAPS_HI_WOL,
+	CAPS_HI_MAC_STOP,
+	CAPS_HI_EXT_LOOPBACK,
+	CAPS_HI_INT_LOOPBACK,
+	CAPS_HI_EFUSE_AGENT,
+	CAPS_HI_WOL_TIMER,
+	CAPS_HI_STATISTICS,
+	CAPS_HI_TRANSACTION_ID,
+};
+
+enum hw_atl_fw2x_ctrl {
+	CTRL_RESERVED1 = 0x00,
+	CTRL_RESERVED2,
+	CTRL_RESERVED3,
+	CTRL_PAUSE,
+	CTRL_ASYMMETRIC_PAUSE,
+	CTRL_RESERVED4,
+	CTRL_RESERVED5,
+	CTRL_RESERVED6,
+	CTRL_1GBASET_FD_EEE,
+	CTRL_2P5GBASET_FD_EEE,
+	CTRL_5GBASET_FD_EEE,
+	CTRL_10GBASET_FD_EEE,
+	CTRL_THERMAL_SHUTDOWN,
+	CTRL_PHY_LOGS,
+	CTRL_EEE_AUTO_DISABLE,
+	CTRL_PFC,
+	CTRL_WAKE_ON_LINK,
+	CTRL_CABLE_DIAG,
+	CTRL_TEMPERATURE,
+	CTRL_DOWNSHIFT,
+	CTRL_PTP_AVB,
+	CTRL_RESERVED7,
+	CTRL_LINK_DROP,
+	CTRL_SLEEP_PROXY,
+	CTRL_WOL,
+	CTRL_MAC_STOP,
+	CTRL_EXT_LOOPBACK,
+	CTRL_INT_LOOPBACK,
+	CTRL_RESERVED8,
+	CTRL_WOL_TIMER,
+	CTRL_STATISTICS,
+	CTRL_FORCE_RECONNECT,
+};
+
+struct aq_hw_s;
+struct aq_fw_ops;
+struct aq_hw_caps_s;
+struct aq_hw_link_status_s;
+
+int hw_atl_utils_initfw(struct aq_hw_s *self, const struct aq_fw_ops **fw_ops);
+
+int hw_atl_utils_soft_reset(struct aq_hw_s *self);
+
+void hw_atl_utils_hw_chip_features_init(struct aq_hw_s *self, u32 *p);
+
+int hw_atl_utils_mpi_read_mbox(struct aq_hw_s *self,
+			       struct hw_aq_atl_utils_mbox_header *pmbox);
+
+void hw_atl_utils_mpi_read_stats(struct aq_hw_s *self,
+				 struct hw_aq_atl_utils_mbox *pmbox);
+
+void hw_atl_utils_mpi_set(struct aq_hw_s *self,
+			  enum hal_atl_utils_fw_state_e state,
+			  u32 speed);
+
+int hw_atl_utils_mpi_get_link_status(struct aq_hw_s *self);
+
+int hw_atl_utils_get_mac_permanent(struct aq_hw_s *self,
+				   u8 *mac);
+
+unsigned int hw_atl_utils_mbps_2_speed_index(unsigned int mbps);
+
+int hw_atl_utils_hw_get_regs(struct aq_hw_s *self,
+			     const struct aq_hw_caps_s *aq_hw_caps,
+			     u32 *regs_buff);
+
+int hw_atl_utils_hw_set_power(struct aq_hw_s *self,
+			      unsigned int power_state);
+
+int hw_atl_utils_hw_deinit(struct aq_hw_s *self);
+
+int hw_atl_utils_get_fw_version(struct aq_hw_s *self, u32 *fw_version);
+
+int hw_atl_utils_update_stats(struct aq_hw_s *self);
+
+struct aq_stats_s *hw_atl_utils_get_hw_stats(struct aq_hw_s *self);
+
+int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
+				  u32 *p, u32 cnt);
+
+int hw_atl_utils_fw_set_wol(struct aq_hw_s *self, bool wol_enabled, u8 *mac);
+
+int hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size);
+
+int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,
+		    struct hw_aq_atl_utils_fw_rpc **rpc);
+
+extern const struct aq_fw_ops aq_fw_1x_ops;
+extern const struct aq_fw_ops aq_fw_2x_ops;
+
+#endif /* HW_ATL_UTILS_H */
diff --git a/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils_fw2x.c b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils_fw2x.c
new file mode 100644
index 00000000..54e9bfd
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/hw_atl/hw_atl_utils_fw2x.c
@@ -0,0 +1,501 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+/* File hw_atl_utils_fw2x.c: Definition of firmware 2.x functions for
+ * Atlantic hardware abstraction layer.
+ */
+
+#include "../aq_hw.h"
+#include "../aq_hw_utils.h"
+#include "../aq_pci_func.h"
+#include "../aq_ring.h"
+#include "../aq_vec.h"
+#include "../aq_nic.h"
+#include "hw_atl_utils.h"
+#include "hw_atl_llh.h"
+
+#define HW_ATL_FW2X_MPI_EFUSE_ADDR       0x364
+#define HW_ATL_FW2X_MPI_MBOX_ADDR        0x360
+#define HW_ATL_FW2X_MPI_RPC_ADDR         0x334
+
+#define HW_ATL_FW2X_MPI_CONTROL_ADDR     0x368
+#define HW_ATL_FW2X_MPI_CONTROL2_ADDR    0x36C
+
+#define HW_ATL_FW2X_MPI_STATE_ADDR       0x370
+#define HW_ATL_FW2X_MPI_STATE2_ADDR      0x374
+
+#define HW_ATL_FW2X_CAP_SLEEP_PROXY      BIT(CAPS_HI_SLEEP_PROXY)
+#define HW_ATL_FW2X_CAP_WOL              BIT(CAPS_HI_WOL)
+
+#define HW_ATL_FW2X_CAP_EEE_1G_MASK      BIT(CAPS_HI_1000BASET_FD_EEE)
+#define HW_ATL_FW2X_CAP_EEE_2G5_MASK     BIT(CAPS_HI_2P5GBASET_FD_EEE)
+#define HW_ATL_FW2X_CAP_EEE_5G_MASK      BIT(CAPS_HI_5GBASET_FD_EEE)
+#define HW_ATL_FW2X_CAP_EEE_10G_MASK     BIT(CAPS_HI_10GBASET_FD_EEE)
+
+#define HAL_ATLANTIC_WOL_FILTERS_COUNT   8
+#define HAL_ATLANTIC_UTILS_FW2X_MSG_WOL  0x0E
+
+struct __packed fw2x_msg_wol_pattern {
+	u8 mask[16];
+	u32 crc;
+};
+
+struct __packed fw2x_msg_wol {
+	u32 msg_id;
+	u8 hw_addr[6];
+	u8 magic_packet_enabled;
+	u8 filter_count;
+	struct fw2x_msg_wol_pattern filter[HAL_ATLANTIC_WOL_FILTERS_COUNT];
+	u8 link_up_enabled;
+	u8 link_down_enabled;
+	u16 reserved;
+	u32 link_up_timeout;
+	u32 link_down_timeout;
+};
+
+static int aq_fw2x_set_link_speed(struct aq_hw_s *self, u32 speed);
+static int aq_fw2x_set_state(struct aq_hw_s *self,
+			     enum hal_atl_utils_fw_state_e state);
+
+static int aq_fw2x_init(struct aq_hw_s *self)
+{
+	int err = 0;
+
+	/* check 10 times by 1ms */
+	AQ_HW_WAIT_FOR(0U != (self->mbox_addr =
+		       aq_hw_read_reg(self, HW_ATL_FW2X_MPI_MBOX_ADDR)),
+		       1000U, 10U);
+	AQ_HW_WAIT_FOR(0U != (self->rpc_addr =
+		       aq_hw_read_reg(self, HW_ATL_FW2X_MPI_RPC_ADDR)),
+		       1000U, 100U);
+	return err;
+}
+
+static int aq_fw2x_deinit(struct aq_hw_s *self)
+{
+	int err = aq_fw2x_set_link_speed(self, 0);
+
+	if (!err)
+		err = aq_fw2x_set_state(self, MPI_DEINIT);
+
+	return err;
+}
+
+static enum hw_atl_fw2x_rate link_speed_mask_2fw2x_ratemask(u32 speed)
+{
+	enum hw_atl_fw2x_rate rate = 0;
+
+	if (speed & AQ_NIC_RATE_10G)
+		rate |= FW2X_RATE_10G;
+	if (speed & AQ_NIC_RATE_5G)
+		rate |= FW2X_RATE_5G;
+	if (speed & AQ_NIC_RATE_5GSR)
+		rate |= FW2X_RATE_5G;
+	if (speed & AQ_NIC_RATE_2GS)
+		rate |= FW2X_RATE_2G5;
+	if (speed & AQ_NIC_RATE_1G)
+		rate |= FW2X_RATE_1G;
+	if (speed & AQ_NIC_RATE_100M)
+		rate |= FW2X_RATE_100M;
+
+	return rate;
+}
+
+static u32 fw2x_to_eee_mask(u32 speed)
+{
+	u32 rate = 0;
+
+	if (speed & HW_ATL_FW2X_CAP_EEE_10G_MASK)
+		rate |= AQ_NIC_RATE_EEE_10G;
+	if (speed & HW_ATL_FW2X_CAP_EEE_5G_MASK)
+		rate |= AQ_NIC_RATE_EEE_5G;
+	if (speed & HW_ATL_FW2X_CAP_EEE_2G5_MASK)
+		rate |= AQ_NIC_RATE_EEE_2GS;
+	if (speed & HW_ATL_FW2X_CAP_EEE_1G_MASK)
+		rate|= AQ_NIC_RATE_EEE_1G;
+
+	return rate;
+}
+
+static u32 eee_mask_to_fw2x(u32 speed)
+{
+	u32 rate = 0;
+
+	if (speed & AQ_NIC_RATE_EEE_10G)
+		rate |= HW_ATL_FW2X_CAP_EEE_10G_MASK;
+	if (speed & AQ_NIC_RATE_EEE_5G)
+		rate |= HW_ATL_FW2X_CAP_EEE_5G_MASK;
+	if (speed & AQ_NIC_RATE_EEE_2GS)
+		rate |= HW_ATL_FW2X_CAP_EEE_2G5_MASK;
+	if (speed & AQ_NIC_RATE_EEE_1G)
+		rate |= HW_ATL_FW2X_CAP_EEE_1G_MASK;
+
+	return rate;
+}
+
+static int aq_fw2x_set_link_speed(struct aq_hw_s *self, u32 speed)
+{
+	u32 val = link_speed_mask_2fw2x_ratemask(speed);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL_ADDR, val);
+
+	return 0;
+}
+
+static void aq_fw2x_set_mpi_flow_control(struct aq_hw_s *self, u32 *mpi_state)
+{
+	if (self->aq_nic_cfg->flow_control & AQ_NIC_FC_RX)
+		*mpi_state |= BIT(CAPS_HI_PAUSE);
+	else
+		*mpi_state &= ~BIT(CAPS_HI_PAUSE);
+
+	if (self->aq_nic_cfg->flow_control & AQ_NIC_FC_TX)
+		*mpi_state |= BIT(CAPS_HI_ASYMMETRIC_PAUSE);
+	else
+		*mpi_state &= ~BIT(CAPS_HI_ASYMMETRIC_PAUSE);
+}
+
+static int aq_fw2x_set_state(struct aq_hw_s *self,
+			     enum hal_atl_utils_fw_state_e state)
+{
+	u32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+
+	switch(state) {
+	case MPI_INIT:
+		mpi_state &= ~BIT(CAPS_HI_LINK_DROP);
+		if (self->aq_nic_cfg->eee_enabled)
+			mpi_state |= eee_mask_to_fw2x(self->aq_nic_cfg->eee_enabled);
+		aq_fw2x_set_mpi_flow_control(self, &mpi_state);
+		break;
+	case MPI_DEINIT:
+		mpi_state |= BIT(CAPS_HI_LINK_DROP);
+		break;
+	case MPI_RESET:
+	case MPI_POWER:
+		/* No actions */
+		break;
+	}
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);
+	return 0;
+}
+
+static int aq_fw2x_update_link_status(struct aq_hw_s *self)
+{
+	u32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE_ADDR);
+	u32 speed = mpi_state & (FW2X_RATE_100M | FW2X_RATE_1G |
+				FW2X_RATE_2G5 | FW2X_RATE_5G | FW2X_RATE_10G);
+	struct aq_hw_link_status_s *link_status = &self->aq_link_status;
+
+	if (speed) {
+		if (speed & FW2X_RATE_10G)
+			link_status->mbps = 10000;
+		else if (speed & FW2X_RATE_5G)
+			link_status->mbps = 5000;
+		else if (speed & FW2X_RATE_2G5)
+			link_status->mbps = 2500;
+		else if (speed & FW2X_RATE_1G)
+			link_status->mbps = 1000;
+		else if (speed & FW2X_RATE_100M)
+			link_status->mbps = 100;
+		else
+			link_status->mbps = 10000;
+	} else {
+		link_status->mbps = 0;
+	}
+
+	return 0;
+}
+
+int aq_fw2x_get_mac_permanent(struct aq_hw_s *self, u8 *mac)
+{
+	int err = 0;
+	u32 h = 0U;
+	u32 l = 0U;
+	u32 mac_addr[2] = { 0 };
+	u32 efuse_addr = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_EFUSE_ADDR);
+
+	if (efuse_addr != 0) {
+		err = hw_atl_utils_fw_downld_dwords(self,
+						    efuse_addr + (40U * 4U),
+						    mac_addr,
+						    ARRAY_SIZE(mac_addr));
+		if (err)
+			return err;
+		mac_addr[0] = __swab32(mac_addr[0]);
+		mac_addr[1] = __swab32(mac_addr[1]);
+	}
+
+	ether_addr_copy(mac, (u8 *)mac_addr);
+
+	if ((mac[0] & 0x01U) || ((mac[0] | mac[1] | mac[2]) == 0x00U)) {
+		unsigned int rnd = 0;
+
+		get_random_bytes(&rnd, sizeof(unsigned int));
+
+		l = 0xE3000000U
+			| (0xFFFFU & rnd)
+			| (0x00 << 16);
+		h = 0x8001300EU;
+
+		mac[5] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[4] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[3] = (u8)(0xFFU & l);
+		l >>= 8;
+		mac[2] = (u8)(0xFFU & l);
+		mac[1] = (u8)(0xFFU & h);
+		h >>= 8;
+		mac[0] = (u8)(0xFFU & h);
+	}
+	return err;
+}
+
+static int aq_fw2x_update_stats(struct aq_hw_s *self)
+{
+	int err = 0;
+	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+	u32 orig_stats_val = mpi_opts & BIT(CAPS_HI_STATISTICS);
+
+	/* Toggle statistics bit for FW to update */
+	mpi_opts = mpi_opts ^ BIT(CAPS_HI_STATISTICS);
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	/* Wait FW to report back */
+	AQ_HW_WAIT_FOR(orig_stats_val !=
+		       (aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+				       BIT(CAPS_HI_STATISTICS)),
+		       1U, 10000U);
+	if (err)
+		return err;
+
+	return hw_atl_utils_update_stats(self);
+}
+
+static int aq_fw2x_get_temp(struct aq_hw_s *self, int *temp)
+{
+	int err = 0;
+	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+	u32 temp_val = mpi_opts & BIT(CAPS_HI_TEMPERATURE);
+	u32 temp_res;
+
+	/* Toggle statistics bit for FW to 0x36C.18 (CAPS_HI_TEMPERATURE) */
+	mpi_opts = mpi_opts ^ BIT(CAPS_HI_TEMPERATURE);
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	/* Wait FW to report back */
+	AQ_HW_WAIT_FOR(temp_val !=
+			(aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+					BIT(CAPS_HI_TEMPERATURE)), 1U, 10000U);
+	err = hw_atl_utils_fw_downld_dwords(self,
+				self->mbox_addr +
+				offsetof(struct hw_aq_atl_utils_mbox, info) +
+				offsetof(struct hw_aq_info, phy_temperature),
+				&temp_res,
+				sizeof(temp_res)/sizeof(u32));
+
+	if (err)
+		return err;
+
+	*temp = temp_res  * 100 / 256;
+	return 0;
+}
+
+static int aq_fw2x_get_cable_len(struct aq_hw_s *self, int *cable_len)
+{
+	int err = 0;
+	u32 cable_len_res;
+
+	err = hw_atl_utils_fw_downld_dwords(self,
+				self->mbox_addr +
+				offsetof(struct hw_aq_atl_utils_mbox, info) +
+				offsetof(struct hw_aq_info, phy_temperature),
+				&cable_len_res,
+				sizeof(cable_len_res)/sizeof(u32));
+
+	if (err)
+		return err;
+
+	*cable_len = (cable_len_res >> 16) & 0xFF;
+	return 0;
+}
+
+static int aq_fw2x_set_sleep_proxy(struct aq_hw_s *self, u8 *mac)
+{
+	int err = 0;
+	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+	struct offload_info *cfg = NULL;
+	unsigned int rpc_size = 0U;
+	u32 mpi_opts;
+
+	rpc_size = sizeof(rpc->msg_id) + sizeof(*cfg);
+
+	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+	if (err < 0)
+		goto err_exit;
+
+	memset(rpc, 0, rpc_size);
+	cfg = (struct offload_info *)(&rpc->msg_id + 1);
+
+	memcpy(cfg->mac_addr, mac, ETH_ALEN);
+	cfg->len = sizeof(*cfg);
+
+	/* Clear bit 0x36C.23 and 0x36C.22 */
+	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+	mpi_opts &= ~HW_ATL_FW2X_CAP_SLEEP_PROXY;
+	mpi_opts &= ~BIT(CAPS_HI_LINK_DROP);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	err = hw_atl_utils_fw_rpc_call(self, rpc_size);
+	if (err < 0)
+		goto err_exit;
+
+	/* Set bit 0x36C.23 */
+	mpi_opts |= HW_ATL_FW2X_CAP_SLEEP_PROXY;
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+			HW_ATL_FW2X_CAP_SLEEP_PROXY), 1U, 10000U);
+err_exit:
+	return err;
+}
+
+static int aq_fw2x_set_wol_params(struct aq_hw_s *self, u8 *mac)
+{
+	int err = 0;
+	struct fw2x_msg_wol *msg = NULL;
+	u32 mpi_opts;
+
+	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+
+	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+	if (err < 0)
+		goto err_exit;
+
+	msg = (struct fw2x_msg_wol *)rpc;
+
+	msg->msg_id = HAL_ATLANTIC_UTILS_FW2X_MSG_WOL;
+	msg->magic_packet_enabled = true;
+	memcpy(msg->hw_addr, mac, ETH_ALEN);
+
+	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+	mpi_opts &= ~(HW_ATL_FW2X_CAP_SLEEP_PROXY | HW_ATL_FW2X_CAP_WOL);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	err = hw_atl_utils_fw_rpc_call(self, sizeof(*msg));
+	if (err < 0)
+		goto err_exit;
+
+	/* Set bit 0x36C.24 */
+	mpi_opts |= HW_ATL_FW2X_CAP_WOL;
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+			HW_ATL_FW2X_CAP_WOL), 1U, 10000U);
+err_exit:
+	return err;
+}
+
+static int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,
+			     u8 *mac)
+{
+	int err = 0;
+
+	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
+		err = aq_fw2x_set_sleep_proxy(self, mac);
+		if (err < 0)
+			goto err_exit;
+		err = aq_fw2x_set_wol_params(self, mac);
+		if (err < 0)
+			goto err_exit;
+	}
+err_exit:
+	return err;
+}
+
+static int aq_fw2x_set_eee_rate(struct aq_hw_s *self, u32 speed)
+{
+	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+	mpi_opts &= ~(HW_ATL_FW2X_CAP_EEE_1G_MASK |
+		HW_ATL_FW2X_CAP_EEE_2G5_MASK | HW_ATL_FW2X_CAP_EEE_5G_MASK |
+		HW_ATL_FW2X_CAP_EEE_10G_MASK);
+
+	mpi_opts |= eee_mask_to_fw2x(speed);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	return 0;
+}
+
+static int aq_fw2x_get_eee_rate(struct aq_hw_s *self, u32 *rate,
+				u32 *supported_rates)
+{
+	int err = 0;
+	u32 caps_hi;
+	u32 mpi_state;
+
+	err = hw_atl_utils_fw_downld_dwords(self,
+				self->mbox_addr +
+				offsetof(struct hw_aq_atl_utils_mbox, info) +
+				offsetof(struct hw_aq_info, caps_hi),
+				&caps_hi,
+				sizeof(caps_hi)/sizeof(u32));
+
+	if (err)
+		return err;
+
+	*supported_rates = fw2x_to_eee_mask(caps_hi);
+
+	mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR);
+	*rate = fw2x_to_eee_mask(mpi_state);
+
+	return err;
+}
+
+static int aq_fw2x_renegotiate(struct aq_hw_s *self)
+{
+	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+
+	mpi_opts |= BIT(CTRL_FORCE_RECONNECT);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+
+	return 0;
+}
+
+static int aq_fw2x_set_flow_control(struct aq_hw_s *self)
+{
+	u32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+
+	aq_fw2x_set_mpi_flow_control(self, &mpi_state);
+
+	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);
+
+	return 0;
+}
+
+const struct aq_fw_ops aq_fw_2x_ops = {
+	.init               = aq_fw2x_init,
+	.deinit             = aq_fw2x_deinit,
+	.reset              = NULL,
+	.renegotiate        = aq_fw2x_renegotiate,
+	.get_mac_permanent  = aq_fw2x_get_mac_permanent,
+	.set_link_speed     = aq_fw2x_set_link_speed,
+	.set_state          = aq_fw2x_set_state,
+	.update_link_status = aq_fw2x_update_link_status,
+	.update_stats       = aq_fw2x_update_stats,
+	.set_power          = aq_fw2x_set_power,
+	.get_temp           = aq_fw2x_get_temp,
+	.get_cable_len      = aq_fw2x_get_cable_len,
+	.set_eee_rate       = aq_fw2x_set_eee_rate,
+	.get_eee_rate       = aq_fw2x_get_eee_rate,
+	.set_flow_control   = aq_fw2x_set_flow_control,
+};
diff --git a/drivers/net/ethernet/aquantia/release_notes.txt b/drivers/net/ethernet/aquantia/release_notes.txt
new file mode 100644
index 00000000..62c8006
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/release_notes.txt
@@ -0,0 +1,276 @@
+Release: 2.0.10.0
+Date: 03/05/2018
+tag: v2.0.10
+================================
+* RM2691: Kernel 2.x support (experimental)
+* RM2692: Linux DKMS packaging
+* RM2698: ethtool negotiate restart should be implemented
+* RM2736: ethtool ring size dynamic change
+* RM2734: EEE settings are lost after link down/up
+* RM2765: Linux driver must support WOL from shutdown
+* RM2697: WoL works in wrong way with FW3.x DW
+* RM2693: Pause frame (flow control) configuration should be done via ethtool
+* RH-1542881 Declare vlan_features bits:
+  http://gitlab.rdc.aquantia.com/drv/Linux/merge_requests/62
+* Leftover bugfixes (msi isr)
+  http://gitlab.rdc.aquantia.com/drv/Linux/merge_requests/61
+
+Release: 2.0.9.0
+Date: 18/04/2018
+tag: v2.0.9
+================================
+* RM2738: Fix RHEL7.5 incompatibility
+
+Release: 2.0.8.0
+Date: 11/04/2018
+tag: v2.0.8
+================================
+* 199177: ASUS XG-C100C 10G Network Adapter no longer working since 4.16
+  FW 1.5.44 and reset sequence collision
+  https://bugzilla.kernel.org/show_bug.cgi?id=199177
+  http://gitlab.rdc.aquantia.com/drv/Linux/merge_requests/54
+
+Release: 2.0.7.0
+Date: 05/04/2018
+tag: v2.0.7
+================================
+* RM2544 Need to make EEE feature configurable with ethtool
+* RM2676 net: aquantia: take care when shutdown on already stopped device
+* RM2667 Disable Dirty Wake on shutdown and suspend
+* (misc) netdev comments 4.16 rc6
+* readme updates on installation
+
+Release: 2.0.6.0
+Date: 15/03/2018
+tag: v2.0.6
+================================
+* RM2574 Post fix (R.Volkov found)
+* Shutdown pci callback closes the link (Synology NAS issues)
+* Introduce rx refill threshold parameter: aq_rx_refill_thres
+
+Release: 2.0.5.0
+Date: 06/03/2018
+tag: v2.0.5
+================================
+* RM2574 B1 hardware never indicates mailbox ready
+* RM2573 Flow control must be enabled by deffault
+* RM2543 Linux driver must set link_drop bit when interface is down
+* Buffer flip&reuse implementation
+  http://gitlab.rdc.aquantia.com/drv/Linux/merge_requests/41
+
+Release: 2.0.4.0
+Date: 16/02/2018
+tag: v2.0.4
+================================
+* RM2508 Indication of the WOL state does not work correctly
+* RM2520 WOL in 2.0.3.0 Linux driver dosn't work with B0 cards
+* RM2512 No traffic on FW 1.5.58 with 2x Linux driver
+* Wrong MTU size checks (< Min or > Max) are now working again on linuxes < 4.10
+* Fix compilation on linux 3.16
+* Reset sequence fix: RBL secure chip reset sequence have to reset SPI
+* RM2536 allow Live MAC change
+* napi_alloc_skb improves performance on high packet rates
+
+Release: 2.0.3.0
+Date: 29/01/2018
+tag: v2.0.3
+================================
+* netdev syncup
+* RM2209: WOL feature (magic packet only)
+* Cable length and temp diagnostics data in sysfs
+* RM2370 Errors are appear during uninstalation linux driver
+
+Upstream Release: 2.0.2.1-kern
+kernel: 4.16
+================================
+d28e9d1 net: aquantia: driver version bump
+fd8221f net: aquantia: Implement pci shutdown callback
+a1c1d63 net: aquantia: Allow live mac address changes
+33a3d54 net: aquantia: Add aq_tx_clean_budget and valid budget handling logic
+002594f net: aquantia: Change inefficient wait loop on fw data reads
+b8d7ecb net: aquantia: Fix a regression with reset on old firmware
+c0a6a02 net: aquantia: Fix hardware reset when SPI may rarely hangup
+
+Release 2.0.2.0
+Upstream: 2.0.2-kern
+tag: v2.0.2
+25/01/2018 f/w 1.x, 2.9.x, 3.x or above
+================================
+* netdev syncup: Do not reset curr_stats on each up/down
+* netdev syncup: typo Octects
+* RM2420:Wrong felicity IDs and link speeds reported
+
+Release 2.0.1.0
+tag: v2.0.1
+30/11/2017 f/w 1.x, 2.9.x, 3.x or above
+================================
+*RM2267:Statistics mistakes and errors
+*RM2128:... PCI errors and NMI
+
+Release 2.0.0.0
+tag: v2.0.0
+17/11/2017 f/w 1.x, 2.9.x, 3.x or above
+================================
++ Reset sequence implemented
+* MAC address readout fixed
+
+Release 2.0.0.0-alpha2
+tag: v2.0.0-alpha2
+11/11/2017 f/w 3.0.3 or above
+================================
+* kernel 3.x build fixed
+
+Release 2.0.0.0-alpha1
+tag: v2.0.0-alpha1
+10/11/2017 f/w 3.0.3 or above
+================================
++ Initial support for both 1.x, 2.x and 3.x FW
+* 64bit wide statistics in ethtool
+! Full reset sequence is not yet implemented
+! Link status is polled, no isr usage yet
+
+
+
+
+
+
+Release 1.6.12.0 master 10_09-2017 f/w 1.5.14 or above
+=============
++QNAP requesting ethtool -c option (#2053)
+*Statistics never gets zeroed upon interface down/up (#2015)
+*Non optimal Interrupt Moderation Rates default settings makes udp very slow (#2041)
+
+Release 1.6.11.0 master 09_25-2017 f/w 1.5.14 or above
+=============
+*Link state is up right after link up command execution for 2 seconds then link goes down (#2033)
+*Netnext mainline syncup
+
+Release 1.6.10.0 master 09_20-2017 f/w 1.5.14 or above
+=============
+*Invalid queue state management causes Tx/Rx to die (#1941)
+*kernel mainline driver does not support jumbo frames (#1985)
+
+Release 1.6.9.0 rel-dev-1.6.9 08_11-2017 f/w 1.5.14 or above
+=============
+*MSM counters are not reset after driver is unloaded/loaded. (#1619).
+*Kernel panic/memory corruption on multicast > 32 (#1864).
+*Incorrect Interrupt moderation values assignment in linux driver (#1918).
+*Fix for enabling incorrect interrupt vectors count on Puma 7 Intel SoC (with Linux Kernel 3.10).
+*Removed unuseful spinlocks from datapath.
+*Minor fixes.
+
+Release 1.6.8.0 rel-dev 07_05-2017 f/w 1.5.14 or above
+=============
+*Fix for RX datapath initialization.
+*Minor fixes.
+
+Release 1.6.7.0 rel-dev 05_05-2017 f/w 1.5.14 or above
+=============
+*Synced with linux sources tree.
+*Support for GRO
+*Fixed Ethtool -S crash
+*Support for kernels >= 3.10
+*Minor fixes.
+
+Release 1.6.2.0 rel-kernel-arm 03_16-2017 f/w 1.5.14 or above
+=============
+*Synced with linux sources tree.
+*Fixed checksumm offloads for IPv6.
+*Added support for ARM.
+*Support for kernels 4.4, 4.8, 4.9
+*Minor fixes.
+
+Release 1.5.345.0 rel-kernel-b0-v3 01_19-2017 f/w 1.5.14 or above
+=============
+*Linux upstream fixes
+*Add fw version checking
+*Fix pm-resume crash.
+
+Release 1.5.335.0 rel-kernel-b0-v3 01_09-2017 f/w 1.5.14 or above
+=============
+*Linux upstream fixes
+
+Release 1.5.324.0 dev-pb-b0-cln-2 12_17-2016 f/w 1.5.14 or above
+=============
+*hibernate fix
+*Minor fixes and code cleanup
+
+Release 1.5.300.0 dev-pb-b0-cln 12_06-2016 f/w 1.5.14 or above
+=============
+*d109 pid support
+*Minor fixes and code cleanup
+
+
+Release 1.5.248.3 dev-pb-b0-clean 11-30-2016 f/w 1.5.14 or above
+=============
+* fix change link speed while NIC down.
+
+Release 1.5.247.3 dev-pb-b0-clean 11-30-2016 f/w 1.5.14 or above
+=============
+* fix netif status
+
+Release 1.5.246.3 dev-pb-b0-clean 11-29-2016 f/w 1.5.14 or above
+=============
++Felicity PID support
+*Updated TX/RX throttling params
+*Minor fixes and code cleanup
+
+Release 1.5.245.3 dev-pb-b0-clean 11-23-2016 f/w 1.5.14 or above
+=============
++CSO error workaround (Bug #701)
++ifconfig filter support (promisc/multicast/broadcast/allmulti)
++Minor fixes and code cleanup
+
+
+Release 1.5.244.3 dev-pb-b0-clean 11-19-2016 f/w 1.5.14 or above
+============
+* Fix #701 workaround 
+
+Release 1.5.243.3 dev-pb-b0-clean 11-16-2016 f/w 1.5.14 or above
+============
++improved ethtool statistics
+
+Release 1.5.239.3 dev-pb-b0-clean 11-11-2016 f/w 1.5.14 or above
+============
++NAPI compliance fix
++Hot unplug fix
++Minor fixes and code cleanup
+
+
+
+Release 1.5.210.3 dev-pb-b0-clean 11-03-2016 f/w 1.5.14 or above
+============
++Fixed Jumbo frames.
++RSS fixes (new hash key, print RSS settings via ethtool)
++Minor fixes and code cleanup
+
+Release 1.5.203.3 dev-pb-b0-clean 10-31-2016 f/w 1.5.14 or above
+=============
++Support SuseServer 12.1
++Fixed kernel panic on CentOS 7.
+
+
+Release 1.5.201.3 dev-pb-b0-clean 10-29-2016 f/w 1.5.14 or above
+=============
++Support Centos
++Minor fixes and code cleanup
+
+Release 1.5.200.3 dev-pb-b0-clean 10-29-2016 f/w 1.5.10 or above
+=============
++Support new VID/PID.
++Fixed and tested the driver for B0 on FPGA.
++Support LRO for B0 on FPGA.
++Fixed link status detect.
+
+Known issues:
+- Build failed on Centos
+
+
+Release 1.5.100.3 10-22-2016 f/w 1.4 or above
+=============
++ Ethtool statistics
+* Debian 6 kernel build
+* A0/B0 support
+
+Know issues:
+- Link status hardcoded always '1G connected'
diff --git a/drivers/net/ethernet/aquantia/rpm-src.spec b/drivers/net/ethernet/aquantia/rpm-src.spec
new file mode 100644
index 00000000..cca9593
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/rpm-src.spec
@@ -0,0 +1,40 @@
+Summary: AQtion Ethernet driver
+Name: Atlantic
+Vendor: aQuantia Corporation
+Version: %{rawver}
+Release: 1
+License: GPLv2
+Group: System Environment/Kernel
+Provides: %{name}
+URL:   http://www.aquantia.com/
+BuildRoot: %{_tmppath}/%{name}-%{version}-root
+BuildArch: noarch
+
+%description
+This package contains aQuantia AQtion Ethernet Linux driver
+
+%prep
+rm -rf Linux/.git
+
+%build
+
+%clean
+rm -rf %{buildroot}
+
+%post
+cd /var/build_aq_drv/%{version}/Linux
+make clean
+make
+make install
+
+%preun
+rm -f /lib/modules/$(shell uname -r)/aquantia/atlantic.ko
+depmod -a $(shell uname -r)
+
+%install
+mkdir -p $RPM_BUILD_ROOT/var/build_aq_drv/%{version}
+cp -r Linux $RPM_BUILD_ROOT/var/build_aq_drv/%{version}
+
+%files
+%defattr(-,root,root,-)
+/var/build_aq_drv/%{version}/Linux
diff --git a/drivers/net/ethernet/aquantia/ver.h b/drivers/net/ethernet/aquantia/ver.h
new file mode 100644
index 00000000..45ca496
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/ver.h
@@ -0,0 +1,20 @@
+/*
+ * aQuantia Corporation Network Driver
+ * Copyright (C) 2014-2017 aQuantia Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef VER_H
+#define VER_H
+
+#define NIC_MAJOR_DRIVER_VERSION           2
+#define NIC_MINOR_DRIVER_VERSION           0
+#define NIC_BUILD_DRIVER_VERSION           10
+#define NIC_REVISION_DRIVER_VERSION        0
+
+#define AQ_CFG_DRV_VERSION_SUFFIX ""
+
+#endif /* VER_H */
diff --git a/drivers/net/ethernet/realtek/r8125/r8125.h b/drivers/net/ethernet/realtek/r8125/r8125.h
index 520cb45..9f80cc8 100644
--- a/drivers/net/ethernet/realtek/r8125/r8125.h
+++ b/drivers/net/ethernet/realtek/r8125/r8125.h
@@ -1067,7 +1067,11 @@ enum RTL8125_registers {
         ERIAR           = 0x74,
         EPHY_RXER_NUM   = 0x7C,
         EPHYAR          = 0x80,
+        CustomLED2      = 0x84,
+        CustomLED1      = 0x86,
         TimeInt2        = 0x8C,
+        GlobalFeature   = 0x94,
+        CustomLED3      = 0x96,
         OCPDR           = 0xB0,
         MACOCP          = 0xB0,
         OCPAR           = 0xB4,
diff --git a/drivers/net/ethernet/realtek/r8125/r8125_n.c b/drivers/net/ethernet/realtek/r8125/r8125_n.c
index 571e0a2..9a1b03a 100644
--- a/drivers/net/ethernet/realtek/r8125/r8125_n.c
+++ b/drivers/net/ethernet/realtek/r8125/r8125_n.c
@@ -86,6 +86,10 @@
 #include <linux/seq_file.h>
 #endif
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include "buffalo/kernevnt.h"
+#endif
+
 /* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
    The RTL chips use a 64 element hash table based on the Ethernet CRC. */
 static const int multicast_filter_limit = 32;
@@ -2855,6 +2859,27 @@ static int rtl8125_disable_eee_plus(struct rtl8125_private *tp)
                         rtl8125_hw_start(dev);
 
                         netif_carrier_on(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+                        {
+                                u16 status = RTL_R16(tp, PHYstatus);
+                                int duplex = 1;
+                                int speed = 0;
+                                if (status & LinkStatus) {
+                                        /*link on*/
+                                        if (status & _2500bpsF)
+                                                speed = 2500;
+                                        else if (status & _1000bpsF)
+                                                speed = 1000;
+                                        else if (status & _100bps)
+                                                speed = 100;
+                                        else if (status & _10bps)
+                                                speed = 10;
+
+                                        duplex = ((status & (_1000bpsF | _2500bpsF)) || (status & FullDup)) ? 1 : 0;
+                                }
+                                kernevnt_LanAct_params(dev->name, speed, duplex);
+                        }
+#endif
 
                         netif_wake_queue(dev);
 
@@ -2878,6 +2903,9 @@ static int rtl8125_disable_eee_plus(struct rtl8125_private *tp)
                         netif_stop_queue(dev);
 
                         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+                        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
 
                         rtl8125_hw_reset(dev);
 
@@ -8736,6 +8764,15 @@ static inline void rtl8125_request_link_timer(struct net_device *dev)
                 break;
         }
 
+        // Buffalo-custom
+        // RED-LED(LED1) : 10M/100M/2.5G bright up (BIT 0/1/5)
+        // GRREN-LED(LED2) : 1G bright up (BIT 3)
+        RTL_W8(tp, GlobalFeature, 0x0);
+        RTL_W16(tp, CustomLED, 0x0 );
+        RTL_W16(tp, CustomLED1, BIT_9 | BIT_5 | BIT_1 | BIT_0 );
+        RTL_W16(tp, CustomLED2, BIT_9 | BIT_3 );
+        RTL_W16(tp, CustomLED3, 0x0 );
+
         tp->NicCustLedValue = RTL_R16(tp, CustomLED);
 
         rtl8125_get_hw_wol(dev);
@@ -9971,6 +10008,9 @@ static int ethtool_ioctl(struct ifreq *ifr)
                 printk(KERN_ERR "%s: esd_flag = 0x%04x\n.\n", dev->name, tp->esd_flag);
                 netif_stop_queue(dev);
                 netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+                kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
                 rtl8125_hw_reset(dev);
                 rtl8125_tx_clear(tp);
                 rtl8125_rx_clear(tp);
@@ -10203,6 +10243,9 @@ static void rtl8125_disable_msi(struct pci_dev *pdev, struct rtl8125_private *tp
         device_set_wakeup_enable(&pdev->dev, tp->wol_enabled);
 
         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
 
         printk("%s", GPL_CLAIM);
 
@@ -10858,6 +10901,9 @@ static int rtl8125_open(struct net_device *dev)
 
         netif_stop_queue(dev);
         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
         rtl8125_hw_config(dev);
         spin_unlock_irqrestore(&tp->lock, flags);
 
@@ -11254,6 +11300,9 @@ static void rtl8125_reset_task(struct work_struct *work)
         spin_lock_irqsave(&tp->lock, flags);
         netif_stop_queue(dev);
         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
         rtl8125_hw_reset(dev);
         spin_unlock_irqrestore(&tp->lock, flags);
 
@@ -12164,6 +12213,9 @@ static void rtl8125_down(struct net_device *dev)
         spin_lock_irqsave(&tp->lock, flags);
 
         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
 
         rtl8125_hw_reset(dev);
 
@@ -12296,6 +12348,9 @@ net_device_stats *rtl8125_get_stats(struct net_device *dev)
         netif_stop_queue(dev);
 
         netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+        kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
 
         netif_device_detach(dev);
 
diff --git a/drivers/net/ethernet/realtek/r8169soc.c b/drivers/net/ethernet/realtek/r8169soc.c
index 67a702b..24bbce8 100644
--- a/drivers/net/ethernet/realtek/r8169soc.c
+++ b/drivers/net/ethernet/realtek/r8169soc.c
@@ -68,6 +68,10 @@
 #define IDAC_FINE_DEFAULT	0x77
 #endif /* CONFIG_ARCH_RTD139x | CONFIG_ARCH_RTD16xx | CONFIG_ARCH_RTD13xx */
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include "buffalo/kernevnt.h"
+#endif
+
 #define RTL8169_VERSION "2.6.0LK-NAPI"
 #define MODULENAME "r8169"
 #define PFX MODULENAME ": "
@@ -1073,6 +1077,11 @@ struct rtl8169_private {
 	bool eee_enable; /* 0: disable, 1: enable */
 	bool acp_enable; /* 0: disable, 1: enable */
 	bool ext_phy;
+
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	u8  duplex;
+	u16 speed;
+#endif
 };
 
 MODULE_AUTHOR("Realtek and the Linux r8169 crew <netdev@vger.kernel.org>");
@@ -1993,10 +2002,17 @@ static void __rtl8169_check_link_status(struct net_device *dev,
 		if (pm)
 			pm_request_resume(&tp->pdev->dev);
 		netif_carrier_on(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		kernevnt_LanAct_params(dev->name, tp->speed, tp->duplex ? 1 : 0);
+#endif
+
 		if (net_ratelimit())
 			netif_info(tp, ifup, dev, "link up\n");
 	} else {
 		netif_carrier_off(dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		kernevnt_LanAct_params(dev->name, 0, 1);
+#endif
 		netif_info(tp, ifdown, dev, "link down\n");
 		if (pm)
 			pm_schedule_suspend(&tp->pdev->dev, 5000);
@@ -2254,6 +2270,11 @@ static int rtl8169_set_speed(struct net_device *dev,
 	if (ret < 0)
 		goto out;
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	tp->duplex = duplex;
+	tp->speed = speed;
+#endif
+
 	if (netif_running(dev)) {
 		//mod_timer(&tp->timer, jiffies + RTL8169_PHY_TIMEOUT);
 	}
@@ -7970,7 +7991,7 @@ static void rtl8169_netpoll(struct net_device *dev)
 {
 	struct rtl8169_private *tp = netdev_priv(dev);
 
-	rtl8169_interrupt(tp->pdev->irq, dev);
+	rtl8169_interrupt(dev->irq, dev);
 }
 #endif
 
@@ -11651,6 +11672,11 @@ static void r8169soc_eee_init(struct rtl8169_private *tp, bool enable)
 	#endif /* CONFIG_ARCH_RTD129x | CONFIG_ARCH_RTD139x |
 		  CONFIG_ARCH_RTD16xx | CONFIG_ARCH_RTD13xx */
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	tp->duplex = 0;
+	tp->speed = 0;
+#endif
+
 	mii = &tp->mii;
 	mii->dev = ndev;
 	mii->mdio_read = rtl_mdio_read;
@@ -12039,6 +12065,9 @@ static void r8169soc_eee_init(struct rtl8169_private *tp, bool enable)
 //		pm_runtime_put_noidle(&pdev->dev);
 
 	netif_carrier_off(ndev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	kernevnt_LanAct_params(ndev->name, 0, 1);
+#endif
 
 	/* Yukuen: Add for link status uevent. 20150206 */
 	init_waitqueue_head(&tp->thr_wait);
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 5fde8e3..88d1137 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -35,6 +35,9 @@
 #include <linux/io.h>
 #include <linux/uaccess.h>
 #include <linux/atomic.h>
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include "buffalo/kernevnt.h"
+#endif
 
 #include <asm/irq.h>
 
@@ -953,6 +956,45 @@ void phy_start(struct phy_device *phydev)
 }
 EXPORT_SYMBOL(phy_start);
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+extern int phy_deferred_linkdown;
+/* phy_adjust_link() : wrapper of phydev->adjust_link() function to generate
+ * 'lanact' kernelevent by generic way.
+ */
+static void phy_adjust_link(struct phy_device *phydev)
+{
+	struct net_device *netdev = phydev->attached_dev;
+	int new_state = 0;
+	unsigned int max_linkdown = max(phy_deferred_linkdown, 1);
+
+	BUG_ON(!netdev);
+	phydev->adjust_link(netdev);
+	/* prepare for called just after initialization */
+	if (phydev->state_cache.downcnt == ~0U) {
+		phydev->state_cache.downcnt = max_linkdown;
+	}
+	if (phydev->link) {
+		/* issue event when link-down count was expired */
+		new_state += (phydev->link != phydev->state_cache.link);
+		new_state += (phydev->speed != phydev->state_cache.speed);
+		new_state += (phydev->duplex != phydev->state_cache.duplex);
+		phydev->state_cache.link = 1;
+		phydev->state_cache.downcnt = 0;
+		phydev->state_cache.speed = phydev->speed;
+		phydev->state_cache.duplex = phydev->duplex;
+	} else {
+		/* issue event only when link-down count was overflow */
+		phydev->state_cache.downcnt++;
+		if (phydev->state_cache.downcnt >= max_linkdown) {
+			new_state += (phydev->state_cache.link != 0);
+			phydev->state_cache.link = 0;
+		}
+	}
+	if (new_state) {
+		kernevnt_LanAct(phydev);
+	}
+}
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 /**
  * phy_state_machine - Handle the state machine
  * @work: work_struct that describes the work to be done
@@ -995,7 +1037,11 @@ void phy_state_machine(struct work_struct *work)
 		if (!phydev->link) {
 			phydev->state = PHY_NOLINK;
 			netif_carrier_off(phydev->attached_dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+			phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			break;
 		}
 
@@ -1008,7 +1054,11 @@ void phy_state_machine(struct work_struct *work)
 		if (err > 0) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+			phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 
 		} else if (0 == phydev->link_timeout--)
 			needs_aneg = true;
@@ -1035,8 +1085,15 @@ void phy_state_machine(struct work_struct *work)
 			}
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+			/* everytime call adjust_link */
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		}
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		phy_adjust_link(phydev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		break;
 	case PHY_FORCING:
 		err = genphy_update_link(phydev);
@@ -1051,7 +1108,11 @@ void phy_state_machine(struct work_struct *work)
 				needs_aneg = true;
 		}
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		break;
 	case PHY_RUNNING:
 		/* Only register a CHANGE if we are polling and link changed
@@ -1089,7 +1150,11 @@ void phy_state_machine(struct work_struct *work)
 			netif_carrier_off(phydev->attached_dev);
 		}
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 
 		if (phy_interrupt_is_valid(phydev))
 			err = phy_config_interrupt(phydev,
@@ -1099,7 +1164,11 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->link = 0;
 			netif_carrier_off(phydev->attached_dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+			phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			do_suspend = true;
 		}
 		break;
@@ -1123,7 +1192,11 @@ void phy_state_machine(struct work_struct *work)
 				} else	{
 					phydev->state = PHY_NOLINK;
 				}
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+				phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 				phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			} else {
 				phydev->state = PHY_AN;
 				phydev->link_timeout = PHY_AN_TIMEOUT;
@@ -1139,7 +1212,11 @@ void phy_state_machine(struct work_struct *work)
 			} else	{
 				phydev->state = PHY_NOLINK;
 			}
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+			phy_adjust_link(phydev);
+#else /*CONFIG_BUFFALO_USE_KERNEVNT*/
 			phydev->adjust_link(phydev->attached_dev);
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 		}
 		break;
 	}
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index b131e55..36dc943 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -40,6 +40,11 @@
 MODULE_DESCRIPTION("PHY library");
 MODULE_AUTHOR("Andy Fleming");
 MODULE_LICENSE("GPL");
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+int phy_deferred_linkdown = 1;
+module_param_named(deferred_linkdown, phy_deferred_linkdown, int, 0600);
+MODULE_PARM_DESC(deferred_linkdown, "Max linkdown count for lanact event");
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 
 void phy_device_free(struct phy_device *phydev)
 {
@@ -333,6 +338,12 @@ struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 	dev->asym_pause = 0;
 	dev->link = 1;
 	dev->interface = PHY_INTERFACE_MODE_GMII;
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	dev->state_cache.speed = 0;
+	dev->state_cache.duplex = -1;
+	dev->state_cache.link = 1;
+	dev->state_cache.downcnt = ~0U;
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 
 	dev->autoneg = AUTONEG_ENABLE;
 
diff --git a/drivers/pwm/pwm-rtk.c b/drivers/pwm/pwm-rtk.c
index f831ec3..fc08969 100644
--- a/drivers/pwm/pwm-rtk.c
+++ b/drivers/pwm/pwm-rtk.c
@@ -495,6 +495,12 @@ static ssize_t pwm_store_enable(struct device *dev, struct device_attribute *att
 	pc->enable[hwpwm] = value;
 	pwm_set_register(pc, hwpwm);
 
+	if ( value ){
+		rtk_pwm_enable_pins( pc, hwpwm );
+	} else {
+		rtk_pwm_disable_pins( pc, hwpwm );
+	}
+
 	PWM_DEBUG("%s %s  ====  done \n",
 		DEV_NAME, __func__);
 	return count;
@@ -1144,9 +1150,13 @@ static int rtd1295_pwm_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	for (i=0; i<NUM_PWM; i++)
+	for (i=0; i<NUM_PWM; i++){
 		pwm_set_register(pwm, i);
 
+		if( pwm->enable[i]==1 )
+			rtk_pwm_enable_pins(pwm, i);
+	}
+
 	PWM_DEBUG("%s %s --  done! !\n", DEV_NAME, __func__);
 
 	return 0;
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index c7b7700..0458692 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1607,6 +1607,10 @@ static int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 
 	/* Store the LUN value in cmnd, if needed. */
 	if (cmd->device->lun_in_cdb)
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+		/* support for AVU2 */
+		if (cmd->device->ignore_lun || !(cmd->cmnd[0] & 0xc0))
+#endif /* CONFIG_BUFFALO_IGNORE_LUN */
 		cmd->cmnd[1] = (cmd->cmnd[1] & 0x1f) |
 			       (cmd->device->lun << 5 & 0xe0);
 
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 27a6d3c..255e2c5 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1320,6 +1320,9 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 	struct Scsi_Host *shost = dev_to_shost(&starget->dev);
 	int ret = 0;
 
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+	return 1;
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 	/*
 	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.
 	 * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 3a6f557..5d92d10 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -624,6 +624,9 @@ static int scsi_sdev_check_buf_bit(const char *buf)
 sdev_rd_attr (vendor, "%.8s\n");
 sdev_rd_attr (model, "%.16s\n");
 sdev_rd_attr (rev, "%.4s\n");
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+sdev_rw_attr (ignore_lun, "%d\n");
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 
 static ssize_t
 sdev_show_device_busy(struct device *dev, struct device_attribute *attr,
@@ -1123,6 +1126,9 @@ static umode_t scsi_sdev_bin_attr_is_visible(struct kobject *kobj,
 	&dev_attr_vendor.attr,
 	&dev_attr_model.attr,
 	&dev_attr_rev.attr,
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+	&dev_attr_ignore_lun.attr,
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 	&dev_attr_rescan.attr,
 	&dev_attr_delete.attr,
 	&dev_attr_state.attr,
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 4864275..f2c8dfd 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -3017,6 +3017,10 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 	gd->fops = &sd_fops;
 	gd->private_data = &sdkp->driver;
 	gd->queue = sdkp->device->request_queue;
+#ifdef CONFIG_BUFFALO_IOERRS
+	gd->io_errors = 0;
+	gd->limit_io_errors = 1000;	/* default limit *//* XXX: should use MAXERR_CNT_DEFAULT in dirivers/md/md.h ? but it is not reasonable to include drivers/md/md.h ... */
+#endif	/* CONFIG_BUFFALO_IOERRS */
 
 	/* defaults, until the device tells us otherwise */
 	sdp->sector_size = 512;
diff --git a/drivers/scsi/sd.h b/drivers/scsi/sd.h
index c8d9863..9e110e5 100644
--- a/drivers/scsi/sd.h
+++ b/drivers/scsi/sd.h
@@ -11,7 +11,11 @@
 /*
  * Time out in seconds for disks and Magneto-opticals (which are slower).
  */
+#ifdef CONFIG_BUFFALO_PLATFORM
+#define SD_TIMEOUT		(120 * HZ)
+#else	/* CONFIG_BUFFALO_PLATFORM */
 #define SD_TIMEOUT		(30 * HZ)
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 #define SD_MOD_TIMEOUT		(75 * HZ)
 /*
  * Flush timeout is a multiplier over the standard device timeout which is
diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 04d2b6e..d2816e5 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -46,6 +46,18 @@
 #include <target/iscsi/iscsi_target_stat.h>
 
 #include <target/iscsi/iscsi_transport.h>
+#ifdef CONFIG_BUFFALO_PLATFORM
+#include <linux/proc_fs.h>
+#endif /*CONFIG_BUFFALO_PLATFORM*/
+#ifdef MODULE
+/* To avoid link-error caused by 64-bit dividend in module. */
+#ifdef __arm__
+u_int64_t __aeabi_uldivmod(u_int64_t a, u_int64_t b)
+{
+	return div64_u64(a, b);
+}
+#endif /*__arm__*/
+#endif /*MODULE*/
 
 static LIST_HEAD(g_tiqn_list);
 static LIST_HEAD(g_np_list);
@@ -690,6 +702,186 @@ static enum target_prot_op iscsit_get_sup_prot_ops(struct iscsi_conn *conn)
 	.iscsit_get_sup_prot_ops = iscsit_get_sup_prot_ops,
 };
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+static struct proc_dir_entry *proc_iscsi_target_dir_entry = NULL,
+                             *proc_status_dir_entry = NULL,
+                             *proc_session_dir_entry = NULL,
+                             *proc_conn_dir_entry = NULL;
+
+static int session_show(struct seq_file *seq, void *v)
+{
+        struct iscsi_tiqn *tiqn = NULL;
+        struct iscsi_portal_group *tpg = NULL;
+        struct se_session *se_sess = NULL;
+        struct iscsi_session *sess = NULL;
+        struct timespec ts;
+	int inst = 1;
+
+        seq_printf(seq, "inst node sid intr_name tgt_name creation_time\n");
+
+        spin_lock(iscsit_global->tiqn_lock);
+        list_for_each_entry(tiqn, iscsit_global->tiqn_list, tiqn_list) {
+                spin_lock(&tiqn->tiqn_tpg_lock);
+                list_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {
+                        spin_lock(&tpg->tpg_se_tpg.session_lock);
+                        list_for_each_entry(se_sess,
+                                            &tpg->tpg_se_tpg.tpg_sess_list,
+                                            sess_list) {
+                                sess = (struct iscsi_session *)
+                                       se_sess->fabric_sess_ptr;
+				getnstimeofday(&ts);
+                                seq_printf(seq,
+                                               "%d %d %d %s %s %llu\n",
+                                               inst++, tiqn->tiqn_index,
+                                               sess->sid,
+                                               sess->sess_ops->InitiatorName,
+                                               sess->sess_ops->TargetName,
+                                               (ts.tv_sec + ts.tv_nsec / 1000000000) -
+                                               ((get_jiffies_64() - INITIAL_JIFFIES) / HZ) +
+                                               ((sess->creation_time - INITIAL_JIFFIES) / HZ));
+                        }
+                        spin_unlock(&tpg->tpg_se_tpg.session_lock);
+                }
+                spin_unlock(&tiqn->tiqn_tpg_lock);
+        }
+        spin_unlock(iscsit_global->tiqn_lock);
+
+	return 0;
+}
+
+static int session_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, session_show, NULL);
+}
+
+static struct file_operations session_proc_fops = {
+        .owner = THIS_MODULE,
+        .open = session_seq_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release,
+};
+
+static int connection_show(struct seq_file *seq, void *v)
+{
+	struct iscsi_tiqn *tiqn = NULL;
+        struct iscsi_portal_group *tpg = NULL;
+        struct se_session *se_sess = NULL;
+        struct iscsi_session *sess = NULL;
+        struct iscsi_conn *conn = NULL;
+        int inst = 1;
+        struct sockaddr_in6 *sock_in6 = NULL;
+        struct sockaddr_in *sock_in = NULL;
+        char *local_ip = NULL;
+        char *login_ip = NULL;
+        u16 local_port = 0;
+        u16 login_port = 0;
+
+        seq_printf(seq, "inst node sid cid addr_type local_ip local_port rem_ip rem_port\n");
+
+        spin_lock(iscsit_global->tiqn_lock);
+        list_for_each_entry(tiqn, iscsit_global->tiqn_list, tiqn_list) {
+                spin_lock(&tiqn->tiqn_tpg_lock);
+                list_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {
+                        spin_lock(&tpg->tpg_se_tpg.session_lock);
+                        list_for_each_entry(se_sess,
+                                            &tpg->tpg_se_tpg.tpg_sess_list,
+                                            sess_list) {
+                                sess = (struct iscsi_session *)
+                                       se_sess->fabric_sess_ptr;
+                                list_for_each_entry(conn,
+                                                    &sess->sess_conn_list,
+                                                    conn_list) {
+                                        if (conn->login_family == AF_INET6) {
+                                                sock_in6 = (struct sockaddr_in6 *)&conn->local_sockaddr;
+                                                local_ip = (char*)&sock_in6->sin6_addr;
+                                                local_port = ntohs(sock_in6->sin6_port);
+                                                sock_in6 = (struct sockaddr_in6 *)&conn->login_sockaddr;
+                                                login_ip = (char*)&sock_in6->sin6_addr;
+                                                login_port = ntohs(sock_in6->sin6_port);
+                                        } else {
+                                                sock_in = (struct sockaddr_in *)&conn->local_sockaddr;
+                                                local_ip = (char*)&sock_in->sin_addr;
+                                                local_port = ntohs(sock_in->sin_port);
+                                                sock_in = (struct sockaddr_in *)&conn->login_sockaddr;
+                                                login_ip = (char*)&sock_in->sin_addr;
+                                                login_port = ntohs(sock_in->sin_port);
+                                        }
+                                        seq_printf(seq,
+                                               conn->login_family == AF_INET6
+                                                   ? "%d %d %d %d %s %pI6 %d %pI6 %d\n"
+                                                   : "%d %d %d %d %s %pI4 %d %pI4 %d\n",
+                                               inst++, tiqn->tiqn_index,
+                                               sess->sid, conn->cid,
+                                               conn->login_family == AF_INET6 ? "ipv6" : "ipv4",
+                                               local_ip,
+                                               local_port,
+                                               login_ip,
+                                               login_port);
+                                }
+                        }
+                        spin_unlock(&tpg->tpg_se_tpg.session_lock);
+                }
+                spin_unlock(&tiqn->tiqn_tpg_lock);
+        }
+        spin_unlock(iscsit_global->tiqn_lock);
+
+	return 0;
+}
+
+static int connection_seq_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, connection_show, NULL);
+}
+
+static struct file_operations connection_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = connection_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static void create_proc_entries(void)
+{
+	proc_iscsi_target_dir_entry = proc_mkdir("iscsi_target", NULL);
+	if (proc_iscsi_target_dir_entry == NULL) {
+		pr_err("Failed to create proc 'iscsi_target' dir\n");
+	}
+	else {
+		proc_status_dir_entry =
+			proc_mkdir("status", proc_iscsi_target_dir_entry);
+		if (proc_status_dir_entry == NULL) {
+			pr_err("Failed to create proc 'iscsi_target/status' dir\n");
+		}
+		else {
+			proc_session_dir_entry =
+				proc_create("session", 0444,
+                                            proc_status_dir_entry, &session_proc_fops);
+			proc_conn_dir_entry =
+				proc_create("connection", 0444,
+                                            proc_status_dir_entry, &connection_proc_fops);
+		}
+	}
+}
+
+static void remove_proc_entries(void)
+{
+	if (proc_session_dir_entry != NULL) {
+		proc_remove(proc_session_dir_entry);
+	}
+	if (proc_conn_dir_entry != NULL) {
+		proc_remove(proc_conn_dir_entry);
+	}
+	if (proc_status_dir_entry != NULL) {
+		proc_remove(proc_status_dir_entry);
+	}
+	if (proc_iscsi_target_dir_entry != NULL) {
+		proc_remove(proc_iscsi_target_dir_entry);
+	}
+}
+#endif /*CONFIG_BUFFALO_PLATFORM*/
+
 static int __init iscsi_target_init_module(void)
 {
 	int ret = 0, size;
@@ -701,6 +893,12 @@ static int __init iscsi_target_init_module(void)
 		pr_err("Unable to allocate memory for iscsit_global\n");
 		return -1;
 	}
+#ifdef CONFIG_BUFFALO_PLATFORM
+	iscsit_global->tiqn_list = &g_tiqn_list;
+	iscsit_global->np_list = &g_np_list;
+	iscsit_global->tiqn_lock = &tiqn_lock;
+	iscsit_global->np_lock = &np_lock;
+#endif /*CONFIG_BUFFALO_PLATFORM*/
 	spin_lock_init(&iscsit_global->ts_bitmap_lock);
 	mutex_init(&auth_id_lock);
 	spin_lock_init(&sess_idr_lock);
@@ -758,6 +956,9 @@ static int __init iscsi_target_init_module(void)
 
 	if (iscsit_load_discovery_tpg() < 0)
 		goto r2t_out;
+#ifdef CONFIG_BUFFALO_PLATFORM
+	create_proc_entries();
+#endif /*CONFIG_BUFFALO_PLATFORM*/
 
 	return ret;
 r2t_out:
@@ -783,6 +984,9 @@ static int __init iscsi_target_init_module(void)
 
 static void __exit iscsi_target_cleanup_module(void)
 {
+#ifdef CONFIG_BUFFALO_PLATFORM
+	remove_proc_entries();
+#endif /*CONFIG_BUFFALO_PLATFORM*/
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&iscsi_target_transport);
 	kmem_cache_destroy(lio_qr_cache);
diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c
index 9ccd5da..8ffd622 100644
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@ -502,13 +502,14 @@ static int iscsi_login_non_zero_tsih_s1(
  */
 static int iscsi_login_non_zero_tsih_s2(
 	struct iscsi_conn *conn,
-	unsigned char *buf)
+	unsigned char *p)
 {
 	struct iscsi_portal_group *tpg = conn->tpg;
 	struct iscsi_session *sess = NULL, *sess_p = NULL;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
-	struct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;
+	struct iscsi_login_req *pdu = (struct iscsi_login_req *)p;
+	unsigned char buf[32];
 	bool iser = false;
 
 	spin_lock_bh(&se_tpg->session_lock);
diff --git a/drivers/tty/serial/8250/8250_pnp.c b/drivers/tty/serial/8250/8250_pnp.c
index 34f05ed..994f735 100644
--- a/drivers/tty/serial/8250/8250_pnp.c
+++ b/drivers/tty/serial/8250/8250_pnp.c
@@ -436,6 +436,15 @@ static int serial_pnp_guess_board(struct pnp_dev *dev)
 	return -ENODEV;
 }
 
+#ifdef CONFIG_BUFFALO_DISCONIRQ
+static bool __read_mostly conirq_disabled = false;
+static int __init conirq_disabled_setup(char *str)
+{
+	conirq_disabled = true;
+	return 1;
+}
+__setup("disconirq", conirq_disabled_setup);
+#endif /* CONFIG_BUFFALO_DISCONIRQ */
 static int
 serial_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
 {
@@ -451,6 +460,13 @@ static int serial_pnp_guess_board(struct pnp_dev *dev)
 	memset(&uart, 0, sizeof(uart));
 	if (pnp_irq_valid(dev, 0))
 		uart.port.irq = pnp_irq(dev, 0);
+#ifdef CONFIG_BUFFALO_DISCONIRQ
+	if (conirq_disabled && uart.port.irq == 11) {
+		pr_info("%s: overwrite to port.irq from %d to 0\n",
+			__func__, uart.port.irq);
+		uart.port.irq = 0;
+	}
+#endif /* CONFIG_BUFFALO_DISCONIRQ */
 	if ((flags & CIR_PORT) && pnp_port_valid(dev, 2)) {
 		uart.port.iobase = pnp_port_start(dev, 2);
 		uart.port.iotype = UPIO_PORT;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 3b3649d..a2b73e2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -106,6 +106,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 
 	ehci->caps = hcd->regs;
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/*
 	 * ehci_init() causes memory for DMA transfers to be
 	 * allocated.  Thus, any vendor-specific workarounds based on
@@ -230,6 +233,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci->frame_index_bug = 1;
 		break;
 	}
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	/* optional debug port, normally in the first BAR */
 	temp = pci_find_capability(pdev, PCI_CAP_ID_DBG);
@@ -255,6 +261,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* These workarounds need to be applied after ehci_setup() */
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_NEC:
@@ -278,6 +287,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	}
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
@@ -289,6 +301,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			HCS_N_PCC(ehci->hcs_params),
 			HCS_N_PORTS(ehci->hcs_params));
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+		if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 		switch (pdev->vendor) {
 		case 0x17a0:		/* GENESYS */
 			/* GL880S: should be PORTS=2 */
@@ -299,8 +314,14 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			/* NF4: should be PCC=10 */
 			break;
 		}
+#ifdef CONFIG_BUFFALO_PLATFORM
+		}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	}
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	if (pdev->vendor == PCI_VENDOR_ID_STMICRO
 	    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)
@@ -329,6 +350,9 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 
 	retval = ehci_pci_reinit(ehci, pdev);
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 done:
 	return retval;
 }
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 1e24f1a..9608e9d 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -2287,7 +2287,7 @@ static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,
 		if (temp & XHCI_HLC) {
 			xhci_dbg_trace(xhci, trace_xhci_dbg_init,
 					"xHCI 1.0: support USB2 hardware lpm");
-			xhci->hw_lpm_support = 1;
+			xhci->hw_lpm_support = 0;/*LPM disable, fix RUF3-K16GB disconnected problem-200918*/
 		}
 	}
 
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 8cd2926..0dd8eb0 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -510,6 +510,29 @@ void usb_stor_report_bus_reset(struct us_data *us)
 /***********************************************************************
  * /proc/scsi/ functions
  ***********************************************************************/
+#ifdef CONFIG_BUFFALO_SCSI_GUID
+#define GUID(x)			__u32 x[3]
+#define GUID_EQUAL(x, y)	(x[0] == y[0] && x[1] == y[1] && x[2] == y[2])
+#define GUID_CLEAR(x)		x[0] = x[1] = x[2] = 0;
+#define GUID_NONE(x)		(!x[0] && !x[1] && !x[2])
+#define GUID_FORMAT		"%08x%08x%08x"
+#define GUID_ARGS(x)		x[0], x[1], x[2]
+static inline void
+make_guid( __u32 *pg, __u16 vendor, __u16 product, char *serial)
+{
+	pg[0] = (vendor << 16) | product;
+	pg[1] = pg[2] = 0;
+	while (*serial) {
+		pg[1] <<= 4;
+		pg[1] |= pg[2] >> 28;
+		pg[2] <<= 4;
+		if (*serial >= 'a')
+			*serial -= 'a' - 'A';
+		pg[2] |= (*serial <= '9' && *serial >= '0') ? *serial - '0' : *serial - 'A' + 10;
+		serial++;
+	}
+}
+#endif	/* CONFIG_BUFFALO_SCSI_GUID */
 
 static int write_info(struct Scsi_Host *host, char *buffer, int length)
 {
@@ -550,6 +573,34 @@ static int show_info (struct seq_file *m, struct Scsi_Host *host)
 	seq_printf(m, "     Protocol: %s\n", us->protocol_name);
 	seq_printf(m, "    Transport: %s\n", us->transport_name);
 
+#ifdef CONFIG_BUFFALO_SCSI_GUID
+	{
+		char serial[USB_STOR_STRING_LEN];       /* serial number */
+
+		GUID(guid);                     /* Global Unique Identifier */
+		GUID_CLEAR(guid);
+		memset(serial,0,sizeof(serial));
+
+		if (us->pusb_dev->descriptor.iSerialNumber /* && !(flags & US_FL_IGNORE_SER)*/)
+			usb_string(us->pusb_dev,
+				   us->pusb_dev->descriptor.iSerialNumber,
+				   serial, sizeof(serial));
+
+		/* Create a GUID for this device */
+		if (us->pusb_dev->descriptor.iSerialNumber && serial[0]) {
+			/* If we have a serial number, and it's a non-NULL string */
+			make_guid(guid, us->pusb_dev->descriptor.idVendor,
+				  us->pusb_dev->descriptor.idProduct, serial);
+		} else {
+			/* We don't have a serial number, so we use 0 */
+			make_guid(guid, us->pusb_dev->descriptor.idVendor,
+				  us->pusb_dev->descriptor.idProduct, "0");
+		}
+		/* show the GUID of the device */
+		seq_printf(m, "         GUID: " GUID_FORMAT "\n", GUID_ARGS(guid));
+	}
+#endif	/* CONFIG_BUFFALO_SCSI_GUID */
+
 	/* show the device flags */
 	seq_printf(m, "       Quirks:");
 
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 6cb042b..fe15ea5 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -852,7 +852,12 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 	sbi->s_es = es;
 	sb->s_magic = le16_to_cpu(es->s_magic);
 
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if ((sb->s_magic != EXT2_SUPER_MAGIC) &&
+	    (sb->s_magic != MEL_EXT2_SUPER_MAGIC))
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		goto cantfind_ext2;
 
 	/* Set defaults before we parse the mount options */
@@ -947,7 +952,12 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 		}
 		es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
 		sbi->s_es = es;
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+		if ((sb->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) &&
+		    (sb->s_magic != cpu_to_le16(MEL_EXT2_SUPER_MAGIC))) {
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		if (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 			ext2_msg(sb, KERN_ERR, "error: magic mismatch");
 			goto failed_mount;
 		}
@@ -998,7 +1008,12 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 	sbi->s_desc_per_block_bits =
 		ilog2 (EXT2_DESC_PER_BLOCK(sb));
 
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if ((sb->s_magic != EXT2_SUPER_MAGIC) &&
+	    (sb->s_magic != MEL_EXT2_SUPER_MAGIC))
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		goto cantfind_ext2;
 
 	if (sb->s_blocksize != bh->b_size) {
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 3c99fb6..aad188c 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -3,7 +3,7 @@
 
 /*
  * 	genhd.h Copyright (C) 1992 Drew Eckhardt
- *	Generic hard disk header file by  
+ *	Generic hard disk header file by
  * 		Drew Eckhardt
  *
  *		<drew@colorado.edu>
@@ -215,6 +215,14 @@ struct gendisk {
 #endif	/* CONFIG_BLK_DEV_INTEGRITY */
 	int node_id;
 	struct badblocks *bb;
+#ifdef	CONFIG_BUFFALO_IOERRS
+	unsigned io_errors;		/* I/O error counter */
+	unsigned limit_io_errors;	/* I/O error limit */
+#ifdef	CONFIG_BUFFALO_ERRCNT
+	atomic_t nr_errs;		/* number of errors occur during
+					 * Block I/O execution. */
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
 };
 
 static inline struct gendisk *part_to_disk(struct hd_struct *part)
@@ -498,7 +506,7 @@ struct bsd_disklabel {
 	__s16	d_type;			/* drive type */
 	__s16	d_subtype;		/* controller/d_type specific */
 	char	d_typename[16];		/* type name, e.g. "eagle" */
-	char	d_packname[16];			/* pack identifier */ 
+	char	d_packname[16];			/* pack identifier */
 	__u32	d_secsize;		/* # of bytes per sector */
 	__u32	d_nsectors;		/* # of data sectors per track */
 	__u32	d_ntracks;		/* # of tracks per cylinder */
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 867110c..29f4830 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -426,6 +426,14 @@ struct phy_device {
 	u8 mdix;
 
 	void (*adjust_link)(struct net_device *dev);
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+	struct {
+		int speed;
+		int duplex;
+		unsigned link : 1;
+		unsigned downcnt : 31;
+	} state_cache;
+#endif /*CONFIG_BUFFALO_USE_KERNEVNT*/
 };
 #define to_phy_device(d) container_of(to_mdio_device(d), \
 				      struct phy_device, mdio)
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index f2b9a2f..dd5c9fdb 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -208,6 +208,9 @@ struct scsi_device {
 
 	unsigned char		access_state;
 	enum scsi_device_state sdev_state;
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+	int ignore_lun;
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 	unsigned long		sdev_data[0];
 } __attribute__((aligned(sizeof(unsigned long))));
 
diff --git a/include/soc/realtek/memory.h b/include/soc/realtek/memory.h
index 042f4b0..60f8c6b 100755
--- a/include/soc/realtek/memory.h
+++ b/include/soc/realtek/memory.h
@@ -36,15 +36,12 @@
 #define SYS_BOOTCODE_MEMBASE 0
 #endif
 
-#if 0
-#define SYS_BOOTCODE_MEMSIZE (0x00030000)
-#else
 /* https://jira.realtek.com/browse/DHCHERC-1007      */
 /* if not reseve [0x00030000,0x00100000), there are  */
 /* un-expected errors.                               */
 /* Please fix me ASAP in order to free 832KB space.  */
 #define SYS_BOOTCODE_MEMSIZE (0x00100000)
-#endif
+
 #if defined(CONFIG_ARCH_RTD139x) || defined(CONFIG_ARCH_RTD16xx)
 /* 0x0002f000 ~ 0x0001ffff */
 #define RPC_COMM_PHYS (0x0002F000)
@@ -64,24 +61,6 @@
 #define RPC_RINGBUF_PHYS (0x01ffe000)
 #define RPC_RINGBUF_SIZE (0x00004000)
 
-/* 0x02200000 ~ 0x025fffff */
-#if defined(CONFIG_RTK_VMX_ULTRA_RAMFS_VENDOR)
-#define ROOTFS_NORMAL_START (0x20000000)
-#define ROOTFS_NORMAL_SIZE  (0x5A00000) //90MB
-#elif defined(CONFIG_RTK_VMX_ULTRA)
-#define ROOTFS_NORMAL_START (0x4BB00000)
-#define ROOTFS_NORMAL_SIZE  (0x3200000) //50MB
-#else
-#define ROOTFS_NORMAL_START (0x02200000)
-#define ROOTFS_NORMAL_SIZE (0x00400000) //4MB
-#endif
-
-#define ROOTFS_NORMAL_END \
-	(ROOTFS_NORMAL_START + ROOTFS_NORMAL_SIZE)
-/* 0x02200000 ~ 0x02dfffff */
-#define ROOTFS_RESCUE_START (0x02200000)
-#define ROOTFS_RESCUE_SIZE (0x00C00000) //12MB
-#define ROOTFS_RESCUE_END (ROOTFS_RESCUE_START + ROOTFS_RESCUE_SIZE)
 /* 0x02600000 ~ 0x02bfffff */
 #define MEM_SLOT_PHYS_1 (0x02600000)
 #define MEM_SLOT_SIZE_1	 (0x00c00000) // Max : 12M
@@ -98,6 +77,17 @@
 #define MEM_SLOT_FLAG_0 (RTK_FLAG_SCPUACC | RTK_FLAG_ACPUACC | \
         RTK_FLAG_VCPU_FWACC | \
 		RTK_FLAG_HWIPACC)
+
+/* 0x05000000 ~ 0x0f8fffff */
+#define ROOTFS_NORMAL_START (0x05000000)
+#define ROOTFS_NORMAL_SIZE  (0x03200000) //50MB
+#define ROOTFS_NORMAL_END   (ROOTFS_NORMAL_START + ROOTFS_NORMAL_SIZE)
+
+/* 0x05000000 ~ 0x05bfffff */
+#define ROOTFS_RESCUE_START (0x05000000)
+#define ROOTFS_RESCUE_SIZE  (0x00C00000) //12MB
+#define ROOTFS_RESCUE_END   (ROOTFS_RESCUE_START + ROOTFS_RESCUE_SIZE)
+
 /* 0x0f900000 ~ 0x0fdfffff */
 #define ACPU_FIREWARE_PHYS (0x0f900000)
 #define ACPU_FIREWARE_SIZE (0x00500000)
diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h
index 6021c3a..2a9777d4 100644
--- a/include/target/iscsi/iscsi_target_core.h
+++ b/include/target/iscsi/iscsi_target_core.h
@@ -886,6 +886,12 @@ struct iscsit_global {
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
+#ifdef CONFIG_BUFFALO_PLATFORM
+	struct list_head	*tiqn_list;
+	struct list_head	*np_list;
+	spinlock_t		*tiqn_lock;
+	struct mutex		*np_lock;
+#endif /*CONFIG_BUFFALO_PLATFORM*/
 };
 
 static inline u32 session_get_next_ttt(struct iscsi_session *session)
diff --git a/include/uapi/linux/magic.h b/include/uapi/linux/magic.h
index bd01769..b0272fdc 100644
--- a/include/uapi/linux/magic.h
+++ b/include/uapi/linux/magic.h
@@ -20,6 +20,10 @@
 #define EFS_SUPER_MAGIC		0x414A53
 #define EXT2_SUPER_MAGIC	0xEF53
 #define EXT3_SUPER_MAGIC	0xEF53
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+#define MEL_EXT2_SUPER_MAGIC	0xEF54
+#define MEL_EXT3_SUPER_MAGIC	0xEF54
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 #define XENFS_SUPER_MAGIC	0xabba1974
 #define EXT4_SUPER_MAGIC	0xEF53
 #define BTRFS_SUPER_MAGIC	0x9123683E
diff --git a/include/uapi/linux/sysctl.h b/include/uapi/linux/sysctl.h
index e13d480..561114c 100644
--- a/include/uapi/linux/sysctl.h
+++ b/include/uapi/linux/sysctl.h
@@ -868,7 +868,17 @@ enum {
 /* /proc/sys/dev/raid */
 enum {
 	DEV_RAID_SPEED_LIMIT_MIN=1,
+#ifdef CONFIG_BUFFALO_PLATFORM
+	DEV_RAID_SPEED_LIMIT_MAX=2,
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	DEV_RAID_SKIP_RESYNC=3,
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+	DEV_RAID_USE_KERNELEVENT=4,
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
+#else	/* CONFIG_BUFFALO_PLATFORM */
 	DEV_RAID_SPEED_LIMIT_MAX=2
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 };
 
 /* /proc/sys/dev/parport/default */
diff --git a/rtd-1619-sata.dtsi_LS710D b/rtd-1619-sata.dtsi_LS710D
new file mode 100644
index 00000000..74f381b
--- /dev/null
+++ b/rtd-1619-sata.dtsi_LS710D
@@ -0,0 +1,69 @@
+#include <dt-bindings/reset/rtk,reset-rtd16xx.h>
+#include <dt-bindings/clock/rtk,clock-rtd16xx.h>
+/ {
+	/include/ "rtd-16xx-sata.dtsi"
+
+	sata_phy: sata_phy@9803FF60 {
+		clocks = <&clk_en_4 CLK_EN_SATA_WRAP_SYS>,
+			<&clk_en_4 CLK_EN_SATA_WRAP_SYSH>;
+		resets = <&crst RSTN_SATA_WRAP>;
+		sata-phy@0 {
+			reg = <0>;
+			resets = <&crst RSTN_SATA_MDIO0>,
+				<&crst RSTN_SATA_PHY_POW0>;
+			spread-spectrum = <0>;
+			phy-param = <0x70000211>, <0x70004211>, <0x70008211>,
+				<0x336a0511>, <0x336a4511>, <0x336a8511>,
+				<0xa9040b11>, <0xa9044b11>, <0xa9048b11>,
+				<0x500b1411>, <0x500b5411>, <0x500b9411>,
+				<0x77771511>, <0x77775511>, <0x77779511>,
+				<0x00231711>, <0x00235711>, <0x00239711>,
+				<0x00632211>, <0x00636211>, <0x0063a211>,
+				<0xab762311>, <0xab766311>, <0xab76a311>;
+			tx-driving-tbl = // user can define tx driving here //
+					<0x40aa2011>, <0x40a86011>, <0x40a5a011>,
+					<0x88aa2111>, <0x88aa6111>, <0x38aaa111>;
+			rx-sense-tbl = // user can define rx sensitivity here //
+					<0x42100911>, <0x42104911>, <0x42108911>,
+					<0x276a0311>, <0x276a4311>, <0x27668311>;
+		};
+		sata-phy@1 {
+			reg = <1>;
+			resets = <&crst RSTN_SATA_MDIO1>,
+				<&crst RSTN_SATA_PHY_POW1>;
+			spread-spectrum = <0>;
+			phy-param = <0x70000211>, <0x70004211>, <0x70008211>,
+				<0x336a0511>, <0x336a4511>, <0x336a8511>,
+				<0xa9040b11>, <0xa9044b11>, <0xa9048b11>,
+				<0x500b1411>, <0x500b5411>, <0x500b9411>,
+				<0x77771511>, <0x77775511>, <0x77779511>,
+				<0x00231711>, <0x00235711>, <0x00239711>,
+				<0x00632211>, <0x00636211>, <0x0063a211>,
+				<0xab762311>, <0xab766311>, <0xab76a311>;
+			tx-driving-tbl = // user can define tx driving here //
+					<0x40a52011>, <0x40a46011>, <0x40a5a011>,
+					<0x484a2111>, <0x484a6111>, <0xa8aaa111>;
+			rx-sense-tbl = // user can define rx sensitivity here //
+					<0x42100911>, <0x42104911>, <0x42108911>,
+					<0x276a0311>, <0x276a4311>, <0x27668311>;
+		};
+	};
+
+	ahci_sata: sata@9803F000 {
+		clocks = <&clk_en_4 CLK_EN_SATA_MAC_SYSH>;
+		resets = <&crst RSTN_SATA_MAC_COM>;
+		hostinit-mode = <0>;
+		sata-port@0 {
+			reg = <0>;
+			phys = <&sata_phy 0>;
+			resets = <&crst RSTN_SATA_MAC_P0>;
+			gpios = <&rtk_iso_gpio 65 1 1>;
+		};
+		sata-port@1 {
+			reg = <1>;
+			phys = <&sata_phy 1>;
+			resets = <&crst RSTN_SATA_MAC_P1>;
+			gpios = <&rtk_iso_gpio 67 1 1>;
+		};
+	};
+};
diff --git a/rtd-1619-sata.dtsi_LS720D b/rtd-1619-sata.dtsi_LS720D
new file mode 100644
index 00000000..84fca15
--- /dev/null
+++ b/rtd-1619-sata.dtsi_LS720D
@@ -0,0 +1,69 @@
+#include <dt-bindings/reset/rtk,reset-rtd16xx.h>
+#include <dt-bindings/clock/rtk,clock-rtd16xx.h>
+/ {
+	/include/ "rtd-16xx-sata.dtsi"
+
+	sata_phy: sata_phy@9803FF60 {
+		clocks = <&clk_en_4 CLK_EN_SATA_WRAP_SYS>,
+			<&clk_en_4 CLK_EN_SATA_WRAP_SYSH>;
+		resets = <&crst RSTN_SATA_WRAP>;
+		sata-phy@0 {
+			reg = <0>;
+			resets = <&crst RSTN_SATA_MDIO0>,
+				<&crst RSTN_SATA_PHY_POW0>;
+			spread-spectrum = <0>;
+			phy-param = <0x70000211>, <0x70004211>, <0x70008211>,
+				<0x336a0511>, <0x336a4511>, <0x336a8511>,
+				<0xa9040b11>, <0xa9044b11>, <0xa9048b11>,
+				<0x500b1411>, <0x500b5411>, <0x500b9411>,
+				<0x77771511>, <0x77775511>, <0x77779511>,
+				<0x00231711>, <0x00235711>, <0x00239711>,
+				<0x00632211>, <0x00636211>, <0x0063a211>,
+				<0xab762311>, <0xab766311>, <0xab76a311>;
+			tx-driving-tbl = // user can define tx driving here //
+					<0x40a52011>, <0x40a46011>, <0x40a6a011>,
+					<0x585a2111>, <0x484a6111>, <0x387aa111>;
+			rx-sense-tbl = // user can define rx sensitivity here //
+					<0x42100911>, <0x42104911>, <0x42108911>,
+					<0x276a0311>, <0x276a4311>, <0x27668311>;
+		};
+		sata-phy@1 {
+			reg = <1>;
+			resets = <&crst RSTN_SATA_MDIO1>,
+				<&crst RSTN_SATA_PHY_POW1>;
+			spread-spectrum = <0>;
+			phy-param = <0x70000211>, <0x70004211>, <0x70008211>,
+				<0x336a0511>, <0x336a4511>, <0x336a8511>,
+				<0xa9040b11>, <0xa9044b11>, <0xa9048b11>,
+				<0x500b1411>, <0x500b5411>, <0x500b9411>,
+				<0x77771511>, <0x77775511>, <0x77779511>,
+				<0x00231711>, <0x00235711>, <0x00239711>,
+				<0x00632211>, <0x00636211>, <0x0063a211>,
+				<0xab762311>, <0xab766311>, <0xab76a311>;
+			tx-driving-tbl = // user can define tx driving here //
+					<0x40a42011>, <0x40a46011>, <0x40a6a011>,
+					<0x484a2111>, <0x484a6111>, <0x287aa111>;
+			rx-sense-tbl = // user can define rx sensitivity here //
+					<0x42100911>, <0x42104911>, <0x42108911>,
+					<0x276a0311>, <0x276a4311>, <0x27668311>;
+		};
+	};
+
+	ahci_sata: sata@9803F000 {
+		clocks = <&clk_en_4 CLK_EN_SATA_MAC_SYSH>;
+		resets = <&crst RSTN_SATA_MAC_COM>;
+		hostinit-mode = <0>;
+		sata-port@0 {
+			reg = <0>;
+			phys = <&sata_phy 0>;
+			resets = <&crst RSTN_SATA_MAC_P0>;
+			gpios = <&rtk_iso_gpio 65 1 1>;
+		};
+		sata-port@1 {
+			reg = <1>;
+			phys = <&sata_phy 1>;
+			resets = <&crst RSTN_SATA_MAC_P1>;
+			gpios = <&rtk_iso_gpio 67 1 1>;
+		};
+	};
+};
diff --git a/scripts/kconfig/Makefile b/scripts/kconfig/Makefile
index 90a091b..2ffbb13 100644
--- a/scripts/kconfig/Makefile
+++ b/scripts/kconfig/Makefile
@@ -109,7 +109,11 @@ endif
 endif
 
 %_defconfig: $(obj)/conf
-	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
+	$(Q)if [ -f $(srctree)/buffalo/arch/$(SRCARCH)/configs/$@ ]; then \
+		$< $(silent) --defconfig=buffalo/arch/$(SRCARCH)/configs/$@ $(Kconfig) ; \
+	else \
+		$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig) ; \
+	fi ;
 
 configfiles=$(wildcard $(srctree)/kernel/configs/$@ $(srctree)/arch/$(SRCARCH)/configs/$@)
 
